<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>制作支付宝的商家收钱码电子版</title>
    <url>/2018/03/25/2018-3-28-%E5%88%B6%E4%BD%9C%E6%94%AF%E4%BB%98%E5%AE%9D%E7%9A%84%E5%95%86%E5%AE%B6%E6%94%B6%E9%92%B1%E7%A0%81%E7%94%B5%E5%AD%90%E7%89%88/</url>
    <content><![CDATA[<h1 id="制作支付宝的商家收钱码电子版"><a href="#制作支付宝的商家收钱码电子版" class="headerlink" title="制作支付宝的商家收钱码电子版"></a>制作支付宝的商家收钱码电子版</h1><h2 id="申请商家收款码"><a href="#申请商家收款码" class="headerlink" title="申请商家收款码"></a>申请商家收款码</h2><p> 此过程通过支付宝官方渠道获取</p>
<h2 id="电脑获取收款码照片"><a href="#电脑获取收款码照片" class="headerlink" title="电脑获取收款码照片"></a>电脑获取收款码照片</h2><p> 手机拍照,然后通过QQ或者微信上传到电脑都可以</p>
<h2 id="识别二维码内容"><a href="#识别二维码内容" class="headerlink" title="识别二维码内容"></a>识别二维码内容</h2><p> <a href="https://cli.im/deqr">上传</a>二维码照片,识别出里面的网址<br>  <img src="https://note.youdao.com/yws/api/personal/file/47FD262ED6864770B0D4EE3BBF3163BD?method=download&shareKey=f56f8fd18e3e7b56dbde8707f094db49" alt="image"></p>
<h2 id="生成新的二维码图片"><a href="#生成新的二维码图片" class="headerlink" title="生成新的二维码图片"></a>生成新的二维码图片</h2><p> 复制扫描结果,生成新的二维码,然后就可以拿着这个去打印店打印各种尺寸的收款码了</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/3554F2F0E8344CD4A47ABD3DBDA4A272?method=download&shareKey=0cd9994e835acc81eb49dd94d524244e" alt="image"></p>
]]></content>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>2021-4-19- 从angularjs 迁移到vue</title>
    <url>/2021/04/19/2021-4-19-%20%E4%BB%8Eangularjs%20%E8%BF%81%E7%A7%BB%E5%88%B0vue/</url>
    <content><![CDATA[<p>由于历史原因，项目组维护的项目有 vue  angularjs  angular 多个包。招聘成本比较高，需要统一技术栈，全部使用vue重构。<br>这里记录下迁移过程，希望能帮助有需要的人。<br>本文记录从angularjs 迁移到vue ，后续angular 迁移到vue单独成文</p>
<h1 id="路由-ui-router-To-vue-router"><a href="#路由-ui-router-To-vue-router" class="headerlink" title="路由 ui-router To vue-router"></a>路由 ui-router To vue-router</h1><p><code>main.js</code>这部分直接重写</p>
<h1 id="多语言处理-angular-translate-To-vue-i18n"><a href="#多语言处理-angular-translate-To-vue-i18n" class="headerlink" title="多语言处理 angular-translate To vue-i18n"></a>多语言处理 angular-translate To vue-i18n</h1><h2 id="1-模板中的-translate"><a href="#1-模板中的-translate" class="headerlink" title="1. 模板中的 translate"></a>1. 模板中的 translate</h2><ol>
<li>使用正则替换 <code>translate\s?=\s?[&quot;&#39;](.*?)[&quot;&#39;]</code> <code>v-t=&quot;&#39;$1&#39;&quot;</code> , 替换下面这三种格式成指令<br><img src="https://upload-images.jianshu.io/upload_images/8156292-61c2d902fa125889.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li>
<li>定义全局指令 <code>v-t</code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Vue.directive(&#39;t&#39;, function (el,binding) &#123;</span><br><span class="line">    el.innerText&#x3D;binding.value</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
$如果有用到 filter的话就还要定义filter,我们项目没有这么用就没写 $<h2 id="2-js中的-translate-instant"><a href="#2-js中的-translate-instant" class="headerlink" title="2. js中的 $translate.instant"></a>2. js中的 $translate.instant</h2>在有注入<code>$translate</code>的地方导入 vue-i18n的实例<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> $translate <span class="keyword">from</span> <span class="string">&#x27;./i18n/&#x27;</span> <span class="comment">// 假设/i18n/index.js 默认导出的是vue-i18n的实例</span></span><br><span class="line">$translate.instant=$translate.t <span class="comment">//instant属性跟 vue-i18n的实例t是一样的</span></span><br></pre></td></tr></table></figure>
<h1 id="scope-与-http-处理"><a href="#scope-与-http-处理" class="headerlink" title="$scope 与 $http  处理"></a>$scope 与 $http  处理</h1>首先将模块从这个样子<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports=[<span class="string">&#x27;$scope&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">$scope,$http</span>)</span>&#123;</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure>
改成下面这个样子<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params">$scope,$http</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> $scope</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
这里我写了一个通用方法<code>getVueOptions</code>处理$scope<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这些代码写在一起是为了方便查看学习,项目中肯定会抽成模块</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> axios;<span class="comment">//使用axios代替$http</span></span><br><span class="line"><span class="keyword">const</span> instance=axios.create()</span><br><span class="line">instance.default.header.common[<span class="string">&#x27;content-type&#x27;</span>]=<span class="string">&#x27;application/json&#x27;</span></span><br><span class="line"><span class="comment">// 将$scope分解成vue组件的 methods 与 data</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getVueOptions</span>(<span class="params">$scope</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> options = &#123;</span><br><span class="line">    data: &#123;&#125;,</span><br><span class="line">    methods: &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> object) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.hasOwnProperty.call(object, key)) &#123;</span><br><span class="line">      <span class="keyword">const</span> element = object[key];</span><br><span class="line">      <span class="keyword">if</span> (element <span class="keyword">instanceof</span> <span class="built_in">Function</span>) &#123;</span><br><span class="line">        options.methods[key] = element</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        options.data[key] = element</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> options</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> scope=&#123;&#125;</span><br><span class="line"><span class="keyword">const</span> opts=getVueOptions(fn(scope,instance))</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      ...opts.data</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods:&#123;</span><br><span class="line">    ...opts.methods</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="ng-init-处理"><a href="#ng-init-处理" class="headerlink" title="ng-init 处理"></a>ng-init 处理</h1>这个放到 <code>mounted()</code>里面调用<code>this.xxx</code>即可</li>
</ol>
<h1 id="模板中的替换"><a href="#模板中的替换" class="headerlink" title="模板中的替换"></a>模板中的替换</h1><p>把angular组件模板<code>xx.html</code>,直接贴到vue组件的 <code>&lt;template&gt;&lt;div&gt;&lt;/div&gt;&lt;/template&gt;</code>中</p>
<p>搜索 <code> ng-</code> ng-前面有空格,如果是方法的话(ng-cick,ng-mouseover)就换成<code>@</code> ,属性(ng-class,ng-style)就换成<code>:</code>,指令(ng-if,ng-show,ng-model)就换成<code>v-</code></p>
<h2 id="属性绑定方式修改"><a href="#属性绑定方式修改" class="headerlink" title="属性绑定方式修改"></a>属性绑定方式修改</h2><p>正则模式搜索 <code>\s(.*?)\s?=\s?([&quot;&#39;])\&#123;\&#123;(.*?)\&#125;\&#125;\2</code> 替换成 <code>  :$1=&quot;$3&quot;</code><br><img src="https://upload-images.jianshu.io/upload_images/8156292-7eca4862d9bd6ee0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h1 id="rootScope-处理"><a href="#rootScope-处理" class="headerlink" title="rootScope 处理"></a>rootScope 处理</h1><p>我这项目没怎么用,如果有用到就 export导出下,利用provide注入到根组件,用到的地方 inject一下</p>
<h1 id="其他依赖注入"><a href="#其他依赖注入" class="headerlink" title="其他依赖注入"></a>其他依赖注入</h1><p>用类似axios的替换模式一个一个换成你vue的替代品即可,如果使用方式有差异就用正则查询全局替换就好了</p>
<h2 id="剩下的就是体力活儿了"><a href="#剩下的就是体力活儿了" class="headerlink" title="剩下的就是体力活儿了"></a>剩下的就是体力活儿了</h2><p><strong>组件</strong>  <strong>指令</strong>  <strong>过滤器</strong> 一个一个的重构就好了<br>组件的props有些是双向绑定的,可以使用vue的 <code>xxx.sync</code> <code>this.$emit(&#39;update:xxx&#39;)</code>的写法来搞定</p>
<p><strong>下一篇 ：</strong>《 typescript angular7 项目迁移到 vue2.x  》等我把改完再发心得</p>
]]></content>
      <tags>
        <tag>项目笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>2021-4-19-《使用 MonoRepo 管理前端项目》读后感</title>
    <url>/2021/04/19/2021-4-19-%E3%80%8A%E4%BD%BF%E7%94%A8%20MonoRepo%20%E7%AE%A1%E7%90%86%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%E3%80%8B%E8%AF%BB%E5%90%8E%E6%84%9F/</url>
    <content><![CDATA[<p>先阅读下这个文章《使用 MonoRepo 管理前端项目》   <a href="https://blog.csdn.net/qiwoo_weekly/article/details/112000852">https://blog.csdn.net/qiwoo_weekly/article/details/112000852</a><br>文章说的是，多npm包管理是每个包对应一个git仓好,还是一个包对应一个仓库好。<br>先表明我的观点：<strong>我支持multi-repo，一个包对应一个仓库</strong></p>
<h1 id="文中列出的multi-repo缺陷"><a href="#文中列出的multi-repo缺陷" class="headerlink" title="文中列出的multi-repo缺陷"></a>文中列出的multi-repo缺陷</h1><p><img src="https://upload-images.jianshu.io/upload_images/8156292-ab6c827fe620646d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<blockquote>
<p>“如果有脚手架” 难道现在还有不用脚手架的么？？？所以这是个伪命题，哪有这么多如果</p>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/8156292-2aa4f2c3921f9ac6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<blockquote>
<ol>
<li>硬盘问题：硬盘大的苹果本子太贵了??缺硬盘??10个项目的node_modules大概也就一部电影的大小,这又是个伪命题。</li>
<li>“每次有个新页面” webpack-plugin-html 不能解决?非要去创建新项目?至于说域名部署,shell脚本就可以处理了</li>
<li>“项目分散” vscode可以创建工作空间,工作空间可以添加项目文件夹 Ctrl+R 也是可以快速切换项目的</li>
</ol>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/8156292-5c1bb9c46fd41c06.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<blockquote>
<p>这个确实是问题,但是作为包的使用,调用方只关心输入与输出,而不应该关心包内部的实现细节。你在写自己的代码，还要调试被依赖的代码，这本身就是个错误的开发流程。如果A模块依赖B模块的功能，肯定需要B模块自身是稳定模块，如果处于开发中的状态，应该继续完善B模块。</p>
</blockquote>
<h1 id="文中提到的前后端放在一个仓库中"><a href="#文中提到的前后端放在一个仓库中" class="headerlink" title="文中提到的前后端放在一个仓库中"></a>文中提到的前后端放在一个仓库中</h1><blockquote>
<p>如果是小型项目是没问题的,大型项目CI/CD,lint什么的可能完全不一样,也不是很建议,要视情况而定</p>
</blockquote>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>MonoRepo 管理前端项目,确实有很多场景可以使用。但文中的理由都有点牵强，我认为开发过程中包会越来越多，越来越大。当项目小的时候就适合用MonoRepo 管理多个包，方便省事儿。等仓库达到一定的大小，比如50M的代码量，就要考虑分包，分库，分专人维护。一人—-一包—-一仓库，做到以人为本。。</p>
]]></content>
      <tags>
        <tag>读后感</tag>
      </tags>
  </entry>
  <entry>
    <title>2021年web安全问题Top10</title>
    <url>/2021/11/23/2021%E5%B9%B4web%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98Top10/</url>
    <content><![CDATA[<p>原文: <a href="https://owasp.org/Top10/zh_TW/">https://owasp.org/Top10/zh_TW/</a></p>
<h2 id="1-权限失效"><a href="#1-权限失效" class="headerlink" title="1. 权限失效"></a>1. 权限失效</h2><ul>
<li>横向越权 A用户能查看,编辑B用户的数据</li>
<li>纵向越权,特权提升 租户能看到管理员的数据,普通用户能看到租户的数据,未登录的用户能看到登录用户的功能</li>
<li>通过修改URL,应用状态,不应该访问到的页面可以被访问到,通过API攻击工具,绕过页面鉴权</li>
<li>CROS配置错误,可以让未经授权的API存取</li>
</ul>
<h2 id="2-加密机制失效"><a href="#2-加密机制失效" class="headerlink" title="2. 加密机制失效"></a>2. 加密机制失效</h2><ul>
<li>使用了老旧的加密算法</li>
<li>密码多系统重复使用</li>
<li>明文存储密码</li>
<li>以http smtp fpt 等协议明文传输</li>
<li>使用默认密码</li>
<li>密码过期机制</li>
<li>密码没有被加盐加密存储</li>
</ul>
<h2 id="3-注入攻击"><a href="#3-注入攻击" class="headerlink" title="3. 注入攻击"></a>3. 注入攻击</h2><ul>
<li>使用者提供的数据应该被处理,验证,过滤后保存</li>
<li>查询参数没有被转义,尽量做到无参数调用</li>
<li>ORM 对象查询参数注入</li>
<li>SQL注入</li>
</ul>
<h2 id="4-不安全设计"><a href="#4-不安全设计" class="headerlink" title="4. 不安全设计"></a>4. 不安全设计</h2><ul>
<li>使用安全问题找回密码,可能问题不止本人一个人知道</li>
<li>预定团体票折扣,没有设置最大人数限制，而且押金只需要支付15人。被人恶意一次性订购了600张电影票，或者全部的电影票</li>
<li>订票软件没有防机器人抢票，票都被黄牛抢了</li>
</ul>
<h2 id="5-安全配置错误"><a href="#5-安全配置错误" class="headerlink" title="5. 安全配置错误"></a>5. 安全配置错误</h2><ul>
<li>启用或安装了不必要的功能（例如，不必要的端口、服务、页面、帐户或权限）。</li>
<li>启用了默认账户密码，且未被修改</li>
<li>云服务配置错误</li>
<li>错误堆栈直接暴露到客户端，比如默认的500返回</li>
<li>对于已升级的新系统，最新的安全功能处于禁用状态或未安全配置。</li>
<li>应用程序服务器、应用程序框架（例如，Struts、Spring、ASP.NET）、库、数据库等中的安全性设置未设置为安全值。</li>
<li>服务器不发送安全标头或指令，或者它们未设置为安全值。</li>
</ul>
<h2 id="6-危险或过时的组件"><a href="#6-危险或过时的组件" class="headerlink" title="6. 危险或过时的组件"></a>6. 危险或过时的组件</h2><ul>
<li>定期升级，维护软件依赖</li>
<li>删除未使用的依赖项</li>
<li>测试软件升级后的兼容性</li>
<li>使用官方安全来源获取组件</li>
<li>订阅使用组件的安全漏洞的邮件警报</li>
</ul>
<h2 id="7-认证和验证机制失效"><a href="#7-认证和验证机制失效" class="headerlink" title="7. 认证和验证机制失效"></a>7. 认证和验证机制失效</h2><ul>
<li>密码被暴力破解,自动攻击</li>
<li>默认密码、弱密码、</li>
<li>在url中公开会话标识符</li>
<li>成功登录后重用会话标识符</li>
<li>会话失效后,SSO没有注销登录</li>
</ul>
<h2 id="8-软件及数据完整性失效"><a href="#8-软件及数据完整性失效" class="headerlink" title="8. 软件及数据完整性失效"></a>8. 软件及数据完整性失效</h2><ul>
<li><p>使用三方CDN,不安全的CI/CD管道,但是三方依赖被修改了,使用数字签名来避免</p>
</li>
<li><p>npm  Maven 使用受信赖的源</p>
</li>
<li><p>使用软件供应链安全工具 OWASP CycloneDX</p>
</li>
<li><p>代码检查</p>
</li>
<li><p>CI/CD过程的权限控制,隔离控制,比如特定程序才有执行权限,目录权限</p>
</li>
<li><p>未被签名或者未被加密的序列化数据发送到不受信任的客户端(比如使用了云服务的静态资源托管,上传完成后应该把文件签名保存下来,下载之前应该比对签名后,再发送到客户端)</p>
<h2 id="9-安全日志记录及监控失效"><a href="#9-安全日志记录及监控失效" class="headerlink" title="9. 安全日志记录及监控失效"></a>9. 安全日志记录及监控失效</h2></li>
<li><p>确保所有登录、访问控制和服务器端输入验证失败都可以使用足够的用户上下文进行记录，以识别可疑或恶意帐户，并保留足够的时间以允许延迟取证分析。</p>
</li>
<li><p>确保以日志管理解决方案可以轻松使用的格式生成日志。</p>
</li>
<li><p>确保对日志数据进行正确编码，以防止对日志记录或监视系统进行注入或攻击。</p>
</li>
<li><p>确保高价值事务具有具有完整性控制的审计跟踪，以防止篡改或删除，例如仅追加数据库表或类似内容。</p>
</li>
<li><p>DevSecOps 团队应建立有效的监视和警报，以便快速检测和响应可疑活动。</p>
</li>
<li><p>建立或采用事件响应和恢复计划，例如美国国家标准与技术研究院 （NIST） 800-61r2 或更高版本。</p>
</li>
</ul>
<h2 id="10-服务器端请求伪造-SSRF"><a href="#10-服务器端请求伪造-SSRF" class="headerlink" title="10.服务器端请求伪造(SSRF)"></a>10.服务器端请求伪造(SSRF)</h2><p>服务器A与服务器B在内网连接,服务器A对外提供服务,且有SSRF漏洞,攻击者通过服务器A获取服务器B的相关信息。</p>
<h3 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h3><ul>
<li>利用file协议读取本地文件</li>
<li>对服务器所在内网、本地进行端口扫描，获取一些服务的banner信息</li>
<li>攻击运行在内网或本地的应用程序</li>
<li>对内网web应用进行指纹识别，识别企业内部的资产信息</li>
<li>攻击内外网的web应用，主要是使用HTTP GET请求就可以实现的攻击</li>
</ul>
<h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><ul>
<li><p>file协议： 只能读取当前被攻击机的文件，内网机器文件不能读取</p>
</li>
<li><p>dict协议：泄露安装软件版本信息，查看端口，操作内网redis服务等</p>
</li>
<li><p>gopher协议：gopher支持发出GET、POST请求。可以先截获get请求包和post请求包，再构造成符合gopher协议的请求。gopher协议是ssrf利用中一个最强大的协议(俗称万能协议)。可用于反弹shell</p>
</li>
<li><p>http/s协议：探测内网主机存活</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>web安全</tag>
      </tags>
  </entry>
  <entry>
    <title>2021年度最佳开源软件</title>
    <url>/2021/11/09/2021%E5%B9%B4%E5%BA%A6%E6%9C%80%E4%BD%B3%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6/</url>
    <content><![CDATA[<p><a href="https://baijiahao.baidu.com/s?id=1714115486438973511&amp;wfr=spider&amp;for=pc">https://baijiahao.baidu.com/s?id=1714115486438973511&amp;wfr=spider&amp;for=pc</a></p>
<h2 id="前端能用到的"><a href="#前端能用到的" class="headerlink" title="前端能用到的"></a>前端能用到的</h2><h3 id="Svelte"><a href="#Svelte" class="headerlink" title="Svelte"></a>Svelte</h3><p>编译时前端框架，拥有SSR的性能，但是不需要服务器,编译结果仍然是纯粹的静态资源。</p>
<p>vue的<code>petite-vue</code>项目也值得关注下，我觉得也够用了。由于web component 标准慢慢被主流浏览器支持，后面的趋势应该是各种框架都编译成 web component，进行发布。</p>
<h3 id="FastAPI"><a href="#FastAPI" class="headerlink" title="FastAPI"></a>FastAPI</h3><p>用于快速构建API，完全兼容 openAPI  Python项目</p>
<h3 id="Apache-Superset"><a href="#Apache-Superset" class="headerlink" title="Apache Superset"></a>Apache Superset</h3><p>作为企业数据收集与展示仓库，支持很多图表，开箱即用。突然发现里面的功能很多跟三朵云里面数据集的功能一致呀！我们SE在这上面找设计灵感？？</p>
<h3 id="PostHog"><a href="#PostHog" class="headerlink" title="PostHog"></a>PostHog</h3><p>监控软件，应该跟打点埋码相关吧，另外推荐个异常监控系统 <a href="https://sentry.io/welcome/">哨兵 sentry</a></p>
<p>剩下的都是些  AI  深度学习 集群 分布式 数据管理相关的开源项目了。</p>
]]></content>
      <tags>
        <tag>新闻</tag>
      </tags>
  </entry>
  <entry>
    <title>Chrome dev Tools 打开缓慢</title>
    <url>/2022/08/15/Chrome-dev-Tools-%E6%89%93%E5%BC%80%E7%BC%93%E6%85%A2/</url>
    <content><![CDATA[<p>之前把开发者工具设置成中文了，然后发现还是英文用着习惯了，就切回了英文。但是切的是UK而不是US，导致打开的时候巨慢。</p>
<p>遇到同样问题的同学一定记得语言要切回US才行</p>
]]></content>
      <tags>
        <tag>devtools</tag>
      </tags>
  </entry>
  <entry>
    <title>babel与core-js</title>
    <url>/2021/12/09/babel%E4%B8%8Ecore-js%E7%9A%84%E5%85%B3%E7%B3%BB/</url>
    <content><![CDATA[<h1 id="babel-垫片是什么"><a href="#babel-垫片是什么" class="headerlink" title="babel,垫片是什么?"></a>babel,垫片是什么?</h1><ol>
<li>babel 是用来把ES6,ESNext语法转换成ES5语法的,本身没有垫片的功能</li>
<li>垫片就是给一些低版本的浏览器实现一些新的API,比如数组的<code>includes</code> <code>find</code>,<code>Promsie</code>等实现</li>
<li><code>@babel/polifill</code> 这个垫片是babel官方提供的,相当于全量引入了长期支持的API,以及使用了的部分API<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;@babel/polyfill&quot;</span>;</span><br><span class="line"><span class="comment">// 等同于下面两句</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;core-js/stable&quot;</span>;<span class="comment">//长期支持的</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;regenerator-runtime/runtime&quot;</span>;<span class="comment">//部分使用的</span></span><br></pre></td></tr></table></figure></li>
<li>目前我们一般用 <code>@babel/preset-env</code>根据使用的API动态的使用垫片,项目中没用过的就不用垫了。</li>
<li><code>core-js</code>是一个专门的垫片仓库</li>
<li><code>@babel/preset-env</code> 的配置项 <code>useBuiltIns</code>有<code>entry</code> 与 <code>usage</code>两个选项,默认值是<code>false</code>,全量引入，体积最大。</li>
<li><code>entry</code>需要手动在代码入口加上 <code>import &#39;@babel/polyfill&#39;</code>,表示按照目标兼容浏览器版本全量加载，体积小一些。</li>
<li><code>usage</code>表示根据API按需加载，体积最小。</li>
<li><code>@babel/preset-env</code>的配置项 <code>corejs:2</code>默认是<code>2.x</code>,如果需要使用<code>core-js@3</code>需要修改这个配置项<code>corejs:3</code></li>
<li>babel在转换语法的时候会自动生成一些辅助函数,这些辅助函数大量重复存在</li>
<li><code>core-js</code>的垫片会直接修改API 的原型与全局方法</li>
<li><code>@babel/plugin-transform-runtime</code>插件会做两件事,第一辅助函数一次性引入,防止重复。第二，垫片作为闭包方法调用，防止全局污染</li>
</ol>
<h1 id="最佳实践的babel配置"><a href="#最佳实践的babel配置" class="headerlink" title="最佳实践的babel配置"></a>最佳实践的babel配置</h1><p><code>npm i @babel/core、@babel/preset-env @babel/runtime-corejs3 @babel/plugin-transform-runtime</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;presets&quot;</span>: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">&quot;@babel/preset-env&quot;</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">&quot;useBuiltIns&quot;</span>: <span class="string">&quot;usage&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  ],</span><br><span class="line">  <span class="string">&quot;plugins&quot;</span>: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">&quot;@babel/plugin-transform-runtime&quot;</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">&quot;corejs&quot;</span>: <span class="number">3</span> <span class="comment">// 指定 runtime-corejs 的版本，目前有 2 3 两个版本</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>core-js 是一个通用的垫片仓库,babel的垫片相关功能依赖core-js</p>
<p><a href="http://www.ruanyifeng.com/blog/2016/01/babel.html">http://www.ruanyifeng.com/blog/2016/01/babel.html</a></p>
]]></content>
      <tags>
        <tag>babel</tag>
      </tags>
  </entry>
  <entry>
    <title>burp suite</title>
    <url>/2021/09/26/burp-suite/</url>
    <content><![CDATA[<p>集成化的渗透测试工具<br><a href="https://t0data.gitbooks.io/burpsuite/content/">Burp Suite 实战指南</a></p>
<p>抓包功能也是吊打fiddler,真心好用</p>
<p>Burp Suite 配合 AWVS web网络漏洞扫描工具使用</p>
<p>DFNRecorder用来模拟登录的,类似于webDriver 是IBM Security APPScan Standard的一部分</p>
]]></content>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title>defer async的区别</title>
    <url>/2021/09/25/defer-async%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p><img src="http://segmentfault.com/img/bVcQV0" alt="图片"></p>
<ol>
<li><code>defer</code> 能确保脚本加载的顺序,会在dom解析完成后执行</li>
<li><code>async</code> 是先请求到先加载,会中断dom解析</li>
<li>ES6 Module 有 <code>type=module</code> 默认defer模式</li>
<li><code>async</code>适合完全独立的脚本</li>
</ol>
]]></content>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>js踩坑 isNaN(null)返回的是false</title>
    <url>/2022/08/15/js%E8%B8%A9%E5%9D%91-isNaN-null-%E8%BF%94%E5%9B%9E%E7%9A%84%E6%98%AFfalse/</url>
    <content><![CDATA[<p><code>isNaN(null) === false</code> 按照方法名的字面意思  null不是一个数组,没毛病。<br>但是这个方法认为是一个数字，它的逻辑是先用<code>Number(null)</code>得到<code>0</code>,0是数字,所以等式成立。</p>
<p><code>[&#39;&#39;]==false</code>这个也是成立的哟</p>
<ul>
<li>隐式转换规则,跟字符串比都转字符串比较,跟数字比转数字,布尔值当数字<code>0</code>跟<code>1</code>看待,对象的话用<code>valueOf</code>拿值,拿到的如果不是原始值就<code>toString</code>后比较</li>
<li><code>[&#39;&#39;].toString()</code>得到’’ 右边是false</li>
</ul>
]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>js避坑-new Array</title>
    <url>/2022/08/15/js%E9%81%BF%E5%9D%91-new-Array/</url>
    <content><![CDATA[<p><code>new Array(8).map(i=&gt;[])</code>这种声明二维数组的方式会报错</p>
<p>改成 <code>new Array(8).fill().map(i=&gt;[])</code>即可</p>
<p>报错的原因是 new Array 产生的数组比较特殊 有length 但是没有内容，所以无法迭代</p>
<p>不过我一般用 <code>Array.form(&#123;length:8&#125;,i=&gt;[])</code>这么初始化</p>
]]></content>
  </entry>
  <entry>
    <title>promise分步请求接口</title>
    <url>/2021/09/26/promise%E5%88%86%E6%AD%A5%E8%AF%B7%E6%B1%82%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>并发请求后台接口,处理时间过长,导致服务器超载挂掉,尤其是用户刷新页面操作,需要前端限制请求并发</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [</span><br><span class="line">  &#123; <span class="attr">url</span>: <span class="string">&#x27;xxx&#x27;</span>, <span class="attr">data</span>: &#123;&#125; &#125;,</span><br><span class="line">  &#123; <span class="attr">url</span>: <span class="string">&#x27;xxx&#x27;</span>, <span class="attr">data</span>: &#123;&#125; &#125;,</span><br><span class="line">  &#123; <span class="attr">url</span>: <span class="string">&#x27;xxx&#x27;</span>, <span class="attr">data</span>: &#123;&#125; &#125;,</span><br><span class="line">  &#123; <span class="attr">url</span>: <span class="string">&#x27;xxx&#x27;</span>, <span class="attr">data</span>: &#123;&#125; &#125;,</span><br><span class="line">  &#123; <span class="attr">url</span>: <span class="string">&#x27;xxx&#x27;</span>, <span class="attr">data</span>: &#123;&#125; &#125;,</span><br><span class="line">  &#123; <span class="attr">url</span>: <span class="string">&#x27;xxx&#x27;</span>, <span class="attr">data</span>: &#123;&#125; &#125;,</span><br><span class="line">  &#123; <span class="attr">url</span>: <span class="string">&#x27;xxx&#x27;</span>, <span class="attr">data</span>: &#123;&#125; &#125;</span><br><span class="line">]</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">SubmitMsg</span>(<span class="params">datas, count</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (datas.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> urls = datas.splice(<span class="number">0</span>, count)</span><br><span class="line">    <span class="keyword">let</span> ret = <span class="keyword">await</span> <span class="built_in">Promise</span>.all(urls.map(getData))</span><br><span class="line">    <span class="built_in">console</span>.log(ret);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params">&#123; url, data &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> axios.post(url, data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SubmitMsg(arr,<span class="number">2</span>) <span class="comment">//每次发送两个请求</span></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>代码片段</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack-dev-server代理host配置</title>
    <url>/2021/09/25/webpack-dev-server%E4%BB%A3%E7%90%86host%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="让同事可以访问本地服务"><a href="#让同事可以访问本地服务" class="headerlink" title="让同事可以访问本地服务"></a>让同事可以访问本地服务</h1><p><code>devServer.host</code>配置成 <code>0.0.0.0</code>或者是本机的IP,host默认值是<code>localhost</code>,只能自己访问</p>
<h1 id="登录的问题"><a href="#登录的问题" class="headerlink" title="登录的问题"></a>登录的问题</h1><p>访问接口需要鉴权,通过IP访问的话 huawei.com 的cookie不能携带,导致要求登录。我们可以修改本机的DNS解析<code>C:\Windows\System32\drivers\etc</code>，将<code>127.0.0.1</code>解析到 <code>localhost.huawei.com</code>  。然后通过<code>localhost.huawei.com</code>去访问本地调试地址。</p>
<h1 id="Invalid-Host-Header"><a href="#Invalid-Host-Header" class="headerlink" title="Invalid Host Header"></a>Invalid Host Header</h1><p>如果页面出现这个报错，需要修改webpack配置  <code>devServer.disableHostCheck</code>为<code>true</code></p>
<blockquote>
<p>cmd  <code>ipconfig</code>可以查看自己的ip</p>
</blockquote>
]]></content>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>一个10年工程师的感慨</title>
    <url>/2021/09/25/%E4%B8%80%E4%B8%AA10%E5%B9%B4%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%9A%84%E6%84%9F%E6%85%A8/</url>
    <content><![CDATA[<p>原文 <a href="https://old.reddit.com/r/ExperiencedDevs/comments/nmodyl/drunk_post_things_ive_learned_as_a_sr_engineer/">https://old.reddit.com/r/ExperiencedDevs/comments/nmodyl/drunk_post_things_ive_learned_as_a_sr_engineer/</a></p>
]]></content>
      <tags>
        <tag>好文</tag>
      </tags>
  </entry>
  <entry>
    <title>web技术方向的思考</title>
    <url>/2024/11/11/web%E6%8A%80%E6%9C%AF%E6%96%B9%E5%90%91%E7%9A%84%E6%80%9D%E8%80%83/</url>
    <content><![CDATA[<p>好久没写文章了，适当的回顾下过去展望下未来总是好的。</p>
<ol>
<li>先说前端框架，jsx,SSR逐渐流行，相当于是PHP跟JSP的复兴，跟10年前最大的区别是统一成nodejs技术栈了。 </li>
<li>微前端架构主要解决的事老旧系统的集成问题，主要适用于大厂，如果是新兴创业公司，不适合盲目跟风。个人感觉直接ESM的原生解决方案更优秀。样式的话支持tailwindcss整合起来。</li>
<li>ES标准化目前都是些语法糖，没发现很大意义的创新。</li>
<li>低代码的维护与调试成本远远高于开发成本，所以如果是一次性的页面，比如活动页，商品展示页，增删改查管理页，强烈建议安排上。但是复杂交互的页面还是高码更好，选择低码平台的话一定要选择支持高低码结合的。</li>
<li>AI方向的话，cursor编辑器强烈安利给大家，花钱也是值得的。最好的功能是它生成的代码能够一键给整合到现有代码中自动diff。v0/vue0 也是不错的，但是cursor用好，vue0我觉得是可有可无。</li>
<li>鸿蒙这个方向，华为可以说是对前端开后门了，会TS就直接上吧。当然uniapp后面也会支持鸿蒙，应该这个优先级会比写原生高吗？</li>
<li>wasm感觉适用于特定场景，比如web端边缘计算。比如nodejs诟病的读写性能问题，直接适用wasm模块，效果嘎嘎好。</li>
<li>跨平台当然还是Electron，Tauri应该是未来，建议再看两年，毕竟QQ都没用，咱就不试了。</li>
<li>3D渲染引擎，Three.js是主流，这个没得选真好。对有选择困难症的我真友好</li>
<li>GIS还是老三件，Leaflet,Mapbox,OpenLayers。Leaflet是轻量级，Mapbox是商业，OpenLayers是开源。</li>
<li>视频播放器，我就安利个西瓜播放器吧，功能齐全，支持定制。</li>
<li>音频播放器，推荐个APlayer吧，功能齐全，支持定制。</li>
<li>网络请求，axios是主流，但是目前感觉fetch已经足够用了，而且支持ESM，不用额外引入。</li>
<li>前端UI框架，Vuetify是主流，Material-UI是备选，Element-Plus是备选，Ant Design Vue是备选。</li>
<li>后端框架，Koa是主流，Express是备选，Nest.js是备选。</li>
<li>构建的话，字节的repack,vue的vite要统一dev跟preview了，期待！</li>
<li>容器化推荐个sealos，他们还有个fastGTP的产品很不错，有点扣子的味道，都支持私有化部署。</li>
<li>前端团队组件分享建议用bit.dev，小团队直接用免费的，团队大了也支持私有化部署</li>
<li>CI/CD前端建议私有化部署sealos，利用S3的桶去承载web静态资源</li>
</ol>
]]></content>
      <tags>
        <tag>思考未来</tag>
      </tags>
  </entry>
  <entry>
    <title>一个在线压缩图片的大小的网站</title>
    <url>/2021/09/25/%E4%B8%80%E4%B8%AA%E5%9C%A8%E7%BA%BF%E5%8E%8B%E7%BC%A9%E5%9B%BE%E7%89%87%E7%9A%84%E5%A4%A7%E5%B0%8F%E7%9A%84%E7%BD%91%E7%AB%99/</url>
    <content><![CDATA[<p><a href="https://tinypng.com/">https://tinypng.com/</a> </p>
]]></content>
      <tags>
        <tag>图片处理</tag>
      </tags>
  </entry>
  <entry>
    <title>几款基于Ai的智能补全vscode插件</title>
    <url>/2021/09/25/%E5%87%A0%E6%AC%BE%E5%9F%BA%E4%BA%8EAi%E7%9A%84%E6%99%BA%E8%83%BD%E8%A1%A5%E5%85%A8vscode%E6%8F%92%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="Github-Copilot"><a href="#Github-Copilot" class="headerlink" title="Github Copilot"></a>Github Copilot</h2><p>基于GitHub上的代码,训练出来的AI补全,需要准确描述函数的作用,它去找相似的</p>
<h2 id="tabnine"><a href="#tabnine" class="headerlink" title="tabnine"></a>tabnine</h2><p>基于自己写过的代码做自动补全</p>
<h2 id="HicodeAI"><a href="#HicodeAI" class="headerlink" title="HicodeAI"></a>HicodeAI</h2><p>华为自研的,不知道借鉴的哪一种</p>
]]></content>
      <tags>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title>前端开发文档之devdocs</title>
    <url>/2021/09/13/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3%E4%B9%8Bdevdocs/</url>
    <content><![CDATA[<p>devdocs.io 是一个在线的web开发文档在线站点，收藏了500+的前端开发文档，还支持离线模式。很适合部署在公司内网中。</p>
<p>如果是我的话，可能会开发一个Chrome插件，用于替换Chrome的欢迎页面，然后把我收藏的所有开发文档做成一个欢迎页。</p>
<p>真是个好想法，行动起来。<br>先给你们一个仓库地址 <a href="https://github.com/alasq/web.devdocs.chrome.welcome">web.devdocs.chrome.welcome</a> 大家可以贡献代码</p>
]]></content>
      <tags>
        <tag>dev</tag>
      </tags>
  </entry>
  <entry>
    <title>前端架构 webpack5 Module Federation</title>
    <url>/2021/11/27/%E5%89%8D%E7%AB%AF%E6%9E%B6%E6%9E%84-webpack5-Module-Federation/</url>
    <content><![CDATA[<h1 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h1><p>A组: 维护一个UI组件库<br>B组: 维护一个单页APP,内部有很多公共函数库,业务相关组件<br>C组: 新建一个单页APP,需要用到A组的UI组件库,B组项目的公共函数库,部分业务组件</p>
<h1 id="前端模块化的现有方案"><a href="#前端模块化的现有方案" class="headerlink" title="前端模块化的现有方案"></a>前端模块化的现有方案</h1><p>A组将UI库发布到npm仓库,B组将公共函数库作为单独的npm包发布,业务组件拷贝一份到C组的代码库</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ol>
<li>B组的改动量大</li>
<li>B组每次公共函数库的改动,需要通知到C组重新发布</li>
<li>业务组件改动,BC两组都要进行修改</li>
</ol>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>函数库与业务组件都打成umd模块放到静态资源服务器上,C组以script标签动态引入,以AMD模块的使用方式从window作用域下使用</p>
<h2 id="继而产生的后续问题"><a href="#继而产生的后续问题" class="headerlink" title="继而产生的后续问题"></a>继而产生的后续问题</h2><ol>
<li>污染window作用域下命名空间</li>
<li>打出来的umd模块需要是完整的,包含全部依赖,体积很大</li>
<li>随着要封装暴露的entry越来越多,打包时间越来越长</li>
</ol>
<h1 id="Module-Federation-模块共享解决方案"><a href="#Module-Federation-模块共享解决方案" class="headerlink" title="Module Federation 模块共享解决方案"></a>Module Federation 模块共享解决方案</h1><h2 id="B组项目修改webpack配置-将公共函数库-公用的业务组件使用ModuleFederationPlugin-插件配置成共享模块"><a href="#B组项目修改webpack配置-将公共函数库-公用的业务组件使用ModuleFederationPlugin-插件配置成共享模块" class="headerlink" title="B组项目修改webpack配置,将公共函数库,公用的业务组件使用ModuleFederationPlugin 插件配置成共享模块"></a>B组项目修改webpack配置,将公共函数库,公用的业务组件使用<code>ModuleFederationPlugin</code> 插件配置成共享模块</h2><figure class="highlight js"><figcaption><span>B组项目webpack配置</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// 假设B组的页面部署到 www.baidu.com/businessB/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123;ModuleFederationPlugin&#125;=<span class="built_in">require</span>(<span class="string">&quot;webpack&quot;</span>).container</span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">   ...otherConfigs</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> ModuleFederationPlugin(&#123;</span><br><span class="line">      name: <span class="string">&quot;appB&quot;</span>,</span><br><span class="line">      filename:<span class="string">&quot;remoteEntry.js&quot;</span>,</span><br><span class="line">      exposes: &#123;</span><br><span class="line">        <span class="string">&#x27;./util&#x27;</span>: <span class="string">&#x27;./src/util&#x27;</span>, <span class="comment">//需要共享的公共函数库 </span></span><br><span class="line">        <span class="string">&#x27;./hero-list&#x27;</span>: <span class="string">&#x27;./src/components/hero-list&#x27;</span>,<span class="comment">//需要共享的业务组件 英雄列表</span></span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="C组使用ModuleFederationPlugin-插件配置配置B组发布到环境上的远程模块"><a href="#C组使用ModuleFederationPlugin-插件配置配置B组发布到环境上的远程模块" class="headerlink" title="C组使用ModuleFederationPlugin 插件配置配置B组发布到环境上的远程模块"></a>C组使用<code>ModuleFederationPlugin</code> 插件配置配置B组发布到环境上的远程模块</h2><p>假设C组的页面部署到 <a href="http://www.baidu.com/businessC/">www.baidu.com/businessC/</a></p>
<figure class="highlight js"><figcaption><span>C组项目webpack配置</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">   ...otherConfigs</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> ModuleFederationPlugin(&#123;</span><br><span class="line">      remotes: &#123;</span><br><span class="line">        appB: <span class="string">&quot;appB@//www.baidu.com/businessB/remoteEntry.js&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><figcaption><span>C组的主页面</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;/businessB/remoteEntry.js&quot;</span> <span class="attr">defer</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./main.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span> </span><br></pre></td></tr></table></figure>
<figure class="highlight js"><figcaption><span>main.js</span></figcaption><table><tr><td class="code"><pre><span class="line">(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> util = <span class="keyword">await</span> <span class="keyword">import</span>(<span class="string">&#x27;appB/util&#x27;</span>)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><figcaption><span>component.vue</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">  components:&#123;</span><br><span class="line"><span class="javascript">    heroList:<span class="function">()=&gt;</span><span class="keyword">import</span>(<span class="string">&quot;appB/hero-list&quot;</span>)</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="完整的-DEMO"><a href="#完整的-DEMO" class="headerlink" title="完整的 DEMO"></a>完整的 DEMO</h2><p><a href="https://stackblitz.com/github/webpack/webpack.js.org/tree/master/examples/module-federation?terminal=start&amp;terminal=">https://stackblitz.com/github/webpack/webpack.js.org/tree/master/examples/module-federation?terminal=start&amp;terminal=</a></p>
<h3 id="external-remotes-plugin-可以从window作用域下动态获取远程仓库的地址"><a href="#external-remotes-plugin-可以从window作用域下动态获取远程仓库的地址" class="headerlink" title="external-remotes-plugin 可以从window作用域下动态获取远程仓库的地址"></a>external-remotes-plugin 可以从window作用域下动态获取远程仓库的地址</h3><p><a href="https://www.npmjs.com/package/external-remotes-plugin">https://www.npmjs.com/package/external-remotes-plugin</a></p>
<figure class="highlight js"><figcaption><span>host config</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">   ...otherConfigs</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> ModuleFederationPlugin(&#123;</span><br><span class="line">      name: <span class="string">&quot;app1&quot;</span>,</span><br><span class="line">      remotes: &#123;</span><br><span class="line">        app2: <span class="string">&quot;app2@[window.app2Url]/remoteEntry.js&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;).</span><br><span class="line">    <span class="keyword">new</span> ExternalTemplateRemotesPlugin(),</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><figcaption><span>host main.js</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.app2Url = <span class="string">&quot;//localhost:3002&quot;</span>; <span class="comment">// Whatever the url/logic to determine your remote module is</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span>(<span class="string">&quot;./bootstrap&quot;</span>);</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>webpack</tag>
        <tag>前端架构</tag>
      </tags>
  </entry>
  <entry>
    <title>单页应用路由切换接口问题</title>
    <url>/2021/11/25/%E5%8D%95%E9%A1%B5%E5%BA%94%E7%94%A8%E8%B7%AF%E7%94%B1%E5%88%87%E6%8D%A2%E6%8E%A5%E5%8F%A3%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>页面跳转的时候,处于异步请求的接口会自动被去取消掉，但是单页应用没有这种机制。我们需要手动实现。<br>axios是基于Promise的。本身对外暴露了一个 cancelToken的配置项用于取消,实际开发中需要在路由跳转的钩子中使用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> CancelToken = axios.CancelToken;</span><br><span class="line"><span class="keyword">const</span> source = CancelToken.source();</span><br><span class="line"></span><br><span class="line">axios.get(<span class="string">&#x27;/user/12345&#x27;</span>, &#123;</span><br><span class="line">  cancelToken: source.token</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">thrown</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (axios.isCancel(thrown)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Request canceled&#x27;</span>, thrown.message);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="comment">// 处理错误</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">axios.post(<span class="string">&#x27;/user/12345&#x27;</span>, &#123;</span><br><span class="line">  name: <span class="string">&#x27;new name&#x27;</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">  cancelToken: source.token</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取消请求（message 参数是可选的）</span></span><br><span class="line">source.cancel(<span class="string">&#x27;Operation canceled by the user.&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>底层实现主要依靠  </p>
<p><code>xhr abort</code><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/abort">https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/abort</a></p>
<p><code>AbortController</code>与<code>fetch</code><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/AbortController">https://developer.mozilla.org/zh-CN/docs/Web/API/AbortController</a></p>
]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>图片base64转文件</title>
    <url>/2021/09/26/%E5%9B%BE%E7%89%87base64%E8%BD%AC%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * base64格式图片转二进制文件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> </span>base64str </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns  </span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">base64ToFile</span>(<span class="params">base64str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> mimeType=base64str.match(<span class="regexp">/:(.*?);/</span>)[<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">let</span> base64=base64str.slice(base64str.indexOf(<span class="string">&#x27;;&#x27;</span>)+<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">let</span> bstr=atob(base64),</span><br><span class="line">  n=bstr.length,</span><br><span class="line">  u8Arr=<span class="keyword">new</span> <span class="built_in">Uint8Array</span>(n);</span><br><span class="line">  <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">    u8Arr[n]=bstr.charCodeAt(n);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> file=<span class="keyword">new</span> Blob([u8Arr],&#123;<span class="attr">type</span>:mimeType&#125;)</span><br><span class="line">  <span class="keyword">return</span> file</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>代码片段</tag>
      </tags>
  </entry>
  <entry>
    <title>图片打包优化</title>
    <url>/2022/08/15/%E5%9B%BE%E7%89%87%E6%89%93%E5%8C%85%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p>UI设计师给的图片（Icon）有时候出奇的大</p>
<p>有两种方案解决，精灵图（雪碧图），不过这种要输出css文件，还要改代码。不想动代码的情况下，我们直接使用另一种 无损压缩下图片再替换掉原图提交到代码仓库即可</p>
<h1 id="使用PS批处理图片"><a href="#使用PS批处理图片" class="headerlink" title="使用PS批处理图片"></a>使用PS批处理图片</h1><ol>
<li>录制动作-》打开图片-》储存为web格式-》保存动作</li>
<li>文件-》自动-》批处理-》选中文件夹-》选中刚保存的动作</li>
</ol>
<h1 id="使用npm图片压缩工具-imgmin"><a href="#使用npm图片压缩工具-imgmin" class="headerlink" title="使用npm图片压缩工具 imgmin"></a>使用npm图片压缩工具 imgmin</h1><p>imgmin包含了下面的模块，分别用于gif jpg png svg格式压缩</p>
<ul>
<li>gifsicle</li>
<li>mozjpeg</li>
<li>optipng</li>
<li>svgo</li>
</ul>
<p>这几个工具都用到了C模块</p>
<h1 id="webpack-img-loader-不推荐"><a href="#webpack-img-loader-不推荐" class="headerlink" title="webpack img-loader(不推荐)"></a>webpack img-loader(不推荐)</h1><p>不推荐的原因是压缩图片一般是一次性的动作，而且耗时较长，另外原图提交到仓库，别的同学下载也麻烦</p>
]]></content>
  </entry>
  <entry>
    <title>基于strapi gridsome技术架构的内容管理系统(CMS)</title>
    <url>/2021/09/09/%E5%9F%BA%E4%BA%8Estrapi-gridsome%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84%E7%9A%84%E5%86%85%E5%AE%B9%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F-CMS/</url>
    <content><![CDATA[<p><a href="https://strapi.io/">strapi</a>是目前github上最流行的基于nodejs 的Handless CMS项目。</p>
<p><a href="https://gridsome.org/">gridsome</a>是基于vue的静态站点构造器，具有SEO友好，站点响应快，安装npm依赖后可以直接启动运行。</p>
<p>CMS我们一般用于网站的后台管理，基于这个技术架构，我们可以快速搭建博客系统，企业官网，项目文档网站等。</p>
<p>改技术架构只需要一个纯前端的开发者就可以运行维护，由于数据库是sqlite3省了数据存储费用，自带了媒体资源上传与存储服务，也节省了静态资源存储服务的费用。非常适合小型网站的构建。</p>
<h2 id="该技术架构成本"><a href="#该技术架构成本" class="headerlink" title="该技术架构成本"></a>该技术架构成本</h2><ol>
<li><p>阿里云ECS大概800一年</p>
</li>
<li><p>定制化界面开发 7-15人天</p>
</li>
<li><p>com域名约75元/年</p>
</li>
</ol>
<p>最基础的站点，大概首次投入7000元。后续1000/年。就可以长期运行下去了。</p>
<p>有需要做网站的可以留言联系我(微信号:sq88sq)</p>
]]></content>
  </entry>
  <entry>
    <title>如何查看emoji表情的Unicode编码</title>
    <url>/2021/10/22/%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8Bemoji%E8%A1%A8%E6%83%85%E7%9A%84Unicode%E7%BC%96%E7%A0%81/</url>
    <content><![CDATA[<h2 id="可以在下面这个网站复制粘贴emoji"><a href="#可以在下面这个网站复制粘贴emoji" class="headerlink" title="可以在下面这个网站复制粘贴emoji"></a>可以在下面这个网站复制粘贴emoji</h2><p><a href="https://getemoji.com/">https://getemoji.com/</a></p>
<h2 id="👶🏻-这个除了复制粘贴怎么打印呢"><a href="#👶🏻-这个除了复制粘贴怎么打印呢" class="headerlink" title="👶🏻 这个除了复制粘贴怎么打印呢?"></a>👶🏻 这个除了复制粘贴怎么打印呢?</h2><p>我们js中的字符串编码是<code>utf-8</code><br><img src="images/2021-10-22-19-19-17.png"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">escape</span>(<span class="string">&#x27;👶🏻&#x27;</span>)</span><br><span class="line"><span class="comment">// &#x27;%uD83D%uDC76%uD83C%uDFFB&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;\uD83D\uDC76\uD83c\uDFFB&#x27;</span>)</span><br><span class="line"><span class="comment">//  👶🏻</span></span><br></pre></td></tr></table></figure>

<h2 id="emoji-regex"><a href="#emoji-regex" class="headerlink" title="emoji-regex"></a>emoji-regex</h2><p><a href="https://www.npmjs.com/package/emoji-regex">https://www.npmjs.com/package/emoji-regex</a></p>
<p>这个仓库用来匹配字符串中的emoji表情,可以用来做富文本的图片替换</p>
]]></content>
      <tags>
        <tag>emoji</tag>
      </tags>
  </entry>
  <entry>
    <title>开发灵异事件之登录失效</title>
    <url>/2021/09/13/%E5%BC%80%E5%8F%91%E7%81%B5%E5%BC%82%E4%BA%8B%E4%BB%B6%E4%B9%8B%E7%99%BB%E5%BD%95%E5%A4%B1%E6%95%88/</url>
    <content><![CDATA[<h1 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h1><p>登录界面多次重定向到自己。退出浏览器，清理缓存，无痕模式，都不行。</p>
<h1 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h1><p>google chrome在90+版本后，关闭所有窗口仍然会在后台运行，右下角有个小图标。这样会导致存在session Storage里面的数据不会被清理，或者是一些缓存命中机制出现变化，原有的登录判断逻辑出现问题。</p>
<h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>右击电脑屏幕右下角状态栏chrome小图标，测底关闭浏览器后台程序。</p>
<p>一劳永逸法，chrome://settings 界面去勾选退出后在后台运行的设置<br><img src="%5Bhttps://%5D(https://upload-images.jianshu.io/upload_images/8156292-157357cdc6edd678.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)" alt="alt"><br>根本解决法，修改判断登录的机制，适配浏览器更新</p>
]]></content>
  </entry>
  <entry>
    <title>无js的菜单栏收缩与折叠动画</title>
    <url>/2022/08/15/%E6%97%A0js%E7%9A%84tab%E6%A0%8F%E6%94%B6%E7%BC%A9%E4%B8%8E%E6%8A%98%E5%8F%A0%E5%8A%A8%E7%94%BB/</url>
    <content><![CDATA[<p>菜单栏收缩主要使用下面的样式实现</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">nav</span><span class="selector-pseudo">:hover</span>,<span class="selector-tag">nav</span><span class="selector-pseudo">:focus</span>-within&#123;</span><br><span class="line">   <span class="attribute">transform</span>:<span class="built_in">translateX</span>(<span class="number">100%</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>折叠面板动画</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">details</span><span class="selector-attr">[open]</span> <span class="selector-tag">summary</span> ~ *&#123;</span><br><span class="line">  <span class="attribute">animation</span>:sweep .<span class="number">5s</span> ease-in-out</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@keyframs</span> sweep&#123;</span><br><span class="line">  <span class="number">0%</span> &#123;opcity:<span class="number">0</span>;<span class="attribute">margin-left</span>:-<span class="number">10px</span>&#125;</span><br><span class="line">  <span class="number">100%</span> &#123;opcity:<span class="number">100</span>;<span class="attribute">margin-left</span>:<span class="number">0px</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>html</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>极致简洁的微前端框架-京东MicroApp开源了</title>
    <url>/2021/09/25/%E6%9E%81%E8%87%B4%E7%AE%80%E6%B4%81%E7%9A%84%E5%BE%AE%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6-%E4%BA%AC%E4%B8%9CMicroApp%E5%BC%80%E6%BA%90%E4%BA%86/</url>
    <content><![CDATA[<p>原文地址 <a href="https://article.itxueyuan.com/ylqMxp">https://article.itxueyuan.com/ylqMxp</a></p>
<ul>
<li>基于自定义元素，影子节点。web-components实现。</li>
<li>自定义元素属性不支持对象，这里重写set方法,用数据中心传递数据<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> dataCenter=&#123;</span><br><span class="line">  people:&#123;</span><br><span class="line">    name:<span class="string">&#x27;Bob&#x27;</span>,</span><br><span class="line">    age:<span class="number">18</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">setAttribute</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> setOld=setAttribute;</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&quot;myPeople&quot;</span>).setAttribute=<span class="function"><span class="keyword">function</span> (<span class="params">attrName,attrValue</span>) </span>&#123;</span><br><span class="line">    setOld(attrName,attrValue);</span><br><span class="line">    <span class="built_in">this</span>.attrName=dataCenter[attrValue]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)(<span class="built_in">document</span>.getElementById(<span class="string">&quot;myPeople&quot;</span>).setAttribute)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>使用微前端会导致各个子项目技术栈完全不一致,各玩各的真的好吗?难道统一技术栈不是更好的选择,这样玩用人成本不是更高了么?</li>
<li>微前端本身也是有学习成本的,这种各玩各的问题定位起来更难了,想组织技术培训的话,卧槽!!!各个子项目用的技术都不一样,无形提高了沟通成本</li>
</ul>
]]></content>
      <tags>
        <tag>读后感</tag>
      </tags>
  </entry>
  <entry>
    <title>树形数据的广度优先与深度优先</title>
    <url>/2021/09/25/%E6%A0%91%E5%BD%A2%E6%95%B0%E6%8D%AE%E7%9A%84%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E4%B8%8E%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88/</url>
    <content><![CDATA[<p>这里只是做一个笔记,解释的话可以自行百度</p>
<h2 id="广度优先"><a href="#广度优先" class="headerlink" title="广度优先"></a>广度优先</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foreach</span>(<span class="params">data,callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> nodes=[];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> data) &#123;</span><br><span class="line">    <span class="keyword">if</span>(item.childrens)&#123;</span><br><span class="line">      node=node.concat(item.childrens)</span><br><span class="line">    &#125;</span><br><span class="line">    callback(item)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(nodes.length==<span class="number">0</span>)<span class="keyword">return</span> </span><br><span class="line">  foreach(nodes)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="深度优先"><a href="#深度优先" class="headerlink" title="深度优先"></a>深度优先</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foreach</span>(<span class="params">data,callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> data) &#123;</span><br><span class="line">    <span class="keyword">if</span>(item.childrens)&#123;</span><br><span class="line">      foreach(item.childrens)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      callback(item)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>代码片段</tag>
      </tags>
  </entry>
  <entry>
    <title>水印样式处理</title>
    <url>/2022/08/15/%E6%B0%B4%E5%8D%B0%E6%A0%B7%E5%BC%8F%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<p>水印一般要求zIndex层级特别高，但是又不能影响到点击事件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;height:0;width:100%;pointer-events:none&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;height:50px;width:50px:position:absolute;top:50px;z-index:100000000;transform:rotate(45deg)&quot;</span>&gt;</span></span><br><span class="line">    LOGO</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>外层声明一个高度0的容器，并给上<code>pointer-events:none</code>取消鼠标事件</li>
<li>内层水印给上很高的z-Index也不会影响到用户操作咯</li>
</ul>
]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>css冷门知识-获取windows系统主题</title>
    <url>/2021/12/09/%E8%8E%B7%E5%8F%96%E7%B3%BB%E7%BB%9F%E4%B8%BB%E9%A2%98/</url>
    <content><![CDATA[<h1 id="使用-matchMedia-API找到-MediaQueryList-对象"><a href="#使用-matchMedia-API找到-MediaQueryList-对象" class="headerlink" title="使用 matchMedia API找到 MediaQueryList 对象"></a>使用 <code>matchMedia</code> API找到 <code>MediaQueryList</code> 对象</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span>  mqList = <span class="built_in">window</span>.matchMedia(<span class="string">&quot;(prefers-color-scheme:dark)&quot;</span>)</span><br><span class="line"><span class="keyword">if</span>(mqList.matches)&#123;<span class="comment">//匹配上了,说明windows使用的是黑暗主题模式</span></span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> 将我们网页的主题设置成暗黑模式</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>媒体查询的类型 <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/@media">https://developer.mozilla.org/en-US/docs/Web/CSS/@media</a> </li>
<li> <code>matchMedia</code>API介绍 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/matchMedia">https://developer.mozilla.org/en-US/docs/Web/API/Window/matchMedia</a> </li>
</ol>
]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>记录webpack4的两个坑</title>
    <url>/2021/09/26/%E8%AE%B0%E5%BD%95webpack4%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%9D%91/</url>
    <content><![CDATA[<ol>
<li><p>mode=production 的时候会自动压缩混淆js。但是如果加上css压缩的配置后,js的会失效,需要显式声明压缩插件<code> new TenserJSPlugin()</code></p>
</li>
<li><p>(file-loader extract-loader html-loader) 与 html-webpack-plugin 有冲突。这时候生成的index.html模板信息会丢失掉，只有一个片段。解决方案是在 (file-loader extract-loader html-loader) 处理html导入的时候,exclude掉index.html(不一定是这个名字,主要看模板名称)</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>这两篇应该是最好的js 微任务 宏任务讲解了</title>
    <url>/2021/10/09/%E8%BF%99%E4%B8%A4%E7%AF%87%E5%BA%94%E8%AF%A5%E6%98%AF%E6%9C%80%E5%A5%BD%E7%9A%84js-%E5%BE%AE%E4%BB%BB%E5%8A%A1-%E5%AE%8F%E4%BB%BB%E5%8A%A1%E8%AE%B2%E8%A7%A3%E4%BA%86/</url>
    <content><![CDATA[<p><a href="https://www.cnblogs.com/jiasm/p/9482443.html">https://www.cnblogs.com/jiasm/p/9482443.html</a></p>
<p><a href="https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/">https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>微任务,宏任务都是一个队列</li>
<li>宏任务产生的宏任务,追加在宏任务队列尾部</li>
<li>微任务产生的微任务,追加在微任务队列尾部</li>
<li>微任务队列空了才会执行下一个宏任务,自己新产生的也会执行完</li>
<li>不同浏览器也是有差异的,chrome跟W3C是一致的</li>
</ul>
]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>通过符号链接的方式移动vscode插件</title>
    <url>/2021/09/26/%E9%80%9A%E8%BF%87%E7%AC%A6%E5%8F%B7%E9%93%BE%E6%8E%A5%E7%9A%84%E6%96%B9%E5%BC%8F%E7%A7%BB%E5%8A%A8vscode%E6%8F%92%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="创建目录符号链接-修改插件位置-防止C盘爆掉"><a href="#创建目录符号链接-修改插件位置-防止C盘爆掉" class="headerlink" title="创建目录符号链接,修改插件位置,防止C盘爆掉"></a>创建目录符号链接,修改插件位置,防止C盘爆掉</h2><ol>
<li>剪切文件夹到新的目录,不然命令行会执行失败</li>
<li>命令行使用管理员权限</li>
<li><code>mklink /D &quot;C:\Users\&#123;username&#125;\.vscode&quot; &quot;D:\&#123;username&#125;\.vscode&quot;</code></li>
</ol>
<blockquote>
<p>{username} 为用户名</p>
</blockquote>
<h2 id="vscode插件中文文档"><a href="#vscode插件中文文档" class="headerlink" title="vscode插件中文文档"></a>vscode插件中文文档</h2><p><a href="http://liik.gitee.io/vs-code-extension-doc-zh/#/">http://liik.gitee.io/vs-code-extension-doc-zh/#/</a></p>
]]></content>
      <tags>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title>防止xss注入</title>
    <url>/2021/10/22/%E9%98%B2%E6%AD%A2xss%E6%B3%A8%E5%85%A5/</url>
    <content><![CDATA[<h2 id="谁是-OWASP-®基金会"><a href="#谁是-OWASP-®基金会" class="headerlink" title="谁是 OWASP ®基金会"></a>谁是 OWASP ®基金会</h2><p>Open Web Application Security Project</p>
<h2 id="web安全理论基础"><a href="#web安全理论基础" class="headerlink" title="web安全理论基础"></a>web安全理论基础</h2><p><a href="https://cheatsheetseries.owasp.org/">https://cheatsheetseries.owasp.org/</a></p>
<h2 id="xss注入"><a href="#xss注入" class="headerlink" title="xss注入"></a>xss注入</h2><p>主要是需要转义html <code>&lt; &gt; &quot; &#39; &amp;</code> 这5个字符</p>
<ul>
<li><code>&gt;</code> 转 <code>&amp;gt;</code> </li>
<li><code>&lt;</code> 转 <code>&amp;lt;</code> </li>
<li><code>&quot;</code> 转 <code>&amp;quot;</code> </li>
<li><code>&#39;</code> 转 <code>&amp;#39;</code> </li>
<li><code>&amp;</code> 转 <code>&amp;amp;</code> </li>
</ul>
<h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><p>直接使用雅虎的xss-filters<br><a href="https://www.npmjs.com/package/xss-filters">https://www.npmjs.com/package/xss-filters</a></p>
]]></content>
      <tags>
        <tag>web安全</tag>
      </tags>
  </entry>
  <entry>
    <title>需求管理</title>
    <url>/2022/08/15/%E9%9C%80%E6%B1%82%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<ul>
<li>OR 原始需求，可能会涉及到多个系统 SE输出</li>
<li>SR 系统需求，单系统，开发PL输出，原始需求分解到单系统的大颗粒需求</li>
<li>DR 开发需求，单系统的具体模块，需要拆解成可编码的模块</li>
</ul>
]]></content>
      <tags>
        <tag>项目管理</tag>
      </tags>
  </entry>
  <entry>
    <title>非vue-cli构建的项目使用 webpack-dev-server不打印代理日志</title>
    <url>/2021/09/26/%E9%9D%9Evue-cli%E6%9E%84%E5%BB%BA%E7%9A%84%E9%A1%B9%E7%9B%AE%E4%BD%BF%E7%94%A8-webpack-dev-server%E4%B8%8D%E6%89%93%E5%8D%B0%E4%BB%A3%E7%90%86%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<p>使用 webpack-dev-server打印代理日志需要使用以下配置</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports=&#123;</span><br><span class="line">  devServer:&#123;</span><br><span class="line">    proxy:&#123;</span><br><span class="line">      <span class="string">&quot;/&quot;</span>&#123;</span><br><span class="line">        target:<span class="string">&#x27;&#x27;</span>,</span><br><span class="line">        logLevel:<span class="string">&#x27;debug&#x27;</span><span class="comment">//加上这个就可以了</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>音乐分轨处理</title>
    <url>/2021/11/09/%E9%9F%B3%E4%B9%90%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<p>妹妹经常外出做音乐表演，需要伴奏，但是从酷狗下载的音乐很多都没有纯伴奏版本，全民K歌这种软件也没有这种伴奏下载的功能。</p>
<p>作为一个程序员哥哥，妹妹的请求总不能说不会搞吧！！也不想花钱买，于是找了下资源。</p>
<p>网上找了这两个可以用来分离原声与伴奏。</p>
<p>开源音频分轨 Python <a href="https://github.com/deezer/spleeter">https://github.com/deezer/spleeter</a></p>
<p>在线分轨网站（推荐） <a href="https://ezstems.com/">https://ezstems.com/</a> 这个应该是用上面的技术搞得，本来还有个网站的，收藏夹没找到，下次找到了再分享出来！！</p>
]]></content>
      <tags>
        <tag>音乐</tag>
      </tags>
  </entry>
  <entry>
    <title>2021-3-24 Chrome Devtools Tip： 2.如何使用DevTools触发CSS伪类</title>
    <url>/2021/03/24/Chrome%20Devtools%20Tip/2021-3-24-%20Chrome%20Devtools%20Tip%EF%BC%9A%202.%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8DevTools%E8%A7%A6%E5%8F%91CSS%E4%BC%AA%E7%B1%BB/</url>
    <content><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/8156292-fe137965f93360e7.gif?imageMogr2/auto-orient/strip" alt="pseudo-trigger.gif"><br>可以触发元素上的<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Pseudo-classes">伪类</a>，以研究元素（例如，将元素悬停在元素上）如何反应。您可以右键单击“元素”面板中的节点，然后选择“强制元素状态”。或者，可以在“<a href="https://developers.google.com/web/tools/chrome-devtools/inspect-styles">样式”</a>子窗格中单击“切换”元素状态图标。</p>
<p>当一个元素应用了某种状态时，您将在节点的开始标签左侧看到一个视觉指示器，在某些情况下，也将在关闭标签左侧（如果它们相距很远）。</p>
<p>我们可以触发：活动类（:active），焦点类(:focus)，悬停类(:hover)和访问过的（:visited）伪类。</p>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p>一般伪类是<code>:PseudoClass</code>,伪元素是<code>::PseudoElement</code>,虽然伪元素也能写一个冒号，但是最好区分开来</p>
]]></content>
      <tags>
        <tag>Chrome Devtools Tip</tag>
      </tags>
  </entry>
  <entry>
    <title>2021-3-24 Chrome Devtools Tip： 3.使用cURL复制功能重播Network面板的请求</title>
    <url>/2021/03/24/Chrome%20Devtools%20Tip/2021-3-24-%20Chrome%20Devtools%20Tip%EF%BC%9A%203.%E4%BD%BF%E7%94%A8cURL%E5%A4%8D%E5%88%B6%E5%8A%9F%E8%83%BD%E9%87%8D%E6%92%ADNetwork%E9%9D%A2%E6%9D%BF%E7%9A%84%E8%AF%B7%E6%B1%82/</url>
    <content><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/8156292-2361d35d4917df7e.gif?imageMogr2/auto-orient/strip" alt="copy-as-curl.gif"><br>网络面板中显示的资源有一个上下文菜单，该菜单允许您复制为cURL，这将进入剪贴板，此时您可以将其粘贴到命令行中，必要时进行修改，然后查看响应。请求标头也包括在内。</p>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><ol>
<li><code>Numbers API</code>给个数字，会返回这个数字相关的信息。其实有很多免费的API很有趣，可以自行收集下，比如天气的，历史上的今天，新冠疫情数据，这样我们没有自己的服务器也能做出有意思的应用。</li>
<li>Windows 系统没有<code>curl</code>命令行工具（除非自己安装），可以使用<code>Copy as PowerShell</code>进行请求重播，复制成fetch代码也不错，做接口测试的时候就省代码了<br><img src="https://upload-images.jianshu.io/upload_images/8156292-bb4bd22c59eaa1f2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li>
</ol>
<h1 id="将网络回复复制到剪贴板"><a href="#将网络回复复制到剪贴板" class="headerlink" title="将网络回复复制到剪贴板"></a>将网络回复复制到剪贴板</h1><p><img src="https://upload-images.jianshu.io/upload_images/8156292-6eb17dca94cc97df.gif?imageMogr2/auto-orient/strip" alt="copy-response.gif"></p>
]]></content>
      <tags>
        <tag>Chrome Devtools Tip</tag>
      </tags>
  </entry>
  <entry>
    <title>2021-3-24 Chrome Devtools Tip： 1. Port Forwarding 允许localhost URL 在移动设备调试</title>
    <url>/2021/03/24/Chrome%20Devtools%20Tip/2021-3-24-%20Chrome%20Devtools%20Tip%EF%BC%9A%201.%20Port%20Forwarding%20%E5%85%81%E8%AE%B8localhost%20URL%20%E5%9C%A8%E7%A7%BB%E5%8A%A8%E8%AE%BE%E5%A4%87%E8%B0%83%E8%AF%95/</url>
    <content><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/8156292-21eac099700614e6.gif?imageMogr2/auto-orient/strip" alt="port-forward.gif"></p>
<h1 id="在本技巧中，您将学习如何在Android设备上转发端口。"><a href="#在本技巧中，您将学习如何在Android设备上转发端口。" class="headerlink" title="在本技巧中，您将学习如何在Android设备上转发端口。"></a>在本技巧中，您将学习如何在Android设备上转发端口。</h1><p>端口转发使您可以直接在android设备上查看本地网站，即使该网站托管在自定义域中。</p>
<ul>
<li>Chrome浏览器从台式机拨打我的本地主机URL</li>
<li>远程调试移动本地主机页面并启用端口转发</li>
<li>刷新并观察到不需要命令行！</li>
</ul>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><ol>
<li><p>Chrome远程调试界面的的url<code>chrome://inspect/#devices</code></p>
</li>
<li><p>记得在手机<code>开发者工具</code>上打开<code>启用USB调试</code></p>
</li>
<li><p>配置入口如下图<br><img src="https://upload-images.jianshu.io/upload_images/8156292-033914fe5e4a3845.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="port-forward配置入口"></p>
</li>
<li><p>配置完勾选端口转发复选框<br><img src="https://upload-images.jianshu.io/upload_images/8156292-15a49c6284f73ada.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
</li>
</ol>
]]></content>
      <categories>
        <category>Chrome Devtools Tip</category>
      </categories>
      <tags>
        <tag>Chrome Devtools Tip</tag>
      </tags>
  </entry>
  <entry>
    <title>2021-3-24 Chrome Devtools Tip： 5.通过本地修改查看您的更改</title>
    <url>/2021/03/24/Chrome%20Devtools%20Tip/2021-3-24-%20Chrome%20Devtools%20Tip%EF%BC%9A%205.%E9%80%9A%E8%BF%87%E6%9C%AC%E5%9C%B0%E4%BF%AE%E6%94%B9%E6%9F%A5%E7%9C%8B%E6%82%A8%E7%9A%84%E6%9B%B4%E6%94%B9/</url>
    <content><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/8156292-d122d3505663c200.gif?imageMogr2/auto-orient/strip" alt="local-mods.gif"></p>
<p>本地修改使您可以查看（通过DevTools）对某些源文件进行了哪些更改。</p>
<p>进行更改并保存后，右键单击“源代码”面板中的文件，然后选择“本地修改”。每个修改都将列为新的更改，并且每个修改都可以单独还原。</p>
<p>本地修改有助于跟踪，进行了哪些更改，何时进行了这些更改以及对哪些文件进行了更改。</p>
<p>您可能还对较新的<a href="https://umaar.com/dev-tips/137-changes-panel/">DevTools更改面板</a>感兴趣。</p>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><ol>
<li>一般IDE（IDEA，VSCODE）自带的diff比较工具都挺好用的，但是如果去比较两个文件夹，还是建议使用<strong>Beyond Compare 4</strong></li>
<li>git 自身的diff工具如果用的不舒服,可以改成vscode呢！这个文章是写怎么设置的，其他工具设置方法类似<a href="https://blog.csdn.net/LeonBec/article/details/78989149">https://blog.csdn.net/LeonBec/article/details/78989149</a></li>
<li>可视化的git工具，小乌龟我用的还是很习惯的，建议下载一个。<a href="https://tortoisegit.org/">https://tortoisegit.org/</a></li>
<li>真的很讨厌用命令行装B，骗骗外行还行，这里怼一下那些天天 <code>git add .</code> 提交所有文件，也不<code>diff</code>一下的菜鸡<h1 id="思考与尝试"><a href="#思考与尝试" class="headerlink" title="思考与尝试"></a>思考与尝试</h1>devtools自带的diff工具，不知道git 命令行能不能设置成这个工具，知道的小伙伴评论区见哈！</li>
</ol>
]]></content>
      <tags>
        <tag>Chrome Devtools Tip</tag>
      </tags>
  </entry>
  <entry>
    <title>2021-3-24 Chrome Devtools Tip： 4.在任何网页上运行预定义的代码段</title>
    <url>/2021/03/24/Chrome%20Devtools%20Tip/2021-3-24-%20Chrome%20Devtools%20Tip%EF%BC%9A%204.%E5%9C%A8%E4%BB%BB%E4%BD%95%E7%BD%91%E9%A1%B5%E4%B8%8A%E8%BF%90%E8%A1%8C%E9%A2%84%E5%AE%9A%E4%B9%89%E7%9A%84%E4%BB%A3%E7%A0%81%E6%AE%B5/</url>
    <content><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/8156292-3ab1f856b9a0a89b.gif?imageMogr2/auto-orient/strip" alt="snippets.gif"><br>DevTools中提供了一个名为Snippets的功能，使您可以注入可在网页上运行的JavaScript代码（与在控制台面板中重新键入JavaScript代码相比，这更方便）。尝试一下：</p>
<ul>
<li>  转到“来源”&gt;“代码段”（位于左侧边栏中）</li>
<li>  在摘要窗口中单击鼠标右键，然后选择“新建”。</li>
<li>  输入文件名和所需的代码段</li>
<li>  右键点击代码段，然后选择运行（或Ctrl / Cmd + Enter）</li>
</ul>
<p>您还会注意到，它具有多行编辑功能，并且可以确认退出而不保存。</p>
<p>这是大量的DevTools片段集合：<a href="https://github.com/bgrins/devtools-snippets">https</a> : <a href="https://github.com/bgrins/devtools-snippets">//github.com/bgrins/devtools-snippets</a></p>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p>代码段可以直接在 <code>Console</code>面板执行的，但是在里面不好调整格式，也没有自动完成，也不能保存。所以这种方式挺好的。</p>
<p>总能遇到一些本地环境不能调试的代码，直接使用代码段功能在测试环境执行我们的代码，省去了打包上环境的时间，也确保了代码的正确性。</p>
<h1 id="思考与尝试"><a href="#思考与尝试" class="headerlink" title="思考与尝试"></a>思考与尝试</h1><p>尝试下打断点，触发断点后，再执行代码段，不知道此时的变量作用域怎么样的呢？有兴趣的同学可以自己试试，评论区见答案。</p>
]]></content>
      <tags>
        <tag>Chrome Devtools Tip</tag>
      </tags>
  </entry>
  <entry>
    <title>2021-3-24 Chrome Devtools Tip： 6.轻松的使用性能面板录制时间线</title>
    <url>/2021/03/24/Chrome%20Devtools%20Tip/2021-3-24-%20Chrome%20Devtools%20Tip%EF%BC%9A%206.%E8%BD%BB%E6%9D%BE%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%A7%E8%83%BD%E9%9D%A2%E6%9D%BF%E5%BD%95%E5%88%B6%E6%97%B6%E9%97%B4%E7%BA%BF/</url>
    <content><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/8156292-6bc177b57bdb952e.gif?imageMogr2/auto-orient/strip" alt="record-timeline-undocked.gif"><br>当您需要在Mac上执行时间线录制时，请尝试将DevTools停靠到一个单独的窗口中，以便将录制按钮放在需要执行操作的页面部分附近。</p>
<p>或者，使用快捷键Cmd + E启动和停止录制。</p>
<p>通过这种方式进行录制，可以使录制的内容简短而甜美，并且可以减少录制时的“杂音”，因为您无需长时间在页面上移动鼠标。</p>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><ol>
<li>录制时间线的重点就是，缩短录制时间，仅仅录制要分析的操作，这样大大减少了分析成本。这个小技巧就是干这个的。</li>
<li>有时候输入法的快捷键会跟我们的IDE快捷键冲突，比如 <code>ctrl shift f</code>在vscode中是聚焦到搜索面板，搜狗输入法是繁简体切换，Hotkey Commander<a href="https://gitee.com/alasq/tools/raw/master/Hotkey%20Commander/hkcmdr_inst.exe"> [ 下载 ]</a>这个工具可以检测快捷键的冲突<br><img src="https://upload-images.jianshu.io/upload_images/8156292-b3ec75b5e13a6402.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1>假如我们写一个vscode 插件，怎么尽可能的不与现有的快捷键冲突</li>
</ol>
]]></content>
      <tags>
        <tag>Chrome Devtools Tip</tag>
      </tags>
  </entry>
  <entry>
    <title>2021-3-24 Chrome Devtools Tip： 目录总览</title>
    <url>/2021/03/24/Chrome%20Devtools%20Tip/2021-3-24-%20Chrome%20Devtools%20Tip%EF%BC%9A%20%E7%9B%AE%E5%BD%95%E6%80%BB%E8%A7%88/</url>
    <content><![CDATA[<h1 id="目标读者"><a href="#目标读者" class="headerlink" title="目标读者"></a>目标读者</h1><p>WEB 应用 <strong>设计&amp; 开发 &amp; 测试 &amp; 重度用户</strong></p>
<h1 id="关于调试"><a href="#关于调试" class="headerlink" title="关于调试"></a>关于调试</h1><p>WEB应用开发者中，设计=》开发=》测试=》BUG修复=》回归测试=》发布=》部署。Chrome Devtool 都是必须要掌握的知识。在项目中，发现很多同事写代码还行，遇到问题就解决的很慢，或者无从下手。玩转调试可以：</p>
<ol>
<li>增加开发效率</li>
<li>快速定位问题</li>
<li>降低沟通成本</li>
</ol>
<h1 id="阅读前"><a href="#阅读前" class="headerlink" title="阅读前"></a>阅读前</h1><p>请先阅读 Google Chrome DevTools 官方文档(<a href="https://developers.google.cn/web/tools/chrome-devtools/">https://developers.google.cn/web/tools/chrome-devtools/</a>) </p>
<h1 id="来源与改进"><a href="#来源与改进" class="headerlink" title="来源与改进"></a>来源与改进</h1><p>文章主要来源于（<a href="https://umaar.com/dev-tips/%EF%BC%89">https://umaar.com/dev-tips/）</a> ，并做以下改进</p>
<ol>
<li>汉化</li>
<li>部分过时的gif重录</li>
<li>加上自己的理解</li>
</ol>
<h1 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h1><p>三月底完成！</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ol>
<li>Port Forwarding 允许localhost URL 在移动设备调试</li>
<li>如何使用DevTools触发CSS伪类</li>
<li>使用cURL复制功能重播Network面板的请求</li>
<li>在任何网页上运行预定义的代码段</li>
<li>通过本地修改查看您的更改</li>
<li>轻松的使用性能面板录制时间线</li>
<li>将图片复制为base64编码data URI</li>
<li>资源面板Source中的快捷键</li>
<li>多光标编辑 框选</li>
<li>Console面板的一些API</li>
<li>Network 网络面板过滤器</li>
<li>Element面板</li>
<li>通过快捷键快速切换 devtools 附着状态</li>
<li>断点调试相关的技巧</li>
<li>颜色拾取器增强</li>
<li>动画调试</li>
<li>调试jquery 事件监听</li>
<li>隐藏网络请求报错的console.error</li>
<li>使用console.table 更好的展示对象 数组信息</li>
<li>Element面板快速切换class查看效果</li>
<li>降低CPU的性能与网络速度来观测性能</li>
<li>使用 Sources 面板 Threads 调试</li>
<li>使用sourceMap 调试ESNext语法</li>
<li>在“Network”中查看来自其他应用程序的网络流量</li>
<li>通过Performance面板录制,行级别查看代码耗时</li>
<li>Store as global variable 存储成全局变量</li>
<li>利用Quick Source 快速写样式</li>
<li>Chrome带参数启动</li>
<li>自定义Network面板的显示列，展示我们关心的响应头</li>
<li>devtools支持热更新调试Nodejs</li>
<li>Blackboxing 获得更好的调试会话</li>
<li>lighthouse 面板检查网页状态</li>
<li><code>css tracker</code>面板查看未使用的css</li>
<li>通过服务器增加 Server-Timing 响应头展示时间信息</li>
<li>Network 查看实际访问的IP</li>
<li>自定义时间测量API</li>
<li>查看帧率FPS</li>
<li>复制完整的调用栈</li>
<li>网页全页截图</li>
</ol>
]]></content>
      <tags>
        <tag>Chrome Devtools Tip</tag>
      </tags>
  </entry>
  <entry>
    <title>2021-4-7- Chrome Devtools Tip： 10.Console面板的一些API</title>
    <url>/2021/04/07/Chrome%20Devtools%20Tip/2021-4-7-%20Chrome%20Devtools%20Tip%EF%BC%9A%2010.%20Console%E9%9D%A2%E6%9D%BF%E7%9A%84%E4%B8%80%E4%BA%9BAPI/</url>
    <content><![CDATA[<h1 id="快速监控JavaScript中的事件"><a href="#快速监控JavaScript中的事件" class="headerlink" title="快速监控JavaScript中的事件"></a>快速监控JavaScript中的事件</h1><p><img src="https://upload-images.jianshu.io/upload_images/8156292-b7226d2fe4dede77.gif?imageMogr2/auto-orient/strip" alt="monitor-events.gif"><br>您可以使用命令行API方法<code>monitorEvents（object [，events]）</code>记录分发给对象的所有事件。然后将事件对象记录到控制台。当您需要提醒事件对象的可用属性时很有用。</p>
<h2 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h2><p>例如，直接在控制台面板中尝试以下代码：</p>
<blockquote>
<p>monitorEvents(window, ‘click’)  </p>
</blockquote>
<p>当您在网页中单击时，现在应该看到click事件自动记录到控制台。</p>
<h1 id="控制台获取当前选定的DOM节点的快捷方式"><a href="#控制台获取当前选定的DOM节点的快捷方式" class="headerlink" title="控制台获取当前选定的DOM节点的快捷方式"></a>控制台获取当前选定的DOM节点的快捷方式</h1><p><img src="https://upload-images.jianshu.io/upload_images/8156292-f6444ade5bf7074e.gif?imageMogr2/auto-orient/strip" alt="dollar-zero.gif"></p>
<p>在“Element”面板中选择节点后，请在控制台面板中使用表达式<code>$0</code>进行访问。您还可以使用<code>$_</code>访问最近求值的表达式的值</p>
<h1 id="控制台快速定位DOM位置"><a href="#控制台快速定位DOM位置" class="headerlink" title="控制台快速定位DOM位置"></a>控制台快速定位DOM位置</h1><p><img src="https://upload-images.jianshu.io/upload_images/8156292-2d4c59000b3e4d31.gif?imageMogr2/auto-orient/strip" alt="reveal-in-elements.gif"></p>
]]></content>
      <tags>
        <tag>Chrome Devtools Tip</tag>
      </tags>
  </entry>
  <entry>
    <title>2021-4-7- Chrome Devtools Tip： 11.Network 网络面板过滤器</title>
    <url>/2021/04/07/Chrome%20Devtools%20Tip/2021-4-7-%20Chrome%20Devtools%20Tip%EF%BC%9A%2011.%20Network%20%E7%BD%91%E7%BB%9C%E9%9D%A2%E6%9D%BF%E8%BF%87%E6%BB%A4%E5%99%A8/</url>
    <content><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/8156292-7fbd6b075cec6c2d.gif?imageMogr2/auto-orient/strip" alt="is-running.gif"></p>
<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>您可以使用“is:running高级网络过滤器”查看未完成的网络请求（例如正在运行的请求）。其他一些过滤器，您可以尝试是：status-code，method，domain和更多！</p>
<h1 id="如何使用它"><a href="#如何使用它" class="headerlink" title="如何使用它"></a>如何使用它</h1><p>在“网络面板”过滤器框中，键入is:running并重新加载页面。观察可见的“网络面板”行如何快速变化以仅显示当前正在运行的资源。</p>
<h1 id="别的过滤器"><a href="#别的过滤器" class="headerlink" title="别的过滤器"></a>别的过滤器</h1><p><img src="https://upload-images.jianshu.io/upload_images/8156292-421dbaa61601a622.gif?imageMogr2/auto-orient/strip" alt="network-advanced-filter.gif"></p>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p>还有这些过滤器可以使用</p>
<ul>
<li>  domain</li>
<li>  has-response-header</li>
<li>  is - []（例如上图的例子）</li>
<li>  larger-than</li>
<li>  method</li>
<li>  mime-type</li>
<li>  mixed-content</li>
<li>  priority</li>
<li>  scheme</li>
<li>  set-cookie-domain</li>
<li>  set-cookie-name</li>
<li>  set-cookie-value</li>
<li>  resource-type</li>
<li>  cookie-domain</li>
<li>  cookie-name</li>
<li>  cookie-path</li>
<li>  cookie-value</li>
<li>  status-code</li>
<li>  url<h1 id="查看网络资源依赖关系"><a href="#查看网络资源依赖关系" class="headerlink" title="查看网络资源依赖关系"></a>查看网络资源依赖关系</h1><img src="https://upload-images.jianshu.io/upload_images/8156292-de7a51900ab3d6b1.gif?imageMogr2/auto-orient/strip" alt="network-dependency.gif"><br>点击到具体的请求，查看 initiator 面板也是可以看到的 请求的调用栈与树状依赖结构</li>
</ul>
]]></content>
      <tags>
        <tag>Chrome Devtools Tip</tag>
      </tags>
  </entry>
  <entry>
    <title>2021-4-7- Chrome Devtools Tip： 12. Element面板</title>
    <url>/2021/04/07/Chrome%20Devtools%20Tip/2021-4-7-%20Chrome%20Devtools%20Tip%EF%BC%9A%2012.%20Element%E9%9D%A2%E6%9D%BF/</url>
    <content><![CDATA[<h1 id="1-Alt-Click展开所有的子节点"><a href="#1-Alt-Click展开所有的子节点" class="headerlink" title="1. Alt + Click展开所有的子节点"></a>1. Alt + Click展开所有的子节点</h1><p><img src="https://upload-images.jianshu.io/upload_images/8156292-4524814cf7ea524e.gif?imageMogr2/auto-orient/strip" alt="alt-click-expand-node.gif"></p>
<h1 id="2-轻松修改tagName"><a href="#2-轻松修改tagName" class="headerlink" title="2. 轻松修改tagName"></a>2. 轻松修改tagName</h1><p><img src="https://upload-images.jianshu.io/upload_images/8156292-7ef233fca006f66a.gif?imageMogr2/auto-orient/strip" alt="quick-edit-element.gif"></p>
<h1 id="3-查看元素的事件侦听器"><a href="#3-查看元素的事件侦听器" class="headerlink" title="3. 查看元素的事件侦听器"></a>3. 查看元素的事件侦听器</h1><p><img src="https://upload-images.jianshu.io/upload_images/8156292-731375e6190683ef.gif?imageMogr2/auto-orient/strip" alt="view-event-listeners.gif"></p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>DevTools可以向您显示在元素上注册的JavaScript事件侦听器。例如，向click注册的处理程序.addEventListener()。</p>
<p>DevTools还可将您带到注册该事件的确切代码行，这在从中进行外部调试时非常有用。</p>
<p>###如何使用此功能<br>在“Element”面板中检查元素<br>导航到“Element”面板中的“Event Listener”窗格<br>浏览在任何节点上注册的事件。您可以通过在上下文菜单中选择“显示函数定义”来查看事件侦听器的源。</p>
<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>有时候事件显示特别多，可以去掉 <code>Ancestors</code>复选框，只显示绑定在元素自身的事件，而非被代理的事件</p>
<h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>事件的冒泡与代理，事件的队列</p>
]]></content>
      <tags>
        <tag>Chrome Devtools Tip</tag>
      </tags>
  </entry>
  <entry>
    <title>2021-4-7- Chrome Devtools Tip： 13. 通过快捷键快速切换 devtools 附着状态</title>
    <url>/2021/04/07/Chrome%20Devtools%20Tip/2021-4-7-%20Chrome%20Devtools%20Tip%EF%BC%9A%2013.%20%E9%80%9A%E8%BF%87%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%BF%AB%E9%80%9F%E5%88%87%E6%8D%A2%20devtools%20%E9%99%84%E7%9D%80%E7%8A%B6%E6%80%81/</url>
    <content><![CDATA[<p><code>Ctrl + Shift + D</code><br><img src="https://upload-images.jianshu.io/upload_images/8156292-1429d3fb31add89d.gif?imageMogr2/auto-orient/strip" alt="dock-undock-shortcut.gif"></p>
<h1 id="调试chrome-devtools面板自身"><a href="#调试chrome-devtools面板自身" class="headerlink" title="调试chrome devtools面板自身"></a>调试chrome devtools面板自身</h1><p>chrome devtools 可以检查我们的htnl页面，而devtools自身也是一个html页面，可以通过 <code>Ctrl shift I </code>快捷键调试检查面板自己，适用场景为devtools插件开发</p>
]]></content>
      <tags>
        <tag>Chrome Devtools Tip</tag>
      </tags>
  </entry>
  <entry>
    <title>2021-4-7- Chrome Devtools Tip： 14.断点调试相关的技巧</title>
    <url>/2021/04/07/Chrome%20Devtools%20Tip/2021-4-7-%20Chrome%20Devtools%20Tip%EF%BC%9A%2014.%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95%E7%9B%B8%E5%85%B3%E7%9A%84%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/8156292-b182b48798fc84b5.gif?imageMogr2/auto-orient/strip" alt="highlight-paused-statement.gif"><br>调试器暂停后，您现在可以看到正在执行的代码的确切部分。它以高亮显示较深的蓝色阴影。这在调试精简代码时很有用。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/8156292-f5fdd4026a918fda.gif?imageMogr2/auto-orient/strip" alt="debugger-shortcuts.gif"></p>
<p>Toggle a breakpoint while on a line: <code>Cmd + B</code> （切换当前行的断点）<br>Select the next call frame: Ctrl + . (下一个调用栈)<br>Select the previous call frame: Ctrl + , (上一个调用栈)</p>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p>动图上点击的按钮是当遇到报错的时候，自动触发断点调试。<br>我们可以在源代码中添加 <code>debugger</code> 设置断点<br>可以在source面板中文件的行号前面单击设置断点 <code>Cmd + B</code></p>
<h3 id="通过DOM被修改，被移除命中断点"><a href="#通过DOM被修改，被移除命中断点" class="headerlink" title="通过DOM被修改，被移除命中断点"></a>通过DOM被修改，被移除命中断点</h3><p><img src="https://upload-images.jianshu.io/upload_images/8156292-a07045fdf96cc168.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h3 id="通过触发网络请求命中断点"><a href="#通过触发网络请求命中断点" class="headerlink" title="通过触发网络请求命中断点"></a>通过触发网络请求命中断点</h3><p><img src="https://upload-images.jianshu.io/upload_images/8156292-f9c5980598e753fc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h3 id="断点触发后，按住Ctrl-能跳转到的地方会被高亮"><a href="#断点触发后，按住Ctrl-能跳转到的地方会被高亮" class="headerlink" title="断点触发后，按住Ctrl 能跳转到的地方会被高亮"></a>断点触发后，按住Ctrl 能跳转到的地方会被高亮</h3><p><img src="https://upload-images.jianshu.io/upload_images/8156292-371da7a472f180de.gif?imageMogr2/auto-orient/strip" alt="js-jump-to-destination.gif"></p>
]]></content>
      <tags>
        <tag>Chrome Devtools Tip</tag>
      </tags>
  </entry>
  <entry>
    <title>2021-4-7- Chrome Devtools Tip： 15. 颜色拾取器增强</title>
    <url>/2021/04/07/Chrome%20Devtools%20Tip/2021-4-7-%20Chrome%20Devtools%20Tip%EF%BC%9A%2015.%20%E9%A2%9C%E8%89%B2%E6%8B%BE%E5%8F%96%E5%99%A8%E5%A2%9E%E5%BC%BA/</url>
    <content><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/8156292-7f6a9b1f0589ac12.gif?imageMogr2/auto-orient/strip" alt="colour-picker-upgrade.gif"></p>
<p>DevTools中的颜色选择器工具正在升级。</p>
<ul>
<li>有一个滴管功能。</li>
<li>简单的界面即可选择包括Alpha在内的颜色。</li>
<li>彩色格式切换器（十六进制，rgba，hsla）。</li>
<li>对比度功能（当前景色与背景色对比度不高的时候会提示）</li>
</ul>
]]></content>
      <tags>
        <tag>Chrome Devtools Tip</tag>
      </tags>
  </entry>
  <entry>
    <title>2021-4-7- Chrome Devtools Tip： 16. 动画调试</title>
    <url>/2021/04/07/Chrome%20Devtools%20Tip/2021-4-7-%20Chrome%20Devtools%20Tip%EF%BC%9A%2016.%20%E5%8A%A8%E7%94%BB%E8%B0%83%E8%AF%95/</url>
    <content><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/8156292-f951ea3a660a13ac.gif?imageMogr2/auto-orient/strip" alt="easing-preview.gif"><br>如图，点击<code>ease-in</code>前面的icon可以预览渐变效果哟</p>
<h1 id="使用动画记录器记录过渡和动画"><a href="#使用动画记录器记录过渡和动画" class="headerlink" title="使用动画记录器记录过渡和动画"></a>使用动画记录器记录过渡和动画</h1><p><img src="https://upload-images.jianshu.io/upload_images/8156292-d3d63aa5eae61a81.gif?imageMogr2/auto-orient/strip" alt="animation-recorder.gif"><br>打开“动画记录器”后，将捕获所有过渡/动画，这意味着您可以方便地播放它们或在以后检查它们。</p>
<p>将鼠标悬停在矩形块上可以播放动画。<br>单击一个矩形块以检查动画。</p>
<h1 id="动画检查器"><a href="#动画检查器" class="headerlink" title="动画检查器"></a>动画检查器</h1><p><img src="https://upload-images.jianshu.io/upload_images/8156292-19d5948d48e40fbb.gif?imageMogr2/auto-orient/strip" alt="animation-inspector.gif"></p>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p>炫酷的动效能让老板分分钟给你加薪，因为它能让产品卖上价格，用户一看就是大制作，高端大气上档次，这才是前端的价值所在。</p>
<h1 id="阴影调整器"><a href="#阴影调整器" class="headerlink" title="阴影调整器"></a>阴影调整器</h1><p><img src="https://upload-images.jianshu.io/upload_images/8156292-50867e7bfb721216.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
]]></content>
      <tags>
        <tag>Chrome Devtools Tip</tag>
      </tags>
  </entry>
  <entry>
    <title>2021-4-7- Chrome Devtools Tip： 17. 调试jquery 事件监听</title>
    <url>/2021/04/07/Chrome%20Devtools%20Tip/2021-4-7-%20Chrome%20Devtools%20Tip%EF%BC%9A%2017.%20%E8%B0%83%E8%AF%95jquery%20%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC/</url>
    <content><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/8156292-c203c83afc13da33.gif?imageMogr2/auto-orient/strip" alt="jquery-event-listeners.gif"><br>jquery事件监听指向jquery的源代码，这对于调试没啥用，我们可以通过查看监听器方法的定义，找到事件处理函数</p>
]]></content>
      <tags>
        <tag>Chrome Devtools Tip</tag>
      </tags>
  </entry>
  <entry>
    <title>2021-4-7- Chrome Devtools Tip： 18. 隐藏网络请求报错的console.error</title>
    <url>/2021/04/07/Chrome%20Devtools%20Tip/2021-4-7-%20Chrome%20Devtools%20Tip%EF%BC%9A%2018.%20%E9%9A%90%E8%97%8F%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E6%8A%A5%E9%94%99%E7%9A%84console.error/</url>
    <content><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/8156292-5a09ee8fb823b683.gif?imageMogr2/auto-orient/strip" alt="hide-network-console.gif"></p>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p>在定位页面无限重定向,比如一直跳转登录的时候,可以勾选上 <code>Preserve log</code>复选框,查看页面信息<br>在console中执行代码的上下文是根据iframe来的,记得切换iframe来执行相应的代码</p>
]]></content>
      <tags>
        <tag>Chrome Devtools Tip</tag>
      </tags>
  </entry>
  <entry>
    <title>2021-4-7- Chrome Devtools Tip： 19. 使用console.table 更好的展示对象 数组信息</title>
    <url>/2021/04/07/Chrome%20Devtools%20Tip/2021-4-7-%20Chrome%20Devtools%20Tip%EF%BC%9A%2019.%20%E4%BD%BF%E7%94%A8console.table%20%E6%9B%B4%E5%A5%BD%E7%9A%84%E5%B1%95%E7%A4%BA%E5%AF%B9%E8%B1%A1%20%E6%95%B0%E7%BB%84%E4%BF%A1%E6%81%AF/</url>
    <content><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/8156292-a154534659201462.gif?imageMogr2/auto-orient/strip" alt="console-table.gif"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> languages = [</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">&quot;JavaScript&quot;</span>, <span class="attr">fileExtension</span>: <span class="string">&quot;.js&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">&quot;TypeScript&quot;</span>, <span class="attr">fileExtension</span>: <span class="string">&quot;.ts&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">&quot;CoffeeScript&quot;</span>, <span class="attr">fileExtension</span>: <span class="string">&quot;.coffee&quot;</span> &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.table(languages);</span><br></pre></td></tr></table></figure>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>属性太多还可以传第二个参数 ,只展示要某些字段 <code>console.table(languages,[&#39;name&#39;]);</code></p>
<h1 id="使用console-time-诊断程序的运行时间"><a href="#使用console-time-诊断程序的运行时间" class="headerlink" title="使用console.time 诊断程序的运行时间"></a>使用console.time 诊断程序的运行时间</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.time(<span class="string">&#x27;My time #1&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.timeLog(<span class="string">&#x27;My time #1&#x27;</span>); <span class="comment">//打印计时器时间</span></span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">&#x27;My time #1&#x27;</span>);<span class="comment">//打印计时器时间,并终止计时器</span></span><br></pre></td></tr></table></figure>
<h1 id="使用-console-timeStamp-可以在录制性能时间线打标记-快速定位性能问题"><a href="#使用-console-timeStamp-可以在录制性能时间线打标记-快速定位性能问题" class="headerlink" title="使用 console.timeStamp() , 可以在录制性能时间线打标记,快速定位性能问题"></a>使用 console.timeStamp() , 可以在录制性能时间线打标记,快速定位性能问题</h1><p><img src="https://upload-images.jianshu.io/upload_images/8156292-64043923a748af3c.gif?imageMogr2/auto-orient/strip" alt="console-timestamp-timeline.gif"></p>
]]></content>
      <tags>
        <tag>Chrome Devtools Tip</tag>
      </tags>
  </entry>
  <entry>
    <title>2021-4-7- Chrome Devtools Tip： 20. Element面板快速切换class查看效果</title>
    <url>/2021/04/07/Chrome%20Devtools%20Tip/2021-4-7-%20Chrome%20Devtools%20Tip%EF%BC%9A%2020.%20Element%E9%9D%A2%E6%9D%BF%E5%BF%AB%E9%80%9F%E5%88%87%E6%8D%A2class%E6%9F%A5%E7%9C%8B%E6%95%88%E6%9E%9C/</url>
    <content><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/8156292-b89e5a5150f31bd9.gif?imageMogr2/auto-orient/strip" alt="toggle-element-classes.gif"></p>
<ol>
<li>选定元素</li>
<li>点击 .cls 按钮,出现class list</li>
<li>点击前面的复选框,进行切换</li>
<li>还能添加class</li>
</ol>
]]></content>
      <tags>
        <tag>Chrome Devtools Tip</tag>
      </tags>
  </entry>
  <entry>
    <title>2021-4-7- Chrome Devtools Tip： 21. 降低CPU的性能与网络速度来观测性能</title>
    <url>/2021/04/07/Chrome%20Devtools%20Tip/2021-4-7-%20Chrome%20Devtools%20Tip%EF%BC%9A%2021.%20%E9%99%8D%E4%BD%8ECPU%E7%9A%84%E6%80%A7%E8%83%BD%E4%B8%8E%E7%BD%91%E7%BB%9C%E9%80%9F%E5%BA%A6%E6%9D%A5%E8%A7%82%E6%B5%8B%E6%80%A7%E8%83%BD/</url>
    <content><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/8156292-0444ada0cfd3c1c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p>老版本面板名称叫 <code>Timeline</code> 时间线<br>有些部署在现网的局点,由于国际网络延时高,会导致一些意想不到的BUG,为了模拟延时,就能用上这个调试功能了<br>模拟低性能计算机可以将现有的性能问题进行放大,让我们的应用跑的更快,毕竟我们开发都是i5起步的CPU,还是要照顾下公司的老机器</p>
]]></content>
      <tags>
        <tag>Chrome Devtools Tip</tag>
      </tags>
  </entry>
  <entry>
    <title>2021-4-7- Chrome Devtools Tip： 22. 使用 Sources 面板 Threads 调试</title>
    <url>/2021/04/07/Chrome%20Devtools%20Tip/2021-4-7-%20Chrome%20Devtools%20Tip%EF%BC%9A%2022.%20%E4%BD%BF%E7%94%A8%20Sources%20%E9%9D%A2%E6%9D%BF%20Threads%20%E8%B0%83%E8%AF%95/</url>
    <content><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/8156292-f7e721beaffe14aa.gif?imageMogr2/auto-orient/strip" alt="debug-per-thread.gif"><br>如果您正在使用利用多个线程的JavaScript功能（例如Service Worker或Web Workers），则Sources Panel会考虑到这一点。</p>
<p>由于每个线程都有其自己的全局脚本上下文，因此您可以选择一个特定的线程进行调试（例如，在其上设置断点）。只需在Sources面板中打开Threads 窗格即可。您应该看到主线程以及所有可用的其他线程。</p>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p><img src="https://upload-images.jianshu.io/upload_images/8156292-91bbd2172b895f2a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>这个是Chrome 89的截图,web worker是直接显示在左边的可以找打对应的文件打断点。右边只是一个指示器，告诉我们断点处在哪个线程<br>这里还可以看到 Content Scripts 面板 ,Chrome拓展开发的时候会用到这个,他能共享DOM</p>
<p>在V3版本的Chrome拓展开发中 Service Worker 也替代了 background.js<br>Service Worker的调试 还有系统通知等等的调试可以看Application面板<br><img src="https://upload-images.jianshu.io/upload_images/8156292-77a7f279e19de948.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
]]></content>
      <tags>
        <tag>Chrome Devtools Tip</tag>
      </tags>
  </entry>
  <entry>
    <title>2021-4-7- Chrome Devtools Tip： 23. 使用sourceMap 调试ESNext语法</title>
    <url>/2021/04/07/Chrome%20Devtools%20Tip/2021-4-7-%20Chrome%20Devtools%20Tip%EF%BC%9A%2023.%20%E4%BD%BF%E7%94%A8sourceMap%20%E8%B0%83%E8%AF%95ESNext%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<p>现在经常使用ESNext语法书写代码,再使用babel转换成ES5,</p>
<ol>
<li>使用webpack 打包时候设置 devtool 为 source-map 即可</li>
<li>生产环境上一般使用压缩混淆后的代码</li>
<li>生产环境的ngnix服务器出于安全考虑,一般也不会返回source map类型的文件!!!</li>
</ol>
<h1 id="使用Sourcemap-调试时解析变量名"><a href="#使用Sourcemap-调试时解析变量名" class="headerlink" title="使用Sourcemap 调试时解析变量名"></a>使用Sourcemap 调试时解析变量名</h1><p><img src="https://upload-images.jianshu.io/upload_images/8156292-ede34451980feb28.gif?imageMogr2/auto-orient/strip" alt="resolve-variable-names.gif"><br>调试的时候就算有sourceMap,显示的依然是被混淆的名字<code>a,b,c</code>这种,我们想看到真实的变量名称,怎么做呢?<br>启动 试验功能的<code>Resolve Variable Names</code></p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>我在Chrome 89 看不到这个老外说的这个试验功能,应该是已经转正了!!不需要单独启用,知道有这个东西就好了</p>
]]></content>
      <tags>
        <tag>Chrome Devtools Tip</tag>
      </tags>
  </entry>
  <entry>
    <title>2021-4-7- Chrome Devtools Tip： 24. 在“Network”中查看来自其他应用程序的网络流量</title>
    <url>/2021/04/07/Chrome%20Devtools%20Tip/2021-4-7-%20Chrome%20Devtools%20Tip%EF%BC%9A%2024.%20%E5%9C%A8%E2%80%9CNetwork%E2%80%9D%E4%B8%AD%E6%9F%A5%E7%9C%8B%E6%9D%A5%E8%87%AA%E5%85%B6%E4%BB%96%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F/</url>
    <content><![CDATA[<h2 id="常用的抓包工具"><a href="#常用的抓包工具" class="headerlink" title="常用的抓包工具"></a>常用的抓包工具</h2><p>Fiddler 小巧精悍,适合http<br>Burpsuite 安全测试的时候用过,很强大<br>wireshark  抓网卡,内容没有聚合上手难度高点</p>
<p>NetWork 面板很好用,用来拦截操作系统的网络流量<br><img src="https://upload-images.jianshu.io/upload_images/8156292-af20e8217608951b.gif?imageMogr2/auto-orient/strip" alt="os-network-proxy.gif"></p>
<p>这里需要另外一个 工具来配合 github kdzwinel/betwixt<br>安装好了再设置下系统的代理就好了</p>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p>其实这个不是用Chrome DevTools去抓包啦,只是betwixt这个抓包工具,长得跟NetWork面板一样</p>
]]></content>
      <tags>
        <tag>Chrome Devtools Tip</tag>
      </tags>
  </entry>
  <entry>
    <title>2021-4-7- Chrome Devtools Tip： 25. 通过Performance面板录制,行级别查看代码耗时</title>
    <url>/2021/04/07/Chrome%20Devtools%20Tip/2021-4-7-%20Chrome%20Devtools%20Tip%EF%BC%9A%2025.%20%E9%80%9A%E8%BF%87Performance%E9%9D%A2%E6%9D%BF%E5%BD%95%E5%88%B6,%E8%A1%8C%E7%BA%A7%E5%88%AB%E6%9F%A5%E7%9C%8B%E4%BB%A3%E7%A0%81%E8%80%97%E6%97%B6/</url>
    <content><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/8156292-6b1b13e4a3b65a7b.gif?imageMogr2/auto-orient/strip" alt="line-level-profiling.gif"></p>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p>页面性能主要看 接口性能(Network) CPU占用(Performance)  内存占用(Memory) 代码执行耗时</p>
]]></content>
      <tags>
        <tag>Chrome Devtools Tip</tag>
      </tags>
  </entry>
  <entry>
    <title>2021-4-7- Chrome Devtools Tip： 26. Store as global variable 存储成全局变量</title>
    <url>/2021/04/07/Chrome%20Devtools%20Tip/2021-4-7-%20Chrome%20Devtools%20Tip%EF%BC%9A%2026.%20Store%20as%20global%20variable%20%E5%AD%98%E5%82%A8%E6%88%90%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/8156292-4e305ded9d17242a.gif?imageMogr2/auto-orient/strip" alt="web-animation-api.gif"></p>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p>很多地方的右键上下文菜单上有这个<code>Store as global variable </code>这个选项<br>作用是在 console 面板存成全局变量,因为对象的引用类型,修改这个全局变量,其实就是改变原对象的值,很强大。</p>
<h2 id="将DOM变成全局变量"><a href="#将DOM变成全局变量" class="headerlink" title="将DOM变成全局变量"></a>将DOM变成全局变量</h2><p><img src="https://upload-images.jianshu.io/upload_images/8156292-3d900a6460dfc1fa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h2 id="将事件的处理函数作为全局变量"><a href="#将事件的处理函数作为全局变量" class="headerlink" title="将事件的处理函数作为全局变量"></a>将事件的处理函数作为全局变量</h2><p><img src="https://upload-images.jianshu.io/upload_images/8156292-ccf98baf8acbfbf2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h2 id="打断点时候的任意一个局部变量"><a href="#打断点时候的任意一个局部变量" class="headerlink" title="打断点时候的任意一个局部变量"></a>打断点时候的任意一个局部变量</h2><p><img src="https://upload-images.jianshu.io/upload_images/8156292-1ee0184cd551f0b5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h2 id="消息的响应体预览界面"><a href="#消息的响应体预览界面" class="headerlink" title="消息的响应体预览界面"></a>消息的响应体预览界面</h2><p><img src="https://upload-images.jianshu.io/upload_images/8156292-792fb8a98b463887.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h2 id="还有其他我没发现的地方"><a href="#还有其他我没发现的地方" class="headerlink" title="还有其他我没发现的地方"></a>还有其他我没发现的地方</h2><p>请大家评论区补充</p>
]]></content>
      <tags>
        <tag>Chrome Devtools Tip</tag>
      </tags>
  </entry>
  <entry>
    <title>2021-4-7- Chrome Devtools Tip： 27. 利用Quick Source 快速写样式</title>
    <url>/2021/04/07/Chrome%20Devtools%20Tip/2021-4-7-%20Chrome%20Devtools%20Tip%EF%BC%9A%2027.%20%E5%88%A9%E7%94%A8Quick%20Source%20%E5%BF%AB%E9%80%9F%E5%86%99%E6%A0%B7%E5%BC%8F/</url>
    <content><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/8156292-16ac3e0e3083942e.gif?imageMogr2/auto-orient/strip" alt="quick-source.gif"></p>
<ol>
<li><code>ctrl shift p</code> 快速打开 <code>quick source</code>面板  </li>
<li>在<code>Element</code> <code>Style</code>面板修改样式可以与 该面板下的文件同步</li>
<li>修改好以后直接另存为覆盖代码库中的文件</li>
</ol>
]]></content>
      <tags>
        <tag>Chrome Devtools Tip</tag>
      </tags>
  </entry>
  <entry>
    <title>2021-4-7- Chrome Devtools Tip： 28. Chrome带参数启动</title>
    <url>/2021/04/07/Chrome%20Devtools%20Tip/2021-4-7-%20Chrome%20Devtools%20Tip%EF%BC%9A%2028.%20Chrome%E5%B8%A6%E5%8F%82%E6%95%B0%E5%90%AF%E5%8A%A8/</url>
    <content><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/8156292-cbfad927c7427d7f.gif?imageMogr2/auto-orient/strip" alt="auto-open-devtools.gif"></p>
<p><code>--auto-open-devtools-for-tabs</code> 新打开的标签页,带上devtools工具<br>比如新打开的页面有重定向问题,但是由于没有打开devtools会导致在Network面板看不到任何有用的信息.</p>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p>老外给的图里面是使用命令行启动，苹果机器的，在windows下可以创建快接方式，在快捷方式里带上参数即可<br><img src="https://upload-images.jianshu.io/upload_images/8156292-27dd854e848f6924.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h1 id="没生效！！"><a href="#没生效！！" class="headerlink" title="没生效！！"></a>没生效！！</h1><p>添加启动参数后,发现没生效。已经打开了一个浏览器实例导致的。关闭所有的Chrome浏览器，再通过这个快接方式打开就能生效了。</p>
<h1 id="让Chrome支持跨域调用"><a href="#让Chrome支持跨域调用" class="headerlink" title="让Chrome支持跨域调用"></a>让Chrome支持跨域调用</h1><p>本地调试小程序挺好用的,不用代理服务器<br><code> --disable-web-security --user-data-dir=C:\MyChromeDevUserData</code> 高版本Chrome需要<code>--user-data-dir</code>这个参数才可以使disable-web-security生效,后面是个例子<br><code>&quot;C:\Program Files (x86)\Google\Chrome\Application\chrome.exe&quot; --disable-web-security --user-data-dir=C:\MyChromeDevUserData</code></p>
<h1 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h1><p>老铁们,还有些什么有用的启动命令可以在评论区发下</p>
]]></content>
      <tags>
        <tag>Chrome Devtools Tip</tag>
      </tags>
  </entry>
  <entry>
    <title>2021-4-7- Chrome Devtools Tip： 29. 自定义Network面板的显示列，展示我们关心的响应头</title>
    <url>/2021/04/07/Chrome%20Devtools%20Tip/2021-4-7-%20Chrome%20Devtools%20Tip%EF%BC%9A%2029.%20%E8%87%AA%E5%AE%9A%E4%B9%89Network%E9%9D%A2%E6%9D%BF%E7%9A%84%E6%98%BE%E7%A4%BA%E5%88%97%EF%BC%8C%E5%B1%95%E7%A4%BA%E6%88%91%E4%BB%AC%E5%85%B3%E5%BF%83%E7%9A%84%E5%93%8D%E5%BA%94%E5%A4%B4/</url>
    <content><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/8156292-73a4ae427d244218.gif?imageMogr2/auto-orient/strip" alt="manage-network-response-headers.gif"><br>正常情况下我们需要查看详情才能看到具体的信息，<br>通过自定义Network面板的显示列就可以在列表中展示我们关心的内容。</p>
<h1 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h1><p>我暂时没想到开发中的实际用途，老铁们有妙用可以在评论区告诉在下</p>
]]></content>
      <tags>
        <tag>Chrome Devtools Tip</tag>
      </tags>
  </entry>
  <entry>
    <title>2021-4-7- Chrome Devtools Tip： 30. devtools支持热更新调试Nodejs</title>
    <url>/2021/04/07/Chrome%20Devtools%20Tip/2021-4-7-%20Chrome%20Devtools%20Tip%EF%BC%9A%2030.%20devtools%E6%94%AF%E6%8C%81%E7%83%AD%E6%9B%B4%E6%96%B0%E8%B0%83%E8%AF%95Nodejs/</url>
    <content><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/8156292-2bebd4c7dccc92ee.gif?imageMogr2/auto-orient/strip" alt="node-js-hot-code-swap.gif"></p>
<ol>
<li><code>node --inspect index.js</code> 调试启动node</li>
<li>Node debugger 已经不是实验功能了,可以直接使用</li>
</ol>
<h1 id="另一种链接到nodejs的方式"><a href="#另一种链接到nodejs的方式" class="headerlink" title="另一种链接到nodejs的方式"></a>另一种链接到nodejs的方式</h1><p><img src="https://upload-images.jianshu.io/upload_images/8156292-575d26b4b49712c2.gif?imageMogr2/auto-orient/strip" alt="improved-node-debugging.gif"></p>
]]></content>
      <tags>
        <tag>Chrome Devtools Tip</tag>
      </tags>
  </entry>
  <entry>
    <title>2021-4-7- Chrome Devtools Tip： 31. Blackboxing 获得更好的调试会话</title>
    <url>/2021/04/07/Chrome%20Devtools%20Tip/2021-4-7-%20Chrome%20Devtools%20Tip%EF%BC%9A%2031.%20Blackboxing%20%E8%8E%B7%E5%BE%97%E6%9B%B4%E5%A5%BD%E7%9A%84%E8%B0%83%E8%AF%95%E4%BC%9A%E8%AF%9D/</url>
    <content><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/8156292-f08a9ae48aa2fb3e.gif?imageMogr2/auto-orient/strip" alt="blackboxing.gif"><br>比如我们自己封装了一个 log.js,里面调用了console.log()。<br>所有打印出来的日志都定位到这个log.js文件,这不是我们想要。我们可以把 log.js设置成 Blackboxing Script。<br>这样就能定位到上一个调用栈的方法上了。</p>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p>真心很实用的功能，以前不知道可以这么玩，我是在打印的位置设置断点，看调用栈，再设置断点。把断点取消掉。</p>
]]></content>
      <tags>
        <tag>Chrome Devtools Tip</tag>
      </tags>
  </entry>
  <entry>
    <title>2021-4-7- Chrome Devtools Tip： 32. lighthouse 面板检查网页状态</title>
    <url>/2021/04/07/Chrome%20Devtools%20Tip/2021-4-7-%20Chrome%20Devtools%20Tip%EF%BC%9A%2032.%20lighthouse%20%E9%9D%A2%E6%9D%BF%E6%A3%80%E6%9F%A5%E7%BD%91%E9%A1%B5%E7%8A%B6%E6%80%81/</url>
    <content><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/8156292-369c984fe07235d6.gif?imageMogr2/auto-orient/strip" alt="lighthouse-audits.gif"></p>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p>多维度给网页打分的工具,把里面的问题都修复了,网页绝对棒棒哒。我们可以根据生成的报告，有针对性的修复页面问题</p>
]]></content>
      <tags>
        <tag>Chrome Devtools Tip</tag>
      </tags>
  </entry>
  <entry>
    <title>2021-4-7- Chrome Devtools Tip： 33. `css tracker`面板查看未使用的css</title>
    <url>/2021/04/07/Chrome%20Devtools%20Tip/2021-4-7-%20Chrome%20Devtools%20Tip%EF%BC%9A%2033.%20%60css%20tracker%60%E9%9D%A2%E6%9D%BF%E6%9F%A5%E7%9C%8B%E6%9C%AA%E4%BD%BF%E7%94%A8%E7%9A%84css/</url>
    <content><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/8156292-81a164ed962f8385.gif?imageMogr2/auto-orient/strip" alt="css-tracker-enhancements.gif"><br><code>css-tracker</code>面板查看未使用的css</p>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p>这个其实用处不大，因为很多css资源是共享的<br>但是 em….. 它真的可以发现某个项目有多烂,顺便推荐一个原子化的css库 <code>tailwindcss</code>可以有效的减少垃圾样式代码</p>
]]></content>
      <tags>
        <tag>Chrome Devtools Tip</tag>
      </tags>
  </entry>
  <entry>
    <title>2021-4-7- Chrome Devtools Tip： 34. 通过服务器增加 Server-Timing 响应头展示时间信息</title>
    <url>/2021/04/07/Chrome%20Devtools%20Tip/2021-4-7-%20Chrome%20Devtools%20Tip%EF%BC%9A%2034.%20%E9%80%9A%E8%BF%87%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%A2%9E%E5%8A%A0%20Server-Timing%20%E5%93%8D%E5%BA%94%E5%A4%B4%E5%B1%95%E7%A4%BA%E6%97%B6%E9%97%B4%E4%BF%A1%E6%81%AF/</url>
    <content><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/8156292-dfe3866e1052de27.gif?imageMogr2/auto-orient/strip" alt="server-timing.gif"><br>nodejs 示例代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> headers = &#123;</span><br><span class="line">    <span class="string">&#x27;Server-Timing&#x27;</span>: <span class="string">`</span></span><br><span class="line"><span class="string">        lb=18; &quot;Load Balancer&quot;,</span></span><br><span class="line"><span class="string">        server-3=104; &quot;Server #3 Startup&quot;,</span></span><br><span class="line"><span class="string">        db-read=187; &quot;Database Read&quot;,</span></span><br><span class="line"><span class="string">        aws-download=317; &quot;AWS Content Download&quot;,</span></span><br><span class="line"><span class="string">        db-write=218; &quot;Database Write&quot;,</span></span><br><span class="line"><span class="string">        templating=48; &quot;Templating plugin&quot;</span></span><br><span class="line"><span class="string">    `</span>.replace(<span class="regexp">/\n/g</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">response.writeHead(<span class="number">200</span>, headers);</span><br></pre></td></tr></table></figure>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p>后台这里应该有对应的中间件实现,有兴趣的老铁可以自行搜索下</p>
]]></content>
      <tags>
        <tag>Chrome Devtools Tip</tag>
      </tags>
  </entry>
  <entry>
    <title>2021-4-7- Chrome Devtools Tip： 35. Network 查看实际访问的IP</title>
    <url>/2021/04/07/Chrome%20Devtools%20Tip/2021-4-7-%20Chrome%20Devtools%20Tip%EF%BC%9A%2035.%20Network%20%E6%9F%A5%E7%9C%8B%E5%AE%9E%E9%99%85%E8%AE%BF%E9%97%AE%E7%9A%84IP/</url>
    <content><![CDATA[<p>通过自定义显示列的方式,可以看到域名解析后的IP地址<br><img src="https://upload-images.jianshu.io/upload_images/8156292-bcce4dd0424848bc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h1 id="快速找到CDN-这个我没找到-Chrome-89"><a href="#快速找到CDN-这个我没找到-Chrome-89" class="headerlink" title="快速找到CDN(这个我没找到 Chrome 89)"></a>快速找到CDN(这个我没找到 Chrome 89)</h1><p><img src="https://upload-images.jianshu.io/upload_images/8156292-bb7d635078e3f763.gif?imageMogr2/auto-orient/strip" alt="network-products.gif"></p>
]]></content>
      <tags>
        <tag>Chrome Devtools Tip</tag>
      </tags>
  </entry>
  <entry>
    <title>2021-4-7- Chrome Devtools Tip： 36. 自定义时间测量API</title>
    <url>/2021/04/07/Chrome%20Devtools%20Tip/2021-4-7-%20Chrome%20Devtools%20Tip%EF%BC%9A%2036.%20%E8%87%AA%E5%AE%9A%E4%B9%89%E6%97%B6%E9%97%B4%E6%B5%8B%E9%87%8FAPI/</url>
    <content><![CDATA[<p>Performance 面板就是以前的timeline面板。用于可视化分析代码性能。js提供了对应的API用于分析<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/User_Timing_API">https://developer.mozilla.org/zh-CN/docs/Web/API/User_Timing_API</a></p>
<p><img src="https://upload-images.jianshu.io/upload_images/8156292-b83d2a537e1aeee8.gif?imageMogr2/auto-orient/strip" alt="user-timing-performance.gif"><br>您可以使用User Timing API查找缓慢的JavaScript代码。</p>
<p>尝试包装可能缓慢的代码，如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">performance.mark(<span class="string">&#x27;costlyFunction Start&#x27;</span>) <span class="comment">// 起始标记</span></span><br><span class="line"></span><br><span class="line">costlyFunction()</span><br><span class="line"></span><br><span class="line">performance.mark(<span class="string">&#x27;costlyFunction End&#x27;</span>) <span class="comment">// 终止标记</span></span><br><span class="line"></span><br><span class="line">performance.measure(</span><br><span class="line">    <span class="string">&#x27;costlyFunction&#x27;</span>, <span class="comment">// 性能测量名称,会在时间线显示</span></span><br><span class="line">    <span class="string">&#x27;costlyFunction Start&#x27;</span>,  起始标记</span><br><span class="line">    <span class="string">&#x27;costlyFunction End&#x27;</span> 终止标记</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h3 id="使用性能API有以下好处"><a href="#使用性能API有以下好处" class="headerlink" title="使用性能API有以下好处"></a>使用性能API有以下好处</h3><ul>
<li>将性能指标注入您不熟悉的应用程序中(上图的例子)</li>
<li>以编程方式读取JavaScript中记录的所有性能指标。<code>performance.getEntries()</code> <code>performance.getEntriesByType(entryType)</code><br><code>performance.getEntriesByName(name, entryType)</code></li>
<li>performance将性能捕获代码部署到最终用户，以便您可以收集实际用户指标。</li>
<li>了解真实用户监视的好处，以及它与综合监视的比较。</li>
<li>使用<a href="https://github.com/SOASTA/boomerang">Boomerang</a>和Node.js之类的工具组合，从您的真实用户直接接收服务器的性能指标。</li>
<li>Dev在DevTools中可视化用户计时指标，并将其与现有的火焰图相关联。</li>
<li>使用外部服务和插件可视化您的性能指标。</li>
</ul>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p>我们做性能录制的时候,系统获取资源,事件触发的时候,内部就是调用的这个API。Chrome选择暴露给我们，让我们在录制的时候，可以更快的找到我们想分析的部分，有针对性的分析我们想分析的代码段。我们还能做监控，当代码执行达不到我们预期的效率的时候，触发上报机制，上报到监控系统。</p>
]]></content>
      <tags>
        <tag>Chrome Devtools Tip</tag>
      </tags>
  </entry>
  <entry>
    <title>2021-4-7- Chrome Devtools Tip： 38. 复制完整的调用栈</title>
    <url>/2021/04/07/Chrome%20Devtools%20Tip/2021-4-7-%20Chrome%20Devtools%20Tip%EF%BC%9A%2038.%20%E5%A4%8D%E5%88%B6%E5%AE%8C%E6%95%B4%E7%9A%84%E8%B0%83%E7%94%A8%E6%A0%88/</url>
    <content><![CDATA[<p>当打断点的时候,可以在如下图进行调用栈的复制,复制到剪贴板!!<br><img src="https://upload-images.jianshu.io/upload_images/8156292-369ec63c02f61443.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h1 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h1><p>这个鸡肋功能到底有啥用啊?? 发stackOverflow帖子的时候用吗?</p>
]]></content>
      <tags>
        <tag>Chrome Devtools Tip</tag>
      </tags>
  </entry>
  <entry>
    <title>2021-4-7- Chrome Devtools Tip： 39. 网页全页截图</title>
    <url>/2021/04/07/Chrome%20Devtools%20Tip/2021-4-7-%20Chrome%20Devtools%20Tip%EF%BC%9A%2039.%20%E7%BD%91%E9%A1%B5%E5%85%A8%E9%A1%B5%E6%88%AA%E5%9B%BE/</url>
    <content><![CDATA[<p>这个真心不错,以前都是装插件使用滚动截图的功能弄得</p>
<ol>
<li>F12 打开</li>
<li><code>ctrl shift p</code>打开 goto anywhere 命令栏</li>
<li>输入 <code>full</code>找到对应的命令回车<br><img src="https://upload-images.jianshu.io/upload_images/8156292-07c9b096e0015d2d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li>
</ol>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p>如果觉得每次找这个命令麻烦,可以把该功能设置成快捷键<br>除了全页截图,还有<br>Capture node screenshot - 截取正在检查的节点<br>Capture screenshot - 只截取可视区域的页面<br>Capture full size screenshot - 整个页面的截图,即使没有呈现在可视区域内的<br>Capture area screenshot - 跟QQ截图一样,自己划定区域</p>
<h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>这个截图功能在做自动化测试时候非常有用,不知道 webDriver是不是用这种内置API去实现的,还是说用的c++调用操作系统能力去实现的?有知道的老铁留言讨论下</p>
]]></content>
      <tags>
        <tag>Chrome Devtools Tip</tag>
      </tags>
  </entry>
  <entry>
    <title>2021-4-7- Chrome Devtools Tip： 7.将图片复制为base64编码data URI</title>
    <url>/2021/04/07/Chrome%20Devtools%20Tip/2021-4-7-%20Chrome%20Devtools%20Tip%EF%BC%9A%207.%20%E5%B0%86%E5%9B%BE%E7%89%87%E5%A4%8D%E5%88%B6%E4%B8%BAbase64%E7%BC%96%E7%A0%81data%20URI/</url>
    <content><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/8156292-10bdf710d15689c8.gif?imageMogr2/auto-orient/strip" alt="copy-as-data-uri.gif"></p>
<h1 id="通过“Element”面板中的CSS选择器搜索HTML元素"><a href="#通过“Element”面板中的CSS选择器搜索HTML元素" class="headerlink" title="通过“Element”面板中的CSS选择器搜索HTML元素"></a>通过“Element”面板中的CSS选择器搜索HTML元素</h1><p><img src="https://upload-images.jianshu.io/upload_images/8156292-4b8101a88b72ca11.gif?imageMogr2/auto-orient/strip" alt="dom-search-by-selector.gif"></p>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><ol>
<li>js可以通过canvas 的drawImage() 然后再 toDataURL()转换成base64   </li>
<li>webpack的url-loader 也能转base64</li>
<li>css selector 可以查找元素，Xpath也是可以的</li>
</ol>
]]></content>
      <tags>
        <tag>Chrome Devtools Tip</tag>
      </tags>
  </entry>
  <entry>
    <title>2021-4-7- Chrome Devtools Tip： 8.资源面板Source中的快捷键</title>
    <url>/2021/04/07/Chrome%20Devtools%20Tip/2021-4-7-%20Chrome%20Devtools%20Tip%EF%BC%9A%208.%20%E8%B5%84%E6%BA%90%E9%9D%A2%E6%9D%BFSource%E4%B8%AD%E7%9A%84%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    <content><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/8156292-293c6c7a656174ab.gif?imageMogr2/auto-orient/strip" alt="go-to-column.gif"></p>
<ol>
<li>Ctrl + O 或者是 Ctrl + P 可以用于查找文件，这个跟vscode是一致的</li>
<li>打开查找工具栏 @开头查找函数 ：开头跳转行好 &gt; 开头查找命令</li>
</ol>
<p><img src="https://upload-images.jianshu.io/upload_images/8156292-8f0a42c8c47ca12c.gif?imageMogr2/auto-orient/strip" alt="editing-locations.gif"></p>
<ol>
<li>ALT+ ←  ALT+ → 可以跳转光标的历史位置，vscode中也是一样的，方便查看定义，再回到原来的位置</li>
<li><code>ctrl shift o</code> 查找文件中的方法定义,不在source面板中使用会跳转到书签管理器界面。这个vscode快捷键是一样的。<br><img src="https://upload-images.jianshu.io/upload_images/8156292-cee42ec6605207cf.gif?imageMogr2/auto-orient/strip" alt="go-to-member.gif"></li>
</ol>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p>资源面板里面编辑文件是有智能提示和代码检测的呢</p>
]]></content>
      <tags>
        <tag>Chrome Devtools Tip</tag>
      </tags>
  </entry>
  <entry>
    <title>2021-4-7- Chrome Devtools Tip： 9.多光标编辑 框选</title>
    <url>/2021/04/07/Chrome%20Devtools%20Tip/2021-4-7-%20Chrome%20Devtools%20Tip%EF%BC%9A%209.%E5%A4%9A%E5%85%89%E6%A0%87%E7%BC%96%E8%BE%91%20%E6%A1%86%E9%80%89/</url>
    <content><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/8156292-a28a562f0bf0c356.gif?imageMogr2/auto-orient/strip" alt="multiple-cursors.gif"><br><code>Ctrl + click </code> 撤销 <code>Ctrl + U </code></p>
<p><img src="https://upload-images.jianshu.io/upload_images/8156292-e85e9974e61816f8.gif?imageMogr2/auto-orient/strip" alt="drag-select.gif"></p>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p>vscode中的<strong>多光标</strong>快捷键是 <code>ALT+ click    </code><br>框选是 <code>ALT+ SHIFT + 拖动</code><br><code>Ctrl+D</code>选中相同项<br><code>Ctrl+ Alt+ ↑</code>  <code>Ctrl+ Alt+ ↓</code></p>
]]></content>
      <tags>
        <tag>Chrome Devtools Tip</tag>
      </tags>
  </entry>
  <entry>
    <title>2021-4-7- Chrome Devtools Tip：37. 查看帧率FPS</title>
    <url>/2021/04/07/Chrome%20Devtools%20Tip/2021-4-7-%20Chrome%20Devtools%20Tip%EF%BC%9A37.%20%E6%9F%A5%E7%9C%8B%E5%B8%A7%E7%8E%87FPS/</url>
    <content><![CDATA[<p>帧率是视频设备可以产生图像（或帧）的速率。 电影和游戏最熟悉它，但现在已广泛用作网站和 Web 应用程序的性能指标。</p>
<blockquote>
<p>60 fps 的帧率被认为是实现流畅显示的目标，因此，为响应某些事件而需要同步进行的所有更新，需要在 16.7 ms (1000ms/60次=16.7ms  )内完成。</p>
</blockquote>
<blockquote>
<p>但是，一致性尤为重要：如果您无法提供 60 fps，则最好以更低的速率连续提供更好的帧率，并避免帧速率突然下降而导致站点假死。</p>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/8156292-e47f4f9b065e1322.gif?imageMogr2/auto-orient/strip" alt="render-perf-pane.gif"></p>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p>新版的这个功能貌似被移除了,我以前还用过 render 面板去看元素重绘还是很方便的,有颜色做区分<br>如果真要看FPS,建议还是在录制一下,参考下图去查看比较方便<br><img src="https://upload-images.jianshu.io/upload_images/8156292-eb77c220b0f33ff5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
]]></content>
      <tags>
        <tag>Chrome Devtools Tip</tag>
      </tags>
  </entry>
  <entry>
    <title>chrome几个有用的带参数启动项</title>
    <url>/2021/09/26/chrome/chrome%E5%87%A0%E4%B8%AA%E6%9C%89%E7%94%A8%E7%9A%84%E5%B8%A6%E5%8F%82%E6%95%B0%E5%90%AF%E5%8A%A8%E9%A1%B9/</url>
    <content><![CDATA[<h2 id="打开新页签的时候自动打开devtools"><a href="#打开新页签的时候自动打开devtools" class="headerlink" title="打开新页签的时候自动打开devtools"></a>打开新页签的时候自动打开devtools</h2><p><code>--auto-open-devtools-for-tabs</code></p>
<h2 id="去除安全井盖-打开没有证书的https页面的时候就不会有告警"><a href="#去除安全井盖-打开没有证书的https页面的时候就不会有告警" class="headerlink" title="去除安全井盖,打开没有证书的https页面的时候就不会有告警"></a>去除安全井盖,打开没有证书的https页面的时候就不会有告警</h2><p><code>--ignore-certificate-errors</code></p>
<h2 id="关闭安全验证-同源策略会被关闭-方便口语调试-新版本的chrome后面的用户目录也是必须设置的"><a href="#关闭安全验证-同源策略会被关闭-方便口语调试-新版本的chrome后面的用户目录也是必须设置的" class="headerlink" title="关闭安全验证,同源策略会被关闭,方便口语调试,新版本的chrome后面的用户目录也是必须设置的"></a>关闭安全验证,同源策略会被关闭,方便口语调试,新版本的chrome后面的用户目录也是必须设置的</h2><p><code>--disable-web-securty --user-data-dir=C:\chromeData</code></p>
]]></content>
      <tags>
        <tag>chrome</tag>
      </tags>
  </entry>
  <entry>
    <title>chrome浏览器窗口关闭后,后台进程仍在运行</title>
    <url>/2021/09/25/chrome/chrome%E6%B5%8F%E8%A7%88%E5%99%A8%E7%AA%97%E5%8F%A3%E5%85%B3%E9%97%AD%E5%90%8E-%E5%90%8E%E5%8F%B0%E8%BF%9B%E7%A8%8B%E4%BB%8D%E5%9C%A8%E8%BF%90%E8%A1%8C/</url>
    <content><![CDATA[<p><code>chrome://settings/system</code> 里面有一个<code>关闭 Google Chrome 后继续运行后台应用</code> 默认是打开的,需要手动关闭。<br>如果项目中用到了sessionStorage的话,可能会影响到正常的逻辑。<br><img src="/images/2021-09-25-20-54-05.png"></p>
]]></content>
      <tags>
        <tag>chrome</tag>
      </tags>
  </entry>
  <entry>
    <title>让 chrome h5 支持 m3u8格式视频</title>
    <url>/2021/09/26/chrome/%E8%AE%A9-chrome-H5-%E6%94%AF%E6%8C%81-m3u8%E6%A0%BC%E5%BC%8F%E8%A7%86%E9%A2%91/</url>
    <content><![CDATA[<ul>
<li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/Audio_and_video_delivery">Audio_and_video_delivery</a></p>
</li>
<li><p><a href="https://developer.mozilla.org/en-US/docs/Web/Guide/Audio_and_video_delivery/Live_streaming_web_audio_and_video">Live streaming web audio and video</a></p>
</li>
<li><p><a href="https://www.jianshu.com/p/e97f6555a070">m3u8 文件格式详解</a></p>
</li>
<li><p>HTTP live Streaming (HLS)</p>
</li>
<li><p>chrome 桌面版是不支持 m3u8格式视频的直接播放</p>
</li>
<li><p>可以通过 hls.js来支持m3u8源的播放,其他播放器也可以</p>
</li>
<li><p>videojs要支持hls类型视频的播放需要安装 videojs-contrib-hls</p>
</li>
<li><p><a href="https://www.vdocipher.com/blog/2020/09/online-video-player-html5-website/">Top 17 Online Video Players For 2021</a></p>
</li>
<li><p>西瓜视频播放器值得推荐</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>chrome</tag>
        <tag>m38u</tag>
      </tags>
  </entry>
  <entry>
    <title>几个chrome插件</title>
    <url>/2021/09/25/chrome/%E5%87%A0%E4%B8%AAchrome%E6%8F%92%E4%BB%B6/</url>
    <content><![CDATA[<p>yet-another-rest-client 用于restful接口测试  </p>
<p>xswitch 用于拦截浏览器发送出去的请求(跨域的也能处理),可以把生产环境的请求拦截到本地用于调试,非常好用</p>
<p>json-handle 美化JSON显示</p>
]]></content>
      <tags>
        <tag>chrome</tag>
      </tags>
  </entry>
  <entry>
    <title>2021-4-19- windows系统rust wasm环境准备</title>
    <url>/2021/04/19/rust/2021-4-19-%20windows%E7%B3%BB%E7%BB%9Frust%20wasm%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/</url>
    <content><![CDATA[<h1 id="rust开发环境搭建"><a href="#rust开发环境搭建" class="headerlink" title="rust开发环境搭建"></a>rust开发环境搭建</h1><p>rustup-init 下载地址 <a href="https://www.rust-lang.org/zh-CN/tools/install">https://www.rust-lang.org/zh-CN/tools/install</a></p>
<blockquote>
<p>rustup 用于管理rust的版本,类似于管理node版本的nvm</p>
</blockquote>
<p>C++ 编译工具链 下载地址 <a href="https://visualstudio.microsoft.com/zh-hans/visual-cpp-build-tools/">https://visualstudio.microsoft.com/zh-hans/visual-cpp-build-tools/</a></p>
<blockquote>
<p>rust 最终还是会编译成C++ 代码的,只勾选C++工具链即可。安装需要存储空间挺大的,不要装C盘<br>windows上我们选择 msvc(微软visual-cpp)工具链 </p>
</blockquote>
<h2 id="rustup-init-安装rust"><a href="#rustup-init-安装rust" class="headerlink" title="rustup-init 安装rust"></a>rustup-init 安装rust</h2><blockquote>
<p>这里可以使用 清华的rustup-mirror加速安装 <code>RUSTUP_DIST_SERVER=https://mirrors.tuna.tsinghua.edu.cn/rustup</code><br><img src="https://upload-images.jianshu.io/upload_images/8156292-0c7fe3e0af73fd14.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="环境变量设置.png"></p>
</blockquote>
<p>rustup-init是个命令行工具，按照默认的安装设置即可</p>
<p><img src="https://upload-images.jianshu.io/upload_images/8156292-429da5106348a60e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="rustup-init.png"></p>
<h2 id="配置cargo镜像"><a href="#配置cargo镜像" class="headerlink" title="配置cargo镜像"></a>配置cargo镜像</h2><p>参考这个文章 <a href="https://cargo.budshome.com/reference/source-replacement.html">https://cargo.budshome.com/reference/source-replacement.html</a><br>可以配置 <code>CARGO_HOME</code> 环境变量修改cargo的目录,因为默认在   <code>C:\Users\&#123;username&#125;\.cargo</code>，而且后面安装东西也在这么目录，最好还是设置下吧</p>
<blockquote>
<p>默认是从国外下载，时间就是生命</p>
</blockquote>
<h2 id="确认安装是否成功"><a href="#确认安装是否成功" class="headerlink" title="确认安装是否成功"></a>确认安装是否成功</h2><p><code>rustup --version</code> 能看到正确的版本号 <code>rustc</code>不报错就可以了</p>
<h2 id="安装cargo-edit"><a href="#安装cargo-edit" class="headerlink" title="安装cargo-edit"></a>安装cargo-edit</h2><blockquote>
<p>cargo install cargo-edit</p>
</blockquote>
<h2 id="安装wasm-pack"><a href="#安装wasm-pack" class="headerlink" title="安装wasm-pack"></a>安装wasm-pack</h2><blockquote>
<p>cargo install wasm-pack</p>
</blockquote>
]]></content>
      <tags>
        <tag>rust</tag>
      </tags>
  </entry>
  <entry>
    <title>wa-lang windows踩坑指南</title>
    <url>/2022/11/20/wa-lang/wa%20windows%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<h1 id="wa-lang-windows系统初体验"><a href="#wa-lang-windows系统初体验" class="headerlink" title="wa-lang windows系统初体验"></a>wa-lang windows系统初体验</h1><p><img src="images/2022-11-19-15-49-38.png"><br>按照官网的执行的install，嗯安装不上，应该是被墙了？<br>不过翻墙后仍然报错!!</p>
<p>于是从gitee上下载了源代码,执行了<code>go install .</code>，报错如下</p>
<p><img src="images/2022-11-19-15-51-50.png"></p>
<p>于是网上找了下国内的镜像仓库，安装成功，但是 <code>wa 不是内部或外部命令</code><br><img src="images/2022-11-19-15-53-20.png"></p>
<p>在项目目录下创建一个<code>wa.cmd</code>来执行下<code>go run main.go %*</code>,这样也能愉快的执行wa命令咯,效果如下<br><img src="images/2022-11-19-16-02-13.png"></p>
<p>后来检查了下 install 的时候会在 <code>$home/go/bin</code>目录(我的电脑是这个路径C:\Users\win7\go\bin)创建 <code>wa.exe</code>的</p>
<p>配置下这个目录的地址到path就行了,最根本的原因是安装前系统中的 <code>$GO_PATH</code>没有设置对。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>安装前检查go有没用正确安装</li>
<li>安装前设置好go的国内的镜像仓库</li>
<li>安装完如果出现<code>wa 不是内部或外部命令</code>,用<code>Everything</code>全盘检索<code>wa.exe</code>文件,把所在目录配置到环境变量中</li>
</ol>
]]></content>
      <tags>
        <tag>wa-lang</tag>
      </tags>
  </entry>
  <entry>
    <title>开发灵异事件之base64图片传输</title>
    <url>/2021/09/09/web%E5%BC%80%E5%8F%91/%E5%BC%80%E5%8F%91%E7%81%B5%E5%BC%82%E4%BA%8B%E4%BB%B6%E4%B9%8Bbase64%E5%9B%BE%E7%89%87%E4%BC%A0%E8%BE%93/</url>
    <content><![CDATA[<h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>发出去的请求一毛一样，都包含了同一张base64格式的图片，图片显示出来是一样的。对比内容不一样。但是请求时间差距3分钟，甚至超时。接口20M大小的图片也能秒级处理。 图片来源一个是前端上传转换的base64，一个是后端把pdf文件首页转换出来的。</p>
<h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>后端生成的图片base64包含大量的换行符，http协议中的换行符有特殊含义，会被网关服务器解析，导致请求超时。</p>
<h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><p>base64格式里面有大量的换行符，会严重影响传输效率</p>
]]></content>
  </entry>
  <entry>
    <title>开发灵异事件之base64图片传输</title>
    <url>/2023/03/28/web%E5%BC%80%E5%8F%91/%E5%BC%80%E5%8F%91%E7%81%B5%E5%BC%82%E4%BA%8B%E4%BB%B6%E4%B9%8Bfix%E5%AE%9A%E4%BD%8D%E5%A4%B1%E8%B4%A5/</url>
    <content><![CDATA[<h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>使用了 <code>position:fixed</code>定位发现弹框不能定位到页面相对位置</p>
<h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>fixed默认是相对于页面的根元素的,但是有一种情况例外,就是如果父有元素做了transfrom变换的时候。此时会相对于该元素定位</p>
<h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><p>fixed定位的元素建议作为body直接子元素使用</p>
]]></content>
  </entry>
  <entry>
    <title>开发灵异事件之图片下载</title>
    <url>/2021/09/09/web%E5%BC%80%E5%8F%91/%E5%BC%80%E5%8F%91%E7%81%B5%E5%BC%82%E4%BA%8B%E4%BB%B6%E4%B9%8B%E5%9B%BE%E7%89%87%E4%B8%8B%E8%BD%BD/</url>
    <content><![CDATA[<h3 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h3><p>使用download属性用a标签下载图片，变成了新页签打开预览</p>
<h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>下载的图片跨域，早期chrome没有这个限制</p>
<h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>后台接口转发可以解决</p>
<p>图片服务器增加允许跨域相关响应头</p>
<p>前端用image拿到图片资源，使用Blob对象下载</p>
]]></content>
  </entry>
  <entry>
    <title>开发灵异事件之显示模糊</title>
    <url>/2023/03/28/web%E5%BC%80%E5%8F%91/%E5%BC%80%E5%8F%91%E7%81%B5%E5%BC%82%E4%BA%8B%E4%BB%B6%E4%B9%8B%E6%98%BE%E7%A4%BA%E6%A8%A1%E7%B3%8A/</url>
    <content><![CDATA[<h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>弹框看起来很模糊</p>
<h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>弹框写了居中效果,但是用了的方式是 <code>transform:translate(-50%,-50%,);left:50%</code>,但是弹框的宽度 或者 高度使用的单位是奇数 例如 <code>501px</code> 就会模糊 因为电脑是没办法识别<code>0.5px</code>这种显示的</p>
<h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><p>居中的话建议用使用 上下左右0 的写法 , <code>margin auto</code> 或者<code>flex布局</code></p>
]]></content>
  </entry>
  <entry>
    <title>开发灵异事件之浏览器变卡</title>
    <url>/2021/09/09/web%E5%BC%80%E5%8F%91/%E5%BC%80%E5%8F%91%E7%81%B5%E5%BC%82%E4%BA%8B%E4%BB%B6%E4%B9%8B%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8F%98%E5%8D%A1/</url>
    <content><![CDATA[<h3 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h3><p>使用window.open 开一个页签后，回到原本的页面，动画啥的变卡了。开的页面越多越卡</p>
<p>当新开的页签崩溃，原有页面也会一起崩溃。</p>
<h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>window.open 新开的页面跟原有页面用的是同一个渲染器。另外 超链接  target=_blank也是一样的。</p>
<h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>使用超链接打开新页面，并使用<code>&lt;a href=&quot;&quot; rel=&quot;noopener&quot;&gt;&lt;/a&gt;</code>属性</p>
<p>也能使用 <code>window.open(URL,_blank,&#39;noopener&#39;)</code></p>
]]></content>
  </entry>
  <entry>
    <title>2021-4-26-async.js中文文档</title>
    <url>/2021/04/19/%E5%8C%85%E4%B8%8E%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5/2021-4-26-async.js%E4%B8%AD%E6%96%87%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[<p><img src="https://raw.githubusercontent.com/caolan/async/master/logo/async-logo_readme.jpg" alt="Async Logo"></p>
<p><em>For Async v1.5.x documentation, go <a href="https://github.com/caolan/async/blob/v1.5.2/README.md">HERE</a></em></p>
<p>Async 是一个功能强大的异步 JavaScript 模块。虽然最初是为了与 <a href="https://nodejs.org/">Node.js</a> 一起使用，可以通过 <code>npm i async</code>安装,<br>它也可以直接在浏览器中使用。</p>
<p>Async 也能通过 yarn 安装:</p>
<ul>
<li><a href="https://yarnpkg.com/en/">yarn</a>: <code>yarn add async</code></li>
</ul>
<p>Async提供了大约70个函数。其中包括集合 (<code>map</code>, <code>reduce</code>, <code>filter</code>, <code>each</code>…) 的异步扩展。以及常见的异步控制流模式 (<code>parallel</code>, <code>series</code>, <code>waterfall</code>…). 这些函数假定您遵循Node.js约定 (提供一个callback作为异步函数的最后一个参数– 一个期望错误作为其第一个参数的回调—并调用回调一次)。</p>
<p>你也可以用 <code>async</code> 函数代替 callback-accepting 函数提供给 Async 方法.  更多信息,请参考 <a href="global.html#AsyncFunction">AsyncFunction</a></p>
<h2 id="Quick-Examples"><a href="#Quick-Examples" class="headerlink" title="Quick Examples"></a>Quick Examples</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span>.map([<span class="string">&#x27;file1&#x27;</span>,<span class="string">&#x27;file2&#x27;</span>,<span class="string">&#x27;file3&#x27;</span>], fs.stat, <span class="function"><span class="keyword">function</span>(<span class="params">err, results</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// results is now an array of stats for each file</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span>.filter([<span class="string">&#x27;file1&#x27;</span>,<span class="string">&#x27;file2&#x27;</span>,<span class="string">&#x27;file3&#x27;</span>], <span class="function"><span class="keyword">function</span>(<span class="params">filePath, callback</span>) </span>&#123;</span><br><span class="line">  fs.access(filePath, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    callback(<span class="literal">null</span>, !err)</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err, results</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// results now equals an array of the existing files</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span>.parallel([</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123; ... &#125;,</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123; ... &#125;</span><br><span class="line">], <span class="function"><span class="keyword">function</span>(<span class="params">err, results</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// optional callback</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span>.series([</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123; ... &#125;,</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123; ... &#125;</span><br><span class="line">]);</span><br></pre></td></tr></table></figure>

<p>还有更多的功能哦,请查看后面完整功能列表。如果您觉得还缺了点什么，请创建一个GitHub issue 给我们。</p>
<h2 id="常见问题-StackOverflow"><a href="#常见问题-StackOverflow" class="headerlink" title="常见问题 (StackOverflow)"></a>常见问题 <a href="http://stackoverflow.com/questions/tagged/async.js">(StackOverflow)</a></h2><h3 id="同步迭代函数-Synchronous-iteration-functions"><a href="#同步迭代函数-Synchronous-iteration-functions" class="headerlink" title="同步迭代函数 (Synchronous iteration functions)"></a>同步迭代函数 (Synchronous iteration functions)</h3><p>在使用async的时候,如果你遇到类似 <code>RangeError: Maximum call stack size exceeded.</code>的报错或者其他栈溢出问题 , 你可能使用了同步迭代。使用“同步”，意味着一个方法与它的callback在同一个事件循环(javascript event loop)中执行，使用 I/O 或者 定时器 除外。调用太多的callback会使栈溢出。如果你遇到这个问题，只需要通过<code>async.setImmediate</code>方法启动一个新的调用栈在下一次事件循环中运行。</p>
<p>如果在某些情况下提早回调，这也偶然会产生：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span>.eachSeries(hugeArray, <span class="function"><span class="keyword">function</span> <span class="title">iteratee</span>(<span class="params">item, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (inCache(item)) &#123;</span><br><span class="line">        callback(<span class="literal">null</span>, cache[item]); <span class="comment">// 如果太多的项目被缓存，也会栈溢出</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        doSomeIO(item, callback);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span> <span class="title">done</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>该成这样:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span>.eachSeries(hugeArray, <span class="function"><span class="keyword">function</span> <span class="title">iteratee</span>(<span class="params">item, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (inCache(item)) &#123;</span><br><span class="line">        <span class="keyword">async</span>.setImmediate(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            callback(<span class="literal">null</span>, cache[item]);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        doSomeIO(item, callback);</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>出于性能考虑，Async没有做同步迭代器校验。如果仍然遇到堆栈溢出,可以按照上面的方法进行延迟。或者使用<a href="#ensureAsync"><code>async.ensureAsync</code></a>方法包装函数，这些函数本质上是异步的，因此不存在此问题，也不需要额外的回调延迟。</p>
<p>如果JavaScript的事件循环仍然有点模糊，请查看<a href="http://blog.carbonfive.com/2013/10/27/the-javascript-event-loop-explained/">this article</a> or <a href="http://2014.jsconf.eu/speakers/philip-roberts-what-the-heck-is-the-event-loop-anyway.html">this talk</a> 获取更多详细信息。</p>
<h3 id="多次调用回调函数-Multiple-callbacks"><a href="#多次调用回调函数-Multiple-callbacks" class="headerlink" title="多次调用回调函数( Multiple callbacks)"></a>多次调用回调函数( Multiple callbacks)</h3><p>确保在调用callback后<code>return</code>这个函数,否则在许多情况下会导致多次回调和不可预知的行为。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span>.waterfall([</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">        getSomething(options, <span class="function"><span class="keyword">function</span> (<span class="params">err, result</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                callback(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;failed getting something:&quot;</span> + err.message));</span><br><span class="line">                <span class="comment">// we should return here</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// since we did not return, this callback still will be called and</span></span><br><span class="line">            <span class="comment">// `processData` will be called twice</span></span><br><span class="line">            callback(<span class="literal">null</span>, result);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    processData</span><br><span class="line">], done)</span><br></pre></td></tr></table></figure>


<p>每当回调调用不是函数的最后一个语句时，最好使用 <code>return callback(err, result)</code>。</p>
<h3 id="Using-ES2017-async-functions"><a href="#Using-ES2017-async-functions" class="headerlink" title="Using ES2017 async functions"></a>Using ES2017 <code>async</code> functions</h3><p>Async 可以用 <code>async</code> functions 代替 Node-风格 回调函数。没有callback形参,通过<code>return</code> 替代<code>callback(null,result)</code>。通过抛异常<code>throw new Error()</code>代替 <code>callback(err)</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span>.mapLimit(files, <span class="number">10</span>, <span class="keyword">async</span> file =&gt; &#123; <span class="comment">// &lt;- no callback!</span></span><br><span class="line">    <span class="keyword">const</span> text = <span class="keyword">await</span> util.promisify(fs.readFile)(dir + file, <span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line">    <span class="keyword">const</span> body = <span class="built_in">JSON</span>.parse(text) <span class="comment">// &lt;- a parse error here will be caught automatically</span></span><br><span class="line">    <span class="keyword">if</span> (!(<span class="keyword">await</span> checkValidity(body))) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`<span class="subst">$&#123;file&#125;</span> has invalid contents`</span>) <span class="comment">// &lt;- this error will also be caught</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> body <span class="comment">// &lt;- return a value!</span></span><br><span class="line">&#125;, <span class="function">(<span class="params">err, contents</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">throw</span> err</span><br><span class="line">    <span class="built_in">console</span>.log(contents)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>我们只能识别到原生<code>async</code> functions，不包括被转移的版本(e.g. with Babel)。另外您可以通过<code>async.asyncify()</code>把<code>async</code> functions 包装成 node-style callback</p>
<h3 id="绑定上下文-Binding-a-context-to-an-iteratee"><a href="#绑定上下文-Binding-a-context-to-an-iteratee" class="headerlink" title="绑定上下文 Binding a context to an iteratee"></a>绑定上下文 Binding a context to an iteratee</h3><p>传递给Async的异步函数,this的上下文指向会被改变,需要通过<code>bind</code>方法指定上下文</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Here is a simple object with an (unnecessarily roundabout) squaring method</span></span><br><span class="line"><span class="keyword">var</span> AsyncSquaringLibrary = &#123;</span><br><span class="line">    squareExponent: <span class="number">2</span>,</span><br><span class="line">    square: <span class="function"><span class="keyword">function</span>(<span class="params">number, callback</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> result = <span class="built_in">Math</span>.pow(number, <span class="built_in">this</span>.squareExponent);</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            callback(<span class="literal">null</span>, result);</span><br><span class="line">        &#125;, <span class="number">200</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span>.map([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], AsyncSquaringLibrary.square, <span class="function"><span class="keyword">function</span>(<span class="params">err, result</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// result is [NaN, NaN, NaN]</span></span><br><span class="line">    <span class="comment">// This fails because the `this.squareExponent` expression in the square</span></span><br><span class="line">    <span class="comment">// function is not evaluated in the context of AsyncSquaringLibrary, and is</span></span><br><span class="line">    <span class="comment">// therefore undefined.</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span>.map([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], AsyncSquaringLibrary.square.bind(AsyncSquaringLibrary), <span class="function"><span class="keyword">function</span>(<span class="params">err, result</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// result is [1, 4, 9]</span></span><br><span class="line">    <span class="comment">// With the help of bind we can attach a context to the iteratee before</span></span><br><span class="line">    <span class="comment">// passing it to Async. Now the square function will be executed in its</span></span><br><span class="line">    <span class="comment">// &#x27;home&#x27; AsyncSquaringLibrary context and the value of `this.squareExponent`</span></span><br><span class="line">    <span class="comment">// will be as expected.</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="内存泄漏-Subtle-Memory-Leaks"><a href="#内存泄漏-Subtle-Memory-Leaks" class="headerlink" title="内存泄漏 Subtle Memory Leaks"></a>内存泄漏 Subtle Memory Leaks</h3><p>在某些情况下，当您在另一个异步函数中调用Async方法时，您可能想尽早退出异步流：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span> (<span class="params">args, outerCallback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">async</span>.waterfall([</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> (<span class="params">arg, next</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (someImportantCondition()) &#123;</span><br><span class="line">                <span class="keyword">return</span> outerCallback(<span class="literal">null</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="keyword">function</span> (<span class="params">arg, next</span>) </span>&#123;<span class="comment">/*...*/</span>&#125;</span><br><span class="line">    ], <span class="function"><span class="keyword">function</span> <span class="title">done</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有时候你想跳过瀑布流的剩余过程,你调用了外部的回调函数,但是Async还是会等待内部的<code>next</code>函数被调用,从而造成函数没有正确结束。</p>
<p>从 3.0版本, 你可以调用任何 <code>false</code> 作为 <code>error</code> 参数的Async 回调,让Async结束方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params">arg, next</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (someImportantCondition()) &#123;</span><br><span class="line">        outerCallback(<span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> next(<span class="literal">false</span>) <span class="comment">// ← signal that you called an outer callback</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h3 id="处理集合时对集合进行改变-Mutating-collections-while-processing-them"><a href="#处理集合时对集合进行改变-Mutating-collections-while-processing-them" class="headerlink" title="处理集合时对集合进行改变 Mutating collections while processing them"></a>处理集合时对集合进行改变 Mutating collections while processing them</h3><p>如果你通过一个数组去调用Async的集合方法(例如 <code>each</code>, <code>mapLimit</code>, or <code>filterSeries</code>),<br>然后数组被<code>push</code>, <code>pop</code>, or <code>splice</code> 这些方法修改,这可能会导致意外,或者不确定的行为。Async会迭代到满足数组的原始 <code>length</code>次数。一些 <code>push</code>, <code>pop</code>, or <code>splice</code> 的索引已经被处理。因此，不建议在异步开始对其进行迭代之后修改该数组。 如果确实需要<code>push</code>, <code>pop</code>, or <code>splice</code>，请改用 <code>queue</code>。</p>
<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>从<br><a href="https://raw.githubusercontent.com/caolan/async/master/dist/async.min.js">GitHub</a>下载源码.<br>也可以通过npm安装:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm i async</span><br></pre></td></tr></table></figure>

<p>然后 <code>require()</code>引入整个模块:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="keyword">async</span> = <span class="built_in">require</span>(<span class="string">&quot;async&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>或缺部分引入某个方法:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> waterfall = <span class="built_in">require</span>(<span class="string">&quot;async/waterfall&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> map = <span class="built_in">require</span>(<span class="string">&quot;async/map&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>开发版:</strong> <a href="https://raw.githubusercontent.com/caolan/async/master/dist/async.js">async.js</a> - 29.6kb 未压缩</p>
<h3 id="在浏览器-In-the-Browser"><a href="#在浏览器-In-the-Browser" class="headerlink" title="在浏览器 In the Browser"></a>在浏览器 In the Browser</h3><p>Async 可以运行在任何 ES2015 环境 (Node 6+ and all modern browsers).</p>
<p>如果你想在更老的环境中使用Async, (e.g. Node 4, IE11) 你需要做如下转换.</p>
<p>Usage:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;async.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="keyword">async</span>.map(data, asyncProcess, <span class="function"><span class="keyword">function</span>(<span class="params">err, results</span>) </span>&#123;</span></span><br><span class="line">        alert(results);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>


<p>Async 的可移植版本, 包含 <code>async.js</code> and <code>async.min.js</code>, 在 <code>/dist</code> 文件夹下. Async 支持 <a href="http://www.jsdelivr.com/projects/async">jsDelivr CDN</a>.</p>
<h3 id="ES-Modules-支持"><a href="#ES-Modules-支持" class="headerlink" title="ES Modules 支持"></a>ES Modules 支持</h3><p>Async包含一个 <code>.mjs</code>版本，该版本应由兼容的打包工具自动使用，例如Webpack或Rollup等任何使用 <code>package.json</code>的<code>module</code>字段的东西。</p>
<p>我们还在npm上的另一个<code>async-es</code>包中提供Async作为纯ES2015模块的集合。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install async-es</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> waterfall <span class="keyword">from</span> <span class="string">&#x27;async-es/waterfall&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">async</span> <span class="keyword">from</span> <span class="string">&#x27;async-es&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="Typescript-支持"><a href="#Typescript-支持" class="headerlink" title="Typescript 支持"></a>Typescript 支持</h3><p>Async 的第三方类型定义。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i -D @types&#x2F;async</span><br></pre></td></tr></table></figure>
<p>建议在您的<code>tsconfig.json</code>中编译选项中配置ES2017或更高版本，这样会保留<code>async</code>函数：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;target&quot;</span>: <span class="string">&quot;es2017&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="其他仓库-友情链接"><a href="#其他仓库-友情链接" class="headerlink" title="其他仓库(友情链接)"></a>其他仓库(友情链接)</h2><ul>
<li><a href="https://www.npmjs.com/package/limiter"><code>limiter</code></a> a package for rate-limiting based on requests per sec/hour.</li>
<li><a href="https://www.npmjs.com/package/neo-async"><code>neo-async</code></a> an altername implementation of Async, focusing on speed.</li>
<li><a href="https://www.npmjs.com/package/co-async"><code>co-async</code></a> a library inspired by Async for use with <a href="https://www.npmjs.com/package/co"><code>co</code></a> and generator functions.</li>
<li> <a href="https://www.npmjs.com/package/promise-async"><code>promise-async</code></a> a version of Async where all the methods are Promisified.</li>
</ul>
<h2 id="docjs-文档"><a href="#docjs-文档" class="headerlink" title="docjs 文档"></a>docjs 文档</h2><p>不是很好翻译,直接看官方英文的<br> <a href="https://caolan.github.io/async/">https://caolan.github.io/async/</a></p>
<hr>
<hr>
<p>———华丽的分割线, 后面是我的理解——————</p>
<hr>
<hr>
<h2 id="Async-主要包含三个部分的函数"><a href="#Async-主要包含三个部分的函数" class="headerlink" title="Async 主要包含三个部分的函数"></a>Async 主要包含三个部分的函数</h2><h3 id="1-对集合的异步拓展-Array-prototype上方法的补充-原生是不支持异步的"><a href="#1-对集合的异步拓展-Array-prototype上方法的补充-原生是不支持异步的" class="headerlink" title="1. 对集合的异步拓展,Array.prototype上方法的补充,原生是不支持异步的"></a>1. 对集合的异步拓展,Array.prototype上方法的补充,原生是不支持异步的</h3><ul>
<li>concat</li>
<li>detect find</li>
<li>each forEach  –不带index</li>
<li>eachOf forEachOf –带index</li>
<li>every</li>
<li>filter</li>
<li>groupBy</li>
<li>map</li>
<li>mapValues</li>
<li>reduce reduceRight transform –都是做累加的</li>
<li>reject –filter的补集</li>
<li>some</li>
<li>sortBy</li>
<li>以上方法又有Limit变体版本</li>
<li>Limit是限制并发数量的</li>
<li>Series又是Limit并发数为1的变体版本</li>
</ul>
<h3 id="2-异步工作流"><a href="#2-异步工作流" class="headerlink" title="2. 异步工作流"></a>2. 异步工作流</h3><ul>
<li><p>工作流</p>
<ul>
<li>queue 队列,执行器只能拿到当前执行的任务</li>
<li>priorityQueue 跟queue相同,但是任务带执行优先级</li>
<li>cargo 队列,执行器中拿到队列中的所有任务信息</li>
<li>waterfall 瀑布,从上往下执行,最后的回调拿到瀑布中最后一个函数的执行结果</li>
<li>series 一个一个运行,最后的回调拿到所有函数的执行结果</li>
<li>auto 自动运行,根据异步函数的依赖关系自动执行</li>
<li>times 执行同一个函数多次</li>
<li>retry 执行失败会重试,直到成功(默认重试5次,重试间隔0秒)</li>
<li>forever 一直执行这个函数,除非报错</li>
</ul>
</li>
<li><p>Promise对应的Async实现</p>
<ul>
<li>parallel 一起执行,任何一个报错就退出,等同于Promise.all [拿到全部正确的结果]</li>
<li>Promise.allSettled [拿到全部结果,不论对错],这个Async没有对应的实现,reflect和reflectAll可以阻止错误终端工作流<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span>.allSettled=<span class="keyword">async</span>.parallel(<span class="keyword">async</span>.reflectAll(tasks))</span><br></pre></td></tr></table></figure></li>
<li>tryEach 任何一个异步函数成功就会退出工作流,等同于Promise.any [拿到第一个正确的结果]</li>
<li>race 任何一个异步函数成功或者失败就是退出工作流,等同于Promise.race[拿到第一个执行完成的结果,不论对错]</li>
</ul>
</li>
<li><p>循环工作流</p>
<ul>
<li>whilst while(condition){statement}  条件满足继续循环</li>
<li>doWhilst do{statement}while(condition) 至少会执行一次</li>
<li></li>
<li>until  loop{}until(condition)  条件满足退出循环</li>
<li>doUntil do{}until(condition) 至少会执行一次</li>
</ul>
</li>
</ul>
<ul>
<li>辅助函数<ul>
<li>compose 打散管道方法 例如 <code>a(b(c()))</code> compose(a,b,c)</li>
<li>seq compose的可读版本 seq(a,b,c) 对应的是 <code>c(b(a()))</code></li>
<li>applyEach 多个异步方法的参数相同,并发版</li>
<li>applyEachSeries 多个异步方法的参数相同,排队版</li>
</ul>
</li>
</ul>
<h3 id="3-辅助函数"><a href="#3-辅助函数" class="headerlink" title="3. 辅助函数"></a>3. 辅助函数</h3><ul>
<li>apply 多参数转换成只有一个callback参数的函数</li>
<li>asyncify,wrapSync 包装 ES2017 async function 成 Node-style风格AsyncFunction</li>
<li>constant 包装常量成 AsyncFunction</li>
<li>dir,log 方便调试输出异步函数的执行结果</li>
<li>ensureAsync 确保函数是异步执行,防止同步调用迭代栈溢出</li>
<li>memoize unmemoize 慢函数增加缓存,清除缓存</li>
<li>nextTick 将函数放入下一次事假循环执行</li>
<li>reflect reflectAll 返回一个新的函数,及时callback(error)也不会导致工作流结束</li>
<li>setImmediate 跟nextTick差不多</li>
<li>timeout 给异步函数增加超时</li>
</ul>
]]></content>
      <tags>
        <tag>js-lib</tag>
      </tags>
  </entry>
  <entry>
    <title>JSON Stream 用于JSON数据的解析</title>
    <url>/2021/09/25/%E5%8C%85%E4%B8%8E%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5/JSON-Stream-%E7%94%A8%E4%BA%8EJSON%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p>JSON Stream使用流的方式去解析JSON文件,即使是非常大的文件也不会造成内存卡顿</p>
<p><a href="https://www.npmjs.com/package/JSONStream">https://www.npmjs.com/package/JSONStream</a></p>
]]></content>
      <tags>
        <tag>json npm</tag>
      </tags>
  </entry>
  <entry>
    <title>rxjs</title>
    <url>/2021/04/19/%E5%8C%85%E4%B8%8E%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5/2021-4-29-%20rxjs/</url>
    <content><![CDATA[<h1 id="rxjs"><a href="#rxjs" class="headerlink" title="rxjs"></a>rxjs</h1><p>rxjs是一个响应式编程的js实现,angular工程里面经常会用到</p>
<h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><p>主要是实现了设计模式中的<code>观察者模式</code>。<br>观察者模式主要实现对象间一对多的行为模式。</p>
<ul>
<li>可观察对象 Observable</li>
<li>观察者 Observer</li>
</ul>
<p>完整的Observer观察者需要需要3个处理器</p>
<ul>
<li>消息处理器Next (必选的)</li>
<li>错误处理器Error</li>
<li>观察结束处理器 complete<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> observer = &#123;</span><br><span class="line">  next: <span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;Observer got a next value: &#x27;</span> + x),</span><br><span class="line">  error: <span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.error(<span class="string">&#x27;Observer got an error: &#x27;</span> + err),</span><br><span class="line">  complete: <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;Observer got a complete notification&#x27;</span>),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
可观察对象Observable能够向观察者发射这三种类型的消息给观察者<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里我简单的模拟下Observable对象的结构</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observable</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.fn=fn</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">subscribe</span>(<span class="params">observer</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.fn(observer)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> observable=<span class="keyword">new</span> Observable(<span class="function"><span class="params">subscriber</span> =&gt;</span> &#123;</span><br><span class="line">  subscriber.next(<span class="number">1</span>);</span><br><span class="line">  <span class="comment">//加了这句后面就不执行了,直接走错误处理器</span></span><br><span class="line">  <span class="comment">// throw &#x27;报错了&#x27; </span></span><br><span class="line">  subscriber.next(<span class="number">2</span>);</span><br><span class="line">  subscriber.next(<span class="number">3</span>);</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    subscriber.next(<span class="number">4</span>);</span><br><span class="line">    subscriber.complete();</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
加上<code>observable.subscribe(observer)</code>这句代码,就可以让观察者执行被观察对象发出的消息了。</li>
</ul>
<h2 id="实现观察者模式"><a href="#实现观察者模式" class="headerlink" title="实现观察者模式"></a>实现观察者模式</h2><p>上面的实现，是一对一的观察（单播）。观察者模式是一对多（多播），跟事件增加处理器一样的道理。rxjs增加了一个中间人<code>Subject</code>做分发。</p>
<p>就像有个山洞，只能进去一个人，但是有一堆人想知道里面的消息。那么派一个人观察，然后告诉大家里面发生了什么就可以了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 模拟一个 Subject 类做消息分发</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Subject</span></span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.observerList=[]</span><br><span class="line">  <span class="function"><span class="title">subscribe</span>(<span class="params">observer</span>)</span>&#123;</span><br><span class="line">    observerList.push(observer)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">unsubscribe</span>(<span class="params">observer</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> index=<span class="built_in">this</span>.observerList.findIndex(observer)</span><br><span class="line">    <span class="built_in">this</span>.observerList=[]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">complete</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.observerList.forEach(<span class="function"><span class="params">observer</span> =&gt;</span> &#123;</span><br><span class="line">      observer.complete()</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">error</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.observerList.forEach(<span class="function"><span class="params">observer</span> =&gt;</span> &#123;</span><br><span class="line">      observer.error(err)</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">next</span>(<span class="params">arg</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.observerList.forEach(<span class="function"><span class="params">observer</span> =&gt;</span> &#123;</span><br><span class="line">      observer.next(arg)</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> subject=<span class="keyword">new</span> Subject() <span class="comment">//找个中间人</span></span><br><span class="line"><span class="keyword">let</span> observer1=<span class="function">()=&gt;</span>&#123;<span class="built_in">console</span>.log(<span class="string">&#x27;观察者1&#x27;</span>)&#125;</span><br><span class="line"><span class="keyword">let</span> observer2=<span class="function">()=&gt;</span>&#123;<span class="built_in">console</span>.log(<span class="string">&#x27;观察者2&#x27;</span>)&#125;</span><br><span class="line">subject.subscribe(observer1)<span class="comment">//观察者1订阅中间人的消息</span></span><br><span class="line">subject.subscribe(observer2)<span class="comment">//观察者2订阅中间人的消息</span></span><br><span class="line">observable.subscribe(subject) <span class="comment">// 中间人订阅可观察对象</span></span><br></pre></td></tr></table></figure>
<h2 id="取消订阅"><a href="#取消订阅" class="headerlink" title="取消订阅"></a>取消订阅</h2><p>订阅会产生订阅信息<code>subscription</code>,订阅信息可以做从属关系,主订阅信息取消,从订阅信息也会被取消</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> subscription1=subject.subscribe(observer1)</span><br><span class="line"><span class="keyword">let</span> subscription2=subject.subscribe(observer2)</span><br><span class="line">subscription1.add(subscription2)<span class="comment">//建立从属关系</span></span><br><span class="line">subscription1.unsubscribe()<span class="comment">//这时候subscription2也跟着一起取消了</span></span><br></pre></td></tr></table></figure>

<h2 id="中间人还有几个变体"><a href="#中间人还有几个变体" class="headerlink" title="中间人还有几个变体"></a>中间人还有几个变体</h2><ul>
<li>BehaviorSubject 这个中间人会把你订阅时候前一次消息告知观察者(比如我打开电视去看足球赛,旁边一个老铁跟我说了句,现在中国队0:7落后。我拿到这个消息，可能会立马砸掉电视，而不会继续观看。)</li>
<li>ReplaySubject 这个中间人有一个缓冲区,和一个缓冲时间。他会把观察者订阅之前出于缓冲区内且在缓冲时间内的消息，告知观察者。</li>
<li>AsyncSubject 这个中间人只会等待complete后通知最后的结果（比如观测者不关心过程，只关心结果的情况）</li>
</ul>
<h2 id="分离订阅时间点"><a href="#分离订阅时间点" class="headerlink" title="分离订阅时间点"></a>分离订阅时间点</h2><p>目前观察者跟可观察对象，是在建立联系的那一刻。可观察对象就产生消息。我们需要控制联系的时间。比如一个在线视频，我需要等前面的广告播放完再看。<br>rxjs是怎么做的呢?  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; interval, Subject &#125; <span class="keyword">from</span> <span class="string">&#x27;rxjs&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; multicast &#125; <span class="keyword">from</span> <span class="string">&#x27;rxjs/operators&#x27;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> source = interval(<span class="number">500</span>);</span><br><span class="line"><span class="keyword">const</span> subject = <span class="keyword">new</span> Subject();</span><br><span class="line"><span class="keyword">const</span> multicasted = source.pipe(multicast(subject));</span><br><span class="line"><span class="keyword">let</span> subscription1, subscription2, subscriptionConnect;</span><br><span class="line"> </span><br><span class="line">subscription1 = multicasted.subscribe(&#123;</span><br><span class="line">  next: <span class="function">(<span class="params">v</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">`observerA: <span class="subst">$&#123;v&#125;</span>`</span>)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// We should call `connect()` here, because the first</span></span><br><span class="line"><span class="comment">// subscriber to `multicasted` is interested in consuming values</span></span><br><span class="line">subscriptionConnect = multicasted.connect();</span><br><span class="line"> </span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  subscription2 = multicasted.subscribe(&#123;</span><br><span class="line">    next: <span class="function">(<span class="params">v</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">`observerB: <span class="subst">$&#123;v&#125;</span>`</span>)</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;, <span class="number">600</span>);</span><br><span class="line"> </span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  subscription1.unsubscribe();</span><br><span class="line">&#125;, <span class="number">1200</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// We should unsubscribe the shared Observable execution here,</span></span><br><span class="line"><span class="comment">// because `multicasted` would have no more subscribers after this</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  subscription2.unsubscribe();</span><br><span class="line">  subscriptionConnect.unsubscribe(); <span class="comment">// for the shared Observable execution</span></span><br><span class="line">&#125;, <span class="number">2000</span>);</span><br></pre></td></tr></table></figure>

<h2 id="运算符-Operators"><a href="#运算符-Operators" class="headerlink" title="运算符 Operators"></a>运算符 Operators</h2><p>我们在上述例子中使用了不少rxjs的<code>运算符</code>。运算符包含两种：  </p>
<ul>
<li>一种是<code>创建运算符</code>，这种运算符的返回值都是一个<code>可观察对象</code>。它能从集合，定时任务，DOM事件创建可观察对象。</li>
<li>另一种是<code>管道运算符</code>,这种运算符用于对<code>可观测对象</code>发出的消息进行处理,比如做消息内容的整合,消息时间的调整。</li>
</ul>
<h2 id="调度器-Scheduler"><a href="#调度器-Scheduler" class="headerlink" title="调度器 Scheduler"></a>调度器 Scheduler</h2><h3 id="调度器分类"><a href="#调度器分类" class="headerlink" title="调度器分类"></a>调度器分类</h3><ul>
<li>null 同步传递消息</li>
<li>queueScheduler 队列调度器,事件宏任务</li>
<li>asapScheduler     微任务调度器,在两次宏任务之间执行,用于promise</li>
<li>asyncScheduler 异步调度器,用于定时器</li>
<li>animationFrameScheduler 动画调度器</li>
</ul>
<h3 id="调度器用处"><a href="#调度器用处" class="headerlink" title="调度器用处"></a>调度器用处</h3><ul>
<li>作为静态操作符的参数</li>
<li><code>subscribeOn(scheduler)</code> 在调用<code>subscribe()</code>函数的时候,作为执行的上下文</li>
<li><code>observeOn(scheduler)</code> 当可观察对象执行<code>next()</code>函数的时候,作为执行上下文<h3 id="来个例子"><a href="#来个例子" class="headerlink" title="来个例子"></a>来个例子</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//调度器枚举值,实际上是调度器对象,还能配置,这里简化处理</span></span><br><span class="line"><span class="keyword">const</span> schedulerType=&#123;</span><br><span class="line">  asyncScheduler:<span class="string">&#x27;asyncScheduler&#x27;</span>,</span><br><span class="line">  queueScheduler:<span class="string">&#x27;queueScheduler&#x27;</span>,</span><br><span class="line">  asapScheduler:<span class="string">&#x27;asapScheduler&#x27;</span>,</span><br><span class="line">  animationFrameScheduler:<span class="string">&#x27;animationFrameScheduler&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟个from运算符</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">from</span>(<span class="params">array, scheduler</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> observe;</span><br><span class="line">  <span class="keyword">let</span> observe=<span class="function"><span class="params">subscriber</span> =&gt;</span> &#123;</span><br><span class="line">    array.forEach(<span class="function"><span class="params">element</span> =&gt;</span> &#123;</span><br><span class="line">      subscriber.next(element)</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(scheduler==schedulerType.asyncScheduler)&#123;</span><br><span class="line">    observe=<span class="function"><span class="params">subscriber</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        array.forEach(<span class="function"><span class="params">element</span> =&gt;</span> &#123;</span><br><span class="line">          subscriber.next(element)</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Observable(observe);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;start&#x27;</span>)</span><br><span class="line"><span class="keyword">from</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]).subscribe(<span class="function"><span class="params">x</span>=&gt;</span><span class="built_in">console</span>.log(x))</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;end&#x27;</span>)</span><br><span class="line"><span class="comment">//logs打印如下</span></span><br><span class="line"><span class="comment">//start </span></span><br><span class="line"><span class="comment">//1 </span></span><br><span class="line"><span class="comment">//2 </span></span><br><span class="line"><span class="comment">//3 </span></span><br><span class="line"><span class="comment">//end </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;start&#x27;</span>)</span><br><span class="line"><span class="keyword">from</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],schedulerType.asyncScheduler).subscribe(<span class="function"><span class="params">x</span>=&gt;</span><span class="built_in">console</span>.log(x))</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;end&#x27;</span>)</span><br><span class="line"><span class="comment">//logs打印如下</span></span><br><span class="line"><span class="comment">//start </span></span><br><span class="line"><span class="comment">//end </span></span><br><span class="line"><span class="comment">//1 </span></span><br><span class="line"><span class="comment">//2 </span></span><br><span class="line"><span class="comment">//3 </span></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <tags>
        <tag>js-lib</tag>
      </tags>
  </entry>
  <entry>
    <title>UI框架之uikit</title>
    <url>/2021/09/13/%E5%8C%85%E4%B8%8E%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5/UI%E6%A1%86%E6%9E%B6%E4%B9%8Buikit/</url>
    <content><![CDATA[<h1 id="官网"><a href="#官网" class="headerlink" title="官网"></a>官网</h1><p><a href="https://getuikit.com/">官网</a></p>
<h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><ul>
<li>轻量</li>
<li>扁平</li>
<li>框架无关</li>
<li>组件特别齐全</li>
<li>Pro 付费版 支持生成器</li>
</ul>
]]></content>
      <tags>
        <tag>UI Framework</tag>
      </tags>
  </entry>
  <entry>
    <title>bpmn 业务流程建模与标注</title>
    <url>/2021/09/25/%E5%8C%85%E4%B8%8E%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5/bpmn-io/</url>
    <content><![CDATA[<p><a href="https://bpmn.io/">https://bpmn.io</a> 用于绘制流程图的js库</p>
<blockquote>
<p>BPMN Business Process Modeling Notation 业务流程建模与标注</p>
</blockquote>
<p>中文文档 <a href="https://github.com/LinDaiDai/bpmn-chinese-document">https://github.com/LinDaiDai/bpmn-chinese-document</a></p>
<p><em>另外还有个mermaid Markdown的流程图绘制库</em></p>
]]></content>
      <tags>
        <tag>流程图</tag>
      </tags>
  </entry>
  <entry>
    <title>js实现全排列,全组合</title>
    <url>/2021/09/26/%E5%8C%85%E4%B8%8E%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5/js%E5%AE%9E%E7%8E%B0%E5%85%A8%E6%8E%92%E5%88%97-%E5%85%A8%E7%BB%84%E5%90%88/</url>
    <content><![CDATA[<p>最近刷OJ算法题库的时候,发现很多都是数学问题都使用的穷举法，于是写了获取穷举的全排列,全组合两个函数。</p>
<h1 id="全组合"><a href="#全组合" class="headerlink" title="全组合"></a>全组合</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 全组合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>arr  用于组合的元数据</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>n 取其中的n个数据用于组合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns </span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAllMix</span>(<span class="params">arr, n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> len = arr.length ** n <span class="comment">//全排列的长度</span></span><br><span class="line">  <span class="keyword">let</span> res = <span class="built_in">Array</span>.from(&#123; <span class="attr">length</span>: len &#125;, <span class="function">(<span class="params">item, k</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 构造都是0的空数组</span></span><br><span class="line">    <span class="keyword">let</span> g = <span class="built_in">Array</span>.from(&#123; <span class="attr">length</span>: n &#125;, <span class="function">() =&gt;</span> <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">let</span> ret = [...g, ...k.toString(arr.length).split(<span class="string">&#x27;&#x27;</span>)].slice(-n).map(<span class="function"><span class="params">j</span> =&gt;</span> arr[j])</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getAllMix([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],<span class="number">2</span>)</span><br><span class="line"><span class="comment">// 从1,2,3中获取其中两个数的所有组合</span></span><br><span class="line"><span class="comment">// [1, 1]</span></span><br><span class="line"><span class="comment">// [1, 2]</span></span><br><span class="line"><span class="comment">// [1, 3]</span></span><br><span class="line"><span class="comment">// [2, 1]</span></span><br><span class="line"><span class="comment">// [2, 2]</span></span><br><span class="line"><span class="comment">// [2, 3]</span></span><br><span class="line"><span class="comment">// [3, 1]</span></span><br><span class="line"><span class="comment">// [3, 2]</span></span><br><span class="line"><span class="comment">// [3, 3]</span></span><br></pre></td></tr></table></figure>

<h1 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 全排列</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>arr 全排列的元数据</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns </span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAllSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> len = arr.length ** arr.length</span><br><span class="line">  <span class="keyword">let</span> res = <span class="built_in">Array</span>.from(&#123; <span class="attr">length</span>: len &#125;, <span class="function">(<span class="params">item, k</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 构造都是0的空数组</span></span><br><span class="line">    <span class="keyword">let</span> g = <span class="built_in">Array</span>.from(&#123; <span class="attr">length</span>: arr.length &#125;, <span class="function">() =&gt;</span> <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">let</span> ret = [...g, ...k.toString(arr.length).split(<span class="string">&#x27;&#x27;</span>)].slice(-arr.length)</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">let</span> dd = res.filter(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    item=item.map(<span class="function"><span class="params">k</span>=&gt;</span><span class="built_in">parseInt</span>(k))</span><br><span class="line">    <span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>(item)</span><br><span class="line">    <span class="keyword">return</span> set.size == item.length</span><br><span class="line">  &#125;).map(<span class="function">(<span class="params">i</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> out=[]</span><br><span class="line">    i.forEach(<span class="function">(<span class="params">j,k</span>) =&gt;</span> &#123;</span><br><span class="line">      out[k]=arr[j]</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> out</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> dd</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getAllSort([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="comment">// 数组1,2,3的全排列</span></span><br><span class="line"><span class="comment">// [</span></span><br><span class="line"><span class="comment">//     [ 1, 2, 3 ],</span></span><br><span class="line"><span class="comment">//     [ 1, 3, 2 ],</span></span><br><span class="line"><span class="comment">//     [ 2, 1, 3 ],</span></span><br><span class="line"><span class="comment">//     [ 2, 3, 1 ],</span></span><br><span class="line"><span class="comment">//     [ 3, 1, 2 ],</span></span><br><span class="line"><span class="comment">//     [ 3, 2, 1 ]</span></span><br><span class="line"><span class="comment">// ]</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>代码片段</tag>
      </tags>
  </entry>
  <entry>
    <title>js获取路径上的参数</title>
    <url>/2021/09/25/%E5%8C%85%E4%B8%8E%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5/js%E8%8E%B7%E5%8F%96%E8%B7%AF%E5%BE%84%E4%B8%8A%E7%9A%84%E5%8F%82%E6%95%B0/</url>
    <content><![CDATA[<p>假如有如下请求js的路径,怎么在some.js中获取这个参数?<br><code>base_url/path/to/some.js?username=bob</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> url=<span class="keyword">new</span> <span class="built_in">Error</span>().stack.match(<span class="regexp">/at\s(.*)\s/</span>)[<span class="number">1</span>];</span><br></pre></td></tr></table></figure>
<p>通过错误对象的堆栈信息,拿到报错的URL。我是真的佩服这个大神的脑洞。</p>
]]></content>
      <tags>
        <tag>代码片段</tag>
      </tags>
  </entry>
  <entry>
    <title>tailwindcss 简介</title>
    <url>/2021/10/09/%E5%8C%85%E4%B8%8E%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5/tailwindcss-%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<p><a href="https://www.tailwindcss.cn/">中文文档</a></p>
<p>tailwindcss 是一个原子化的样式库,提供原子化的class,一个class只对应一条css属性</p>
<h3 id="原子化的好处"><a href="#原子化的好处" class="headerlink" title="原子化的好处"></a>原子化的好处</h3><ul>
<li>不用费脑子想类名了</li>
<li>css文件大小可控</li>
<li>css更安全不用担心样式冲突</li>
</ul>
<h3 id="原子化的缺点"><a href="#原子化的缺点" class="headerlink" title="原子化的缺点"></a>原子化的缺点</h3><p>html里面会有一堆类名,不过tailwindcss认为可以通过组件化来规避这个问题,所以也不是缺点</p>
<h3 id="分层设计"><a href="#分层设计" class="headerlink" title="分层设计"></a>分层设计</h3><p>样式共分为四层,使用 <code>@layer</code>可以将我们的代码放到不同的位置,用来调整样式的优先级</p>
<ol>
<li>base 主要定义全局样式,字体等</li>
<li>components 定义class,比如按钮,卡片</li>
<li>utilities 定义原子化的class</li>
<li>screens 定义媒体查询的class</li>
</ol>
<h3 id="支持响应式设计"><a href="#支持响应式设计" class="headerlink" title="支持响应式设计"></a>支持响应式设计</h3><p>sm md lg xl 2xl 大部分基础样式提供响应式前缀</p>
<ul>
<li><code>sm</code> 640px 手机</li>
<li><code>md</code> 768px 平板</li>
<li><code>lg</code> 1024px 1080P显示器</li>
<li><code>xl</code> 1280px 2K显示器  </li>
<li><code>2xl</code> 1536px 4K 显示器<br>例如 <code>w-full</code> <code>md:w-full</code></li>
</ul>
<p><img src="https://iknow-pic.cdn.bcebos.com/f7246b600c33874427696bc25c0fd9f9d62aa0e4?x-bce-process=image/resize,m_lfit,w_600,h_800,limit_1/quality,q_85/format,f_jpg" alt="alt"></p>
<h3 id="支持状态类前缀"><a href="#支持状态类前缀" class="headerlink" title="支持状态类前缀"></a>支持状态类前缀</h3><p>hover focus 等,不是全部的</p>
<h3 id="不够用"><a href="#不够用" class="headerlink" title="不够用"></a>不够用</h3><p>tailwindcss只提供了最常用的样式对应的class,如果这些还不够用的话,我们可以通过指令自定义</p>
<ul>
<li>@layer 样式放的层级 <code> @layer components&#123;...&#125;</code></li>
<li>@variants 定义状态前缀 <code>@variants hover&#123;...&#125;</code></li>
<li>@screen 定义媒体查询 <code>@screen sm&#123;...&#125;</code></li>
<li>@apply 现有的类打散组合  <code>@apply w-full py-2 px-4</code></li>
<li>@reponsive 是<code>@variants reponsive &#123;...&#125;</code>的别名</li>
<li>screen() 与 @screen 类似 <code>@media screen(sm)&#123;...&#125;</code></li>
<li>theme() 或者主题参数 <code>theme(&#39;colors.blue.500&#39;)</code></li>
</ul>
<p>以上是css中的写法,tailwindcss也支持在配置文件中使用js的写法配置。具体就不赘述了。</p>
]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>开源项目推荐 &amp; 好文推荐</title>
    <url>/2021/09/26/%E5%8C%85%E4%B8%8E%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E6%8E%A8%E8%8D%90/</url>
    <content><![CDATA[<h1 id="JeecgBoot"><a href="#JeecgBoot" class="headerlink" title="JeecgBoot"></a>JeecgBoot</h1><p><a href="http://www.jeecg.com/">http://www.jeecg.com/</a> 官网  </p>
<p><a href="http://boot.jeecg.com/">http://boot.jeecg.com</a> demo</p>
<p>JeecgBoot是一款基于BPM的低代码平台！前后端分离架构 SpringBoot 2.x，SpringCloud，Ant Design&amp;Vue，Mybatis-plus，Shiro，JWT，支持微服务。强大的代码生成器让前后端代码一键生成，实现低代码开发！ JeecgBoot引领新低代码开发模式 OnlineCoding-&gt; 代码生成器-&gt; 手工MERGE， 帮助Java项目解决70%的重复工作，让开发更多关注业务，既能快速提高效率，节省研发成本，同时又不失灵活性！一系列低代码能力：Online表单、Online报表、Online图表、表单设计、流程设计、报表设计、大屏设计 等等…</p>
<p>里面的积木报表还是很方便的</p>
<h1 id="KodExplorer-可道云"><a href="#KodExplorer-可道云" class="headerlink" title="KodExplorer 可道云"></a>KodExplorer 可道云</h1><p>看着就是个跳板机,说是企业网盘,我记得那个vscode彩虹屁插件的资源界面有点像啊 </p>
<h1 id="wordart-词云在线生成"><a href="#wordart-词云在线生成" class="headerlink" title="wordart 词云在线生成"></a>wordart 词云在线生成</h1><p><a href="https://wordart.com/">https://wordart.com</a> 无广告 支持图片轮廓 随机颜色 自定义字体</p>
<h1 id="好文推荐"><a href="#好文推荐" class="headerlink" title="好文推荐"></a>好文推荐</h1><ul>
<li><a href="https://juejin.cn/post/6892886272377880583">这些高阶的函数技术,你掌握了么</a></li>
<li><a href="https://my.oschina.net/u/4585038/blog/4869304">从前端性能优化引申出来的5道经典面试题</a></li>
<li><a href="https://segmentfault.com/a/1190000023066043?sort=newest">JavaScript ES6代理的实际用例</a></li>
<li><a href="https://developer.aliyun.com/article/778120">如何打造一款标准的 JS SDK ？</a></li>
<li><a href="https://juejin.cn/post/6844903927100473357">前后端常见的几种鉴权方式</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>盘点几个js库</title>
    <url>/2021/09/26/%E5%8C%85%E4%B8%8E%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5/%E7%9B%98%E7%82%B9%E5%87%A0%E4%B8%AAjs%E5%BA%93/</url>
    <content><![CDATA[<h1 id="p5-js"><a href="#p5-js" class="headerlink" title="p5.js"></a>p5.js</h1><p>把整个浏览器当做一个画板进行创意创作的绘图库<br>官网: https:p5js.org</p>
<h1 id="SpriteJS"><a href="#SpriteJS" class="headerlink" title="SpriteJS"></a>SpriteJS</h1><p>SpriteJS是一款由360奇舞团开源的跨终端 canvas/webgl绘图库,我看了下API非常友好<br>官网: https:gitee.com/qihoo360/SpriteJS</p>
<h1 id="Annie2x"><a href="#Annie2x" class="headerlink" title="Annie2x"></a>Annie2x</h1><p>Annie2x是一款Adobe Flash的插件,支持Flash CC 2015及以上 和 Adobe Animate全线版本。<br>官网： <a href="http://annie2x.com/">http://annie2x.com/</a></p>
<h1 id="flatfile"><a href="#flatfile" class="headerlink" title="flatfile"></a>flatfile</h1><p>超强的数据导入js库,可以将Excel PDF CSV 导出成廷议的符合规则的结构化数据,强大的UI界面支持,非常适合集成到大数据采集的项目</p>
<h2 id="官网"><a href="#官网" class="headerlink" title="官网"></a>官网</h2><p><a href="https://flatfile.io/">https://flatfile.io</a></p>
<h2 id="特色"><a href="#特色" class="headerlink" title="特色"></a>特色</h2><ol>
<li>前端数据导入,校验,格式化</li>
<li>无须构建CSV解析器</li>
<li>强大的API可以将结构化数据发布到任意端点</li>
</ol>
<h2 id="flatfile库的设计思路"><a href="#flatfile库的设计思路" class="headerlink" title="flatfile库的设计思路"></a>flatfile库的设计思路</h2><ol>
<li>定义JSONschema用于数据自身的校验</li>
<li>提供导入校验的钩子 用于数据行字段之间的的校验,以及数据处理能力</li>
<li>点击导入按钮,解析Excel,将Excel列与JSONschema列进行自动映射</li>
<li>提供映射交互页面,给用户修改自动映射的结果</li>
<li>生成数据处理后的结果,让用户填充校验失败的字段</li>
<li>提供导出的API 提供平台能力使用这些结构化数据</li>
</ol>
<h1 id="handsontable-强大的表格-数据再多都不会卡"><a href="#handsontable-强大的表格-数据再多都不会卡" class="headerlink" title="handsontable 强大的表格,数据再多都不会卡"></a>handsontable 强大的表格,数据再多都不会卡</h1><p><a href="https://handsontable.com/">https://handsontable.com/</a></p>
<h1 id="ag-grid-The-Best-JavaScript-Grid-in-the-World"><a href="#ag-grid-The-Best-JavaScript-Grid-in-the-World" class="headerlink" title="ag-grid The Best JavaScript Grid in the World"></a>ag-grid The Best JavaScript Grid in the World</h1><p><a href="https://www.ag-grid.com/">https://www.ag-grid.com</a></p>
]]></content>
      <tags>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title>为博客添加 Gitalk 评论插件</title>
    <url>/2017/12/19/%E5%8D%9A%E5%AE%A2/2017-12-19-%E4%B8%BA%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0-Gitalk-%E8%AF%84%E8%AE%BA%E6%8F%92%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>由于 <strong>Disqus</strong> 对于国内网路的支持十分糟糕，很多人反映 Disqus 评论插件一直加载不出来。而我一直是处于翻墙状态的~（话说你们做程序员的都不翻墙用Google的吗😅，哈哈，吐嘈下）</p>
<p>针对这个问题，我添加了<a href="https://github.com/gitalk/gitalk">Gitalk</a> 评论插件。在此，非常感谢 <a href="https://github.com/FeDemo">@FeDemo</a> 的推荐 。</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="Gitalk-评论插件"><a href="#Gitalk-评论插件" class="headerlink" title="Gitalk 评论插件"></a>Gitalk 评论插件</h3><p>首先来看看 Gitalk 的界面和功能：</p>
<p><a href="https://gitalk.github.io/"><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fmm4u3j0lmj30nk0kl40i.jpg"></a></p>
<p>gitalk 使用 Github 帐号登录，界面干净整洁，最喜欢的一点是支持 <code>MarkDown语法</code>。</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>Gitalk 是一个利用 Github API,基于 Github issue 和 Preact 开发的评论插件，在 Gitalk 之前还有一个 <a href="https://github.com/imsun/gitment">gitment</a> 插件也是基于这个原理开发的,不过 gitment 已经很久没人维护了。</p>
<p>可以看到在 gitalk 的评论框进行评论时，其实就是在对应的 issue 上提问题。</p>
<p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fmm5916av1j30i209rab7.jpg" alt="gitalk评论框"></p>
<p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fmm596ggkfj30mx0gfjuk.jpg" alt="Github issue"></p>
<h3 id="集成-Gitalk"><a href="#集成-Gitalk" class="headerlink" title="集成 Gitalk"></a>集成 Gitalk</h3><p>到这里，你应该对 Gitalk 有个大致的了解了，现在，开始集成 gitalk 插件吧。</p>
<p>将这段代码插入到你的网站：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!-- Gitalk 评论 start  --&gt;</span><br><span class="line">&#123;% <span class="keyword">if</span> site.gitalk.enable %&#125;</span><br><span class="line">&lt;!-- Link Gitalk 的支持文件  --&gt;</span><br><span class="line">&lt;link rel=<span class="string">&quot;stylesheet&quot;</span> href=<span class="string">&quot;https://unpkg.com/gitalk/dist/gitalk.css&quot;</span>&gt;</span><br><span class="line">&lt;script src=<span class="string">&quot;https://unpkg.com/gitalk@latest/dist/gitalk.min.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;div id=<span class="string">&quot;gitalk-container&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">    &lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">    <span class="keyword">var</span> gitalk = <span class="keyword">new</span> Gitalk(&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// gitalk的主要参数</span></span><br><span class="line">		clientID: <span class="string">`Github Application clientID`</span>,</span><br><span class="line">		clientSecret: <span class="string">`Github Application clientSecret`</span>,</span><br><span class="line">		repo: <span class="string">`存储你评论 issue 的 Github 仓库名`</span>,</span><br><span class="line">		owner: <span class="string">&#x27;Github 用户名&#x27;</span>,</span><br><span class="line">		admin: [<span class="string">&#x27;Github 用户名&#x27;</span>],</span><br><span class="line">		id: <span class="string">&#x27;页面的唯一标识，gitalk会根据这个标识自动创建的issue的标签&#x27;</span>,</span><br><span class="line">    </span><br><span class="line">    &#125;);</span><br><span class="line">    gitalk.render(<span class="string">&#x27;gitalk-container&#x27;</span>);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br><span class="line">&lt;!-- Gitalk end --&gt;</span><br></pre></td></tr></table></figure>

<p>我们需要关心的就是配置下面几个参数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">clientID: <span class="string">`Github Application clientID`</span>,</span><br><span class="line">clientSecret: <span class="string">`Github Application clientSecret`</span>,</span><br><span class="line">repo: <span class="string">`Github 仓库名`</span>,<span class="comment">//存储你评论 issue 的 Github 仓库名（建议直接用 GitHub Page 的仓库名）</span></span><br><span class="line">owner: <span class="string">&#x27;Github 用户名&#x27;</span>,</span><br><span class="line">admin: [<span class="string">&#x27;Github 用户名&#x27;</span>], <span class="comment">//这个仓库的管理员，可以有多个，用数组表示，一般写自己,</span></span><br><span class="line">id: <span class="string">&#x27;window.location.pathname&#x27;</span>, <span class="comment">//页面的唯一标识，gitalk 会根据这个标识自动创建的issue的标签,我们使用页面的相对路径作为标识</span></span><br></pre></td></tr></table></figure>
<p>当然，还有其他很多参数，有兴趣的话可以 <a href="https://github.com/gitalk/gitalk#options"> 点这里</a>。</p>
<p>比如我就增加了这个全屏遮罩的参数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">distractionFreeMode: true,</span><br></pre></td></tr></table></figure>

<h3 id="创建-Github-Application"><a href="#创建-Github-Application" class="headerlink" title="创建 Github Application"></a>创建 Github Application</h3><p>Gitalk 需要一个 <strong>Github Application</strong>，<a href="https://github.com/settings/applications/new">点击这里申请</a>。</p>
<p>填写下面参数：</p>
<p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fmm7jaib6fj30jo0gaacs.jpg"></p>
<p>点击创建</p>
<p>获取 <code>Client ID</code> 和 <code>Client Secret</code> 填入你的我们 Gitalk 参数中</p>
<p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fmm7jrzff6j30lc0budhp.jpg"></p>
<p>当你参数都设置好，将代码推送到 Github 仓库后，没什么问题的话，当你点击进入你的博客页面后就会出现评论框了。</p>
<p>当你用 github 帐号登录（管理员），并且第一次加载该会比较慢，因为第一次加载会自动在你 <code>repo</code> 的仓库下创建对应 issue。</p>
<p>比如说这样：</p>
<p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fmm867n88cj30l809mjse.jpg"></p>
<p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fmm8a0i0jkj30rr0ct42t.jpg"></p>
<p>当然，你也可以手动创建issue作为 gitalk评论容器。只要有 <code>Gitalk</code> 标签 和 <code>id</code> 对应标签就可以。比我我自己创建的 <a href="https://github.com/qiubaiying/qiubaiying.github.io/issues/38">About issue</a> 。</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>最后说几句吐嘈几句， Gitalk 需要你点开每篇文章的页面才会创建对应的 issue,对我来说真是个糟糕的体验（文章有点多~）。</p>
<p>当然，也有解决办法，这篇 <a href="https://draveness.me/git-comments-initialize">自动初始化 Gitalk 和 Gitment 评论</a>，就解决了这个问题。</p>
<p>最后，<a href="https://github.com/qiubaiying/qiubaiying.github.io">给个 star 吧</a>~</p>
]]></content>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>启用rss订阅功能</title>
    <url>/2018/03/25/%E5%8D%9A%E5%AE%A2/2018-3-25-%E5%90%AF%E7%94%A8rss%E8%AE%A2%E9%98%85/</url>
    <content><![CDATA[<h1 id="修改-config-yml文件"><a href="#修改-config-yml文件" class="headerlink" title="修改_config.yml文件"></a>修改_config.yml文件</h1><ol>
<li>在gems中增加jekyll-feed依赖</li>
<li>配置插件jekyll-feed </li>
<li>页面中启用RSS按钮的显示   </li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plugins:</span><br><span class="line">  - jekyll-feed</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">gems:[jekyll-feed]  </span><br><span class="line"></span><br><span class="line">RSS: true</span><br></pre></td></tr></table></figure>
<h1 id="根目录下应该有-feed-xml"><a href="#根目录下应该有-feed-xml" class="headerlink" title="根目录下应该有 feed.xml"></a>根目录下应该有 feed.xml</h1><p>具体可以参考<a href="https://blog.csdn.net/itmyhome1990/article/details/42919429">为Jekyll博客添加RSS feed订阅功能</a></p>
]]></content>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>博客中使用emoji表情</title>
    <url>/2018/03/25/%E5%8D%9A%E5%AE%A2/2018-3-25-%E5%9C%A8%E5%8D%9A%E5%AE%A2%E4%B8%AD%E4%BD%BF%E7%94%A8emoji%E8%A1%A8%E6%83%85/</url>
    <content><![CDATA[<p><a href="https://github.com/guodongxiaren/README/blob/master/emoji.md">表情列表</a></p>
<h1 id="修改-config-yml文件"><a href="#修改-config-yml文件" class="headerlink" title="修改_config.yml文件"></a>修改_config.yml文件</h1><ol>
<li>在gems中增加jemoji依赖</li>
<li>配置插件jemoji  </li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plugins:</span><br><span class="line">  - jemoji</span><br><span class="line"></span><br><span class="line">gems:[jemoji]  </span><br></pre></td></tr></table></figure>
<h1 id="测试显示"><a href="#测试显示" class="headerlink" title="测试显示"></a>测试显示</h1><h2 id="bowtie-blush"><a href="#bowtie-blush" class="headerlink" title=":bowtie: :blush:"></a>:bowtie: :blush:</h2>]]></content>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>2021-4-7-在博客中使用简书的图片</title>
    <url>/2021/04/07/%E5%8D%9A%E5%AE%A2/2021-4-7-%E5%9C%A8%E5%8D%9A%E5%AE%A2%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%AE%80%E4%B9%A6%E7%9A%84%E5%9B%BE%E7%89%87/</url>
    <content><![CDATA[<p>正常使用简书的图片会出现403错误,需要在页面头<code>_includes\head.html</code>加入   <code>&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;</code>防止被简书安全措施(跨站请求伪造)拦截</p>
]]></content>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo github pages 域名设置</title>
    <url>/2021/05/06/%E5%8D%9A%E5%AE%A2/2021-5-6-%20hexo%20cname%20github%20pages%20%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D/</url>
    <content><![CDATA[<p>将<code>CNAME</code>文件放在 <code>/source/</code>目录下即可</p>
]]></content>
  </entry>
  <entry>
    <title>netlify介绍</title>
    <url>/2021/12/17/%E5%8D%9A%E5%AE%A2/netlify%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h1 id="目前博客存在的问题"><a href="#目前博客存在的问题" class="headerlink" title="目前博客存在的问题"></a>目前博客存在的问题</h1><p>github pages服务部署,国内访问很慢,github防止百度爬虫不收录</p>
<h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>使用netlify可以做静态网站的cdn部署</p>
<h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h1><ol>
<li>使用github账号登录netlify</li>
<li>授权netlify访问需要部署的仓库与分支</li>
</ol>
<hr>
<ol start="3">
<li>如果有自己的域名,在DNS解析服务器上,CNAME解析到netlify提供的域名即可</li>
</ol>
<h1 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h1><p>ping 一下自己的域名,看下真实地址对不对就可以的<br><img src="images/2021-12-17-22-27-52.png"></p>
<h1 id="netlify官网"><a href="#netlify官网" class="headerlink" title="netlify官网"></a>netlify官网</h1><p><a href="https://www.netlify.com/">https://www.netlify.com/</a></p>
]]></content>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>给hexo next换个色调</title>
    <url>/2021/11/09/%E5%8D%9A%E5%AE%A2/%E7%BB%99hexo-next%E6%8D%A2%E4%B8%AA%E8%89%B2%E8%B0%83/</url>
    <content><![CDATA[<p>next的极简风我还是挺喜欢的，但是不喜欢这个黑白主题，死气沉沉的，我想给他换个色调。</p>
<ol>
<li>首先找到喜欢的色调图片</li>
<li><a href="https://coolors.co/">https://coolors.co/</a> 打开调色网站</li>
<li>修改主题配置<figure class="highlight yml"><figcaption><span>source/_data/next.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">custom_file_path:</span></span><br><span class="line">  <span class="comment">#head: source/_data/head.njk</span></span><br><span class="line">  <span class="comment">#header: source/_data/header.njk</span></span><br><span class="line">  <span class="comment">#sidebar: source/_data/sidebar.njk</span></span><br><span class="line">  <span class="comment">#postMeta: source/_data/post-meta.njk</span></span><br><span class="line">  <span class="comment">#postBodyEnd: source/_data/post-body-end.njk</span></span><br><span class="line">  <span class="comment">#footer: source/_data/footer.njk</span></span><br><span class="line">  <span class="comment">#bodyEnd: source/_data/body-end.njk</span></span><br><span class="line">  <span class="attr">variable:</span> <span class="string">source/_data/variables.styl</span></span><br><span class="line">  <span class="comment">#mixin: source/_data/mixins.styl</span></span><br><span class="line">  <span class="comment">#style: source/_data/styles.styl  </span></span><br></pre></td></tr></table></figure></li>
<li>新建文件 <code>source/_data/variables.styl</code></li>
<li>下面是默认色<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-pseudo">:root</span> &#123;</span><br><span class="line">  --<span class="selector-tag">body</span>-bg-<span class="attribute">color</span>: <span class="number">#f5f5d5</span>;</span><br><span class="line">  --<span class="attribute">content</span>-bg-<span class="attribute">color</span>: <span class="number">#f5f5d5</span>;</span><br><span class="line">  --card-bg-<span class="attribute">color</span>: <span class="number">#f5f5f5</span>;</span><br><span class="line">  --text-<span class="attribute">color</span>: <span class="number">#555</span>;</span><br><span class="line">  --<span class="selector-tag">blockquote</span>-<span class="attribute">color</span>: <span class="number">#666</span>;</span><br><span class="line">  --link-<span class="attribute">color</span>: <span class="number">#555</span>;</span><br><span class="line">  --link-hover-<span class="attribute">color</span>: <span class="number">#222</span>;</span><br><span class="line">  --brand-<span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">  --brand-hover-<span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">  --<span class="selector-tag">table</span>-row-odd-bg-<span class="attribute">color</span>: <span class="number">#f9f9f9</span>;</span><br><span class="line">  --<span class="selector-tag">table</span>-row-hover-bg-<span class="attribute">color</span>: <span class="number">#f5f5f5</span>;</span><br><span class="line">  --<span class="selector-tag">menu</span>-item-bg-<span class="attribute">color</span>: <span class="number">#f5f5f5</span>;</span><br><span class="line">  --btn-default-bg: <span class="number">#fff</span>;</span><br><span class="line">  --btn-default-<span class="attribute">color</span>: <span class="number">#555</span>;</span><br><span class="line">  --btn-default-<span class="attribute">border-color</span>: <span class="number">#555</span>;</span><br><span class="line">  --btn-default-hover-bg: <span class="number">#222</span>;</span><br><span class="line">  --btn-default-hover-<span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">  --btn-default-hover-<span class="attribute">border-color</span>: <span class="number">#222</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>修改后面这个文件就行了,但是我还没想好合适的颜色  </p>
<figure class="highlight less"><figcaption><span>source/_data/variables.styl</span></figcaption><table><tr><td class="code"><pre><span class="line">$body-bg-color   = #BEE7E9 </span><br><span class="line">$content-bg-color   = #a1e6e9  </span><br><span class="line"><span class="comment">// $card-bg-color   = #</span></span><br><span class="line"><span class="comment">// $text-color   = #</span></span><br><span class="line"><span class="comment">// $blockquote-color   = #</span></span><br><span class="line"><span class="comment">// $link-color   = #</span></span><br><span class="line"><span class="comment">// $link-hover-color   = #e4393c</span></span><br><span class="line"><span class="comment">// $brand-color   = #</span></span><br><span class="line"><span class="comment">// $brand-hover-color   = #</span></span><br><span class="line"><span class="comment">// $table-row-odd-bg-color   = #</span></span><br><span class="line"><span class="comment">// $table-row-hover-bg-color   = #</span></span><br><span class="line"><span class="comment">// $menu-item-bg-color   = #</span></span><br><span class="line"><span class="comment">// $btn-default-bg   = #</span></span><br><span class="line"><span class="comment">// $btn-default-color   = #</span></span><br><span class="line"><span class="comment">// $btn-default-border-color   = #</span></span><br><span class="line"><span class="comment">// $btn-default-hover-bg   = #</span></span><br><span class="line"><span class="comment">// $btn-default-hover-color   = #</span></span><br><span class="line"><span class="comment">// $btn-default-hover-border-color   = #</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


]]></content>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>2021-4-19- docker基本原理概述</title>
    <url>/2021/04/19/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/2021-4-19-%20docker%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h1 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h1><p>软件部署的时候,我们需要打包发布到 开发环境 测试环境 生产环境。<br>但是我开发环境,测试环境用的是windows 。 集成测试环境, 生产环境用的linux。<br>由于环境的不同可能会导致意想不到的问题，明明在环境A测试通过，在环境B测试失败。于是又要加班定位，而这种系统级别的定位往往是最费时间和脑子的，而聪明的程序员就想到，我直接备份我的操作系统，然后你那边直接还原我的操作系统就好了。<br>备份操作系统文件太大，操作系统的硬件也可能不一样，那么怎么办？<br>虚拟机呗！！！<br>虚拟机还不够快，不够小，不够方便，docker应运而生!!</p>
<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>docker最重要的两个概念,是<strong>容器</strong>,和<strong>镜像</strong><br>其实根据我的docker起源说,聪明的小伙伴肯定能类比到上述的虚拟机和虚拟机用到的镜像文件,对的,咱就这么理解就好了<br>容器==虚拟机 镜像==虚拟机启动用到的镜像<br>要想我们发布的软件跑起来,怎么做?<br>运行一个容器,容器里面装个镜像就可以了!!! so easy</p>
<h1 id="Git神模仿"><a href="#Git神模仿" class="headerlink" title="Git神模仿"></a>Git神模仿</h1><p>做过开发的应该都用过git去管理源代码,docker将git的思想用在镜像上。<br>假如有个容器运行着linux的基础镜像,你在此容器中上安装了nodejs,然后我们就可以commit一下这个容器,容器的状态就会被保存成生成一个新的镜像了.<br>很多docker命令都能做到类似git commit 的这种命令,然后返回一个hash值来标识新的镜像,我们就可以根据这些hash标记,在容器内时光倒流,docker也支持git打标签的方式给容器或者镜像取个别名,方便查找,hash谁记得住<br>#下一篇文章 就是hello world环节了</p>
]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>2021-4-19- docker的一些命令</title>
    <url>/2021/04/19/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/2021-4-19-%20docker%E7%9A%84%E4%B8%80%E4%BA%9B%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>承接上一篇的 <a href="https://www.jianshu.com/p/8ac09895933c">win7 docker环境安装</a><br><code>docker info</code> 查看当前虚拟机的docker信息<br><img src="https://upload-images.jianshu.io/upload_images/8156292-5eb649af529413be.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><code>docker help</code>  查看命令的帮助文档<br><img src="https://upload-images.jianshu.io/upload_images/8156292-62a65b9f3fc65cad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><img src="https://upload-images.jianshu.io/upload_images/8156292-7f6a4d45057a544b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><img src="https://upload-images.jianshu.io/upload_images/8156292-748199cb9f11bba6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><img src="https://upload-images.jianshu.io/upload_images/8156292-921ccef7c8b1887a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>一共40来个命令,每个命令后面有解释,一看就明白干嘛的</p>
<h1 id="第一类命令-镜像相关的命令跟git-命令可以类比着记忆"><a href="#第一类命令-镜像相关的命令跟git-命令可以类比着记忆" class="headerlink" title="第一类命令 镜像相关的命令跟git 命令可以类比着记忆"></a>第一类命令 镜像相关的命令跟git 命令可以类比着记忆</h1><ul>
<li>build==init  初始化镜像</li>
<li>commit==commit  提交镜像</li>
<li>diff 比较文件系统</li>
<li>tag 给镜像打标签</li>
<li>history 查看镜像历史</li>
<li> save 将镜像保存成 tar包</li>
<li>load 从tar中读取镜像</li>
<li>rmi 删除镜像</li>
</ul>
<h1 id="第二类命令-容器相关的命令-每个容器可以理解成系统中的一个运行的进程"><a href="#第二类命令-容器相关的命令-每个容器可以理解成系统中的一个运行的进程" class="headerlink" title="第二类命令 容器相关的命令,每个容器可以理解成系统中的一个运行的进程"></a>第二类命令 容器相关的命令,每个容器可以理解成系统中的一个运行的进程</h1><ul>
<li>create ,rm 创建容器</li>
<li>attach 给容器附加个什么东西</li>
<li>exec 在容器里执行什么东西</li>
<li>restart 重启容器</li>
<li>export 导出容器成tar压缩包</li>
<li>pause ,unpause  取消暂停</li>
<li>run,kill 启动容器</li>
<li>stop,start 杀容器,停止运行,并不会删除,容器有三种状态,运行的,暂停的,停止的,看这状态是不是更像虚拟机了</li>
<li>rename 重命名</li>
<li>ps ,port,logs,top,stats 容器列表,容器的接口映射关系,容器的日志,容器内的进程,容器资源使用情况,这几个都是看容器状态的</li>
<li>update 更新容器的配置<h1 id="第三类命令-dockerHub相关的"><a href="#第三类命令-dockerHub相关的" class="headerlink" title="第三类命令 dockerHub相关的"></a>第三类命令 dockerHub相关的</h1></li>
<li>login ,logout 登录,登出</li>
<li>pull,push dockerHub 拉取 推送 镜像</li>
</ul>
<h1 id="stop与kill的区别"><a href="#stop与kill的区别" class="headerlink" title="stop与kill的区别"></a>stop与kill的区别</h1><p>stop 会等10秒后再kill容器,并会告知容器内的程序<br>详情请参考 <a href="https://blog.csdn.net/weixin_34414196/article/details/86428138">https://blog.csdn.net/weixin_34414196/article/details/86428138</a></p>
<h1 id="run-跟-start的区别"><a href="#run-跟-start的区别" class="headerlink" title="run 跟 start的区别"></a>run 跟 start的区别</h1><p>run =create + start<br>所以咱们第一次用run  后面用start就好了</p>
<p>当我们具体用哪个命令的时候,<code>docker COMMAND --help</code> 查看某个命令的帮助文档<br><img src="https://upload-images.jianshu.io/upload_images/8156292-42e1a0d65a8641d9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>[OPTIONS] 上图中的这种参数就是可有可无,大写代表变量,不要直接抄哦<br>NAME|ID  容器的名称或者ID 必选<br>[NAME|ID…] 表示可以填多个</p>
]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>2021-4-19- win7 docker环境安装</title>
    <url>/2021/04/19/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/2021-4-19-%20win7%20docker%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<ol>
<li>本人win7,先下载DockerToolBox,win10的可以下载docker desktop for windows<br>下载地址 <a href="https://docs.docker.com/toolbox/overview/">https://docs.docker.com/toolbox/overview/</a><br>双击运行 一路下一步就好了<br><img src="https://upload-images.jianshu.io/upload_images/8156292-f83cd8976a133c8c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li>
<li>然后报错,手按太快,询问是否安装虚拟机的时候直接点了回车,不安装,这里要注意下<br><img src="https://upload-images.jianshu.io/upload_images/8156292-bf7c186d1f902ae6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li>
<li>正常安装后桌面应该出现这三个小图标,第一个是docker的命令行工具,第二个是联网查看dockerhub的镜像,第三个是虚拟机<br><img src="https://upload-images.jianshu.io/upload_images/8156292-5424787ab9e6b89d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li>
<li>把提前下载好的 docker2boot镜像丢到缓存里面,否则启动的时候找不到会自动下载比较慢<br><img src="https://upload-images.jianshu.io/upload_images/8156292-06cb26f3eeb4ada1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li>
<li>我们运行第一个Docker Quickstart Terminal ,出现下面的界面就ok了<br><img src="https://upload-images.jianshu.io/upload_images/8156292-35392cc5cc1dcd05.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li>
</ol>
]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>git常见问题</title>
    <url>/2021/04/19/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/2021-4-19-git%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="使用git提交到github-每次都要输入用户名和密码的解决方法"><a href="#使用git提交到github-每次都要输入用户名和密码的解决方法" class="headerlink" title="使用git提交到github,每次都要输入用户名和密码的解决方法"></a>使用git提交到github,每次都要输入用户名和密码的解决方法</h1><p><a href="https://www.cnblogs.com/sky6862/p/7992736.html">https://www.cnblogs.com/sky6862/p/7992736.html</a></p>
<h1 id="使用ssh协议提交github代码"><a href="#使用ssh协议提交github代码" class="headerlink" title="使用ssh协议提交github代码"></a>使用ssh协议提交github代码</h1><p><a href="https://blog.csdn.net/u013778905/article/details/83501204">https://blog.csdn.net/u013778905/article/details/83501204</a></p>
<h1 id="git-记住密码"><a href="#git-记住密码" class="headerlink" title="git 记住密码"></a>git 记住密码</h1><p><code>git config --global credential.helper store</code></p>
<h1 id="git-密码错误"><a href="#git-密码错误" class="headerlink" title="git 密码错误"></a>git 密码错误</h1><p>控制面板\用户帐户和家庭安全\凭据管理器  把网站的凭证删除掉</p>
<h1 id="git-pull-冲突"><a href="#git-pull-冲突" class="headerlink" title="git pull 冲突"></a>git pull 冲突</h1><p>如果不想解决的话,可以直接 <code>git reset --hard HEAD</code></p>
<h1 id="一次提交需要提交到多个分支的时候-使用摘取命令"><a href="#一次提交需要提交到多个分支的时候-使用摘取命令" class="headerlink" title="一次提交需要提交到多个分支的时候,使用摘取命令"></a>一次提交需要提交到多个分支的时候,使用摘取命令</h1><p><code>git cherry-pick &lt;commitID&gt;</code></p>
<h1 id="git-从本地clone"><a href="#git-从本地clone" class="headerlink" title="git 从本地clone"></a>git 从本地clone</h1><p>git clone 除了从远程地址clone，还能从本地clone。<br>有时候方便开发我们需要不同的分支在不同的文件夹下同步开发，避免频繁的编译重构。<br>直接复制文件夹，里面的node_modules  target 等被gitignore的文件会非常慢.<br><img src="https://upload-images.jianshu.io/upload_images/8156292-9a607263a9ddbf2c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>IDEA maven helper 插件</title>
    <url>/2021/09/26/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/IDEA-maven-helper-%E6%8F%92%E4%BB%B6/</url>
    <content><![CDATA[<p>用于分析没有使用的jar包依赖</p>
]]></content>
      <tags>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title>npm ls 报错</title>
    <url>/2021/05/06/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/cb-apply-is-not-a-function/</url>
    <content><![CDATA[<blockquote>
<p>“npm ls –depth 0” 报错 “cb.apply is not a function”<br>我是安装nvm 切换node版本后报错的</p>
</blockquote>
<ol>
<li><code>win + r</code> 打开运行，输入<code>%appdata%</code></li>
<li>删除 <code>npm</code> 和 <code>npm-cache</code> 文件夹</li>
<li>执行<code>npm cache clean --force</code>命令</li>
</ol>
<p>此时应该就可以了。如果还不行，就执行卸载Node.js重新安装。</p>
]]></content>
      <tags>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title>eclipse开启自动完成</title>
    <url>/2021/09/26/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/eclipse%E5%BC%80%E5%90%AF%E8%87%AA%E5%8A%A8%E5%AE%8C%E6%88%90/</url>
    <content><![CDATA[<p>依次点击Window –&gt; Perferences（选项设置） –&gt; Java –&gt; Editor（编辑） –&gt; Content Assist（内容辅助/代码提示）<br><img src="https://img-blog.csdn.net/20180612234507746" alt="alt"><br>然后在“Content Assist”页面中，可以看到下面有一个Auto Activation中有一个Auto activation triggers for Java</p>
<p>在这一个输入框中输入<code>.qwertyuioplkjhgfdsazxcvbnm</code>，然后点击下面的“OK”，这样代码自动补全就已经设置好了</p>
<p>在我们编写代码的时候，只要打出一个字母或者”.”都可以自动调出自动补全功能</p>
]]></content>
      <tags>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title>npm install 命令报错的情况下 显示详细log用于排查问题</title>
    <url>/2021/09/25/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/npm-install-%E5%91%BD%E4%BB%A4%E6%8A%A5%E9%94%99%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B-%E6%98%BE%E7%A4%BA%E8%AF%A6%E7%BB%86log%E7%94%A8%E4%BA%8E%E6%8E%92%E6%9F%A5%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p><code>npm install ionic --loglevel verbose</code> 修改日志级别即可</p>
]]></content>
      <tags>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title>node打包成可执行文件exe</title>
    <url>/2021/09/26/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/node%E6%89%93%E5%8C%85%E6%88%90%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6exe/</url>
    <content><![CDATA[<h2 id="使用pkg这个npm工具打包"><a href="#使用pkg这个npm工具打包" class="headerlink" title="使用pkg这个npm工具打包"></a>使用pkg这个npm工具打包</h2><ol>
<li>安装<code>npm i -g pkg</code></li>
<li>配置<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;bin&quot;</span>:<span class="string">&quot;main.js&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;pkg&quot;</span>:&#123;</span><br><span class="line">    <span class="attr">&quot;target&quot;</span>:<span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;outputPath&quot;</span>:<span class="string">&quot;&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>执行 执行的时候可能会报错,因为要从GitHub下载一些依赖,需要能连上github才行</li>
</ol>
<h3 id="无法从github下载解决方案"><a href="#无法从github下载解决方案" class="headerlink" title="无法从github下载解决方案"></a>无法从github下载解决方案</h3><ol>
<li>从pkg-fetch仓库的release文件中找到自己要打包的target编译版本,例如<code>node-v14.4.0-win-x64</code>,下载后修改名字,修改成<code>fetched-v14.4.0-win-x64</code></li>
<li>将下载的文件放到<code>~/.pkg-cache/v3.0</code>目录下,如果目录中有 <code>.downloading</code>的文件记得删除掉</li>
</ol>
<h2 id="deno可以直接打包成exe-有兴趣的尝试下"><a href="#deno可以直接打包成exe-有兴趣的尝试下" class="headerlink" title="deno可以直接打包成exe,有兴趣的尝试下"></a>deno可以直接打包成exe,有兴趣的尝试下</h2>]]></content>
      <tags>
        <tag>npm</tag>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title>npm生成命令行脚本</title>
    <url>/2021/09/26/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/npm%E7%94%9F%E6%88%90%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<ol>
<li><p>入口第一行 <code>index.js</code> 声明脚本执行环境是node</p>
<figure class="highlight js"><figcaption><span>/path/index.js</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#! /usr/bin/env node</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>package.json#bin</code>对象内可以配置多个命令行。key是命令,value是文件路径</p>
<figure class="highlight json"><figcaption><span>/package.json</span></figcaption><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;bin&quot;</span>:&#123;</span><br><span class="line">    <span class="attr">&quot;vue&quot;</span>:<span class="string">&quot;path/index.js&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;名称2&quot;</span>:<span class="string">&quot;path/to/some.js&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用 <code>npm link</code>全局安装这个包,就可以使用<code>vue xxx</code>命令咯</p>
</li>
<li><p>或者作为本地依赖项,在srcipts里面使用</p>
<figure class="highlight json"><figcaption><span>/package.json</span></figcaption><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;srcipts&quot;</span>:&#123;</span><br><span class="line">    <span class="attr">&quot;cli&quot;</span>:<span class="string">&quot;vue xxx&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;dependencies&quot;</span>:&#123;</span><br><span class="line">    <span class="attr">&quot;vue-cli&quot;</span>:<span class="string">&quot;file:./index.js&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <tags>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title>win10小技巧之剪切板</title>
    <url>/2021/09/13/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/win10%E5%B0%8F%E6%8A%80%E5%B7%A7%E4%B9%8B%E5%89%AA%E5%88%87%E6%9D%BF/</url>
    <content><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/8156292-059a726b92b331b6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>windows10开启剪贴板历史后，使用 <code>win+v</code>可以看到剪贴板历史，从历史中选择。非常好用<br><img src="https://upload-images.jianshu.io/upload_images/8156292-b343ce64720df903.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
]]></content>
      <tags>
        <tag>windows10</tag>
      </tags>
  </entry>
  <entry>
    <title>利用bat简化命令行脚本</title>
    <url>/2021/09/26/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/%E5%88%A9%E7%94%A8bat%E7%AE%80%E5%8C%96%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<h2 id="注册表修改"><a href="#注册表修改" class="headerlink" title="注册表修改"></a>注册表修改</h2><p>创建 <code>fastkey.reg</code> 注册表修改文件。 AutoRun后面的路径修改成自己的配置文件，这个修改是让CMD每次执行的时候去执行下这个<code>fastkey.bat</code></p>
<figure class="highlight plain"><figcaption><span>fastkey.reg</span></figcaption><table><tr><td class="code"><pre><span class="line">Windows Registry Editor Version 5.00</span><br><span class="line"></span><br><span class="line">[HKEY_CURRENT_USER\SOFTWARE\Microsoft\Command Processor]</span><br><span class="line">&quot;AutoRun&quot;&#x3D;&quot;D:\\profile\\fastkey.bat&quot;</span><br></pre></td></tr></table></figure>

<h2 id="创建修改-fastkey-bat-文件"><a href="#创建修改-fastkey-bat-文件" class="headerlink" title="创建修改 fastkey.bat 文件"></a>创建修改 fastkey.bat 文件</h2><p>这里我创建了三个命令别名</p>
<ol>
<li>(单行命令)用linux shell的<code>ls</code>命令执行windows cmd的dir命令。<code>$*</code>代表把<code>ls</code>后面所有的参数带给<code>dir</code></li>
<li>(多行命令)多行命令的话,我们可以写在批处理文件中,然后通过别名调用批处理文件</li>
<li>端口被占用查询<code>netstat -ano | findstr LISTENNING | findstr 8080</code>,这个命令我经常用但是又记不住,所以配置了一个别名,要注意的点是管道运算符<code>|</code>需要转义成<code>$b</code>,且两边不能有空格<figure class="highlight bat"><figcaption><span>D:\profile\fastkey.bat</span></figcaption><table><tr><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"><span class="built_in">doskey</span> ls= <span class="built_in">dir</span> /b $*</span><br><span class="line"><span class="built_in">doskey</span> dev= <span class="keyword">call</span> %~dp0npmdev.bat</span><br><span class="line"><span class="built_in">doskey</span> port= netstat -ano$bfindstr LISTENNING$bfindstr $*</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>创建自定义批处理脚本 npmdev.bat<figure class="highlight bat"><figcaption><span>D:\profile\npmdev.bat</span></figcaption><table><tr><td class="code"><pre><span class="line">npm run dev || npm <span class="built_in">start</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>现在我可以在命令行里面</p>
<ol>
<li>输入<code>dev</code>执行 npm run dev || npm start</li>
<li>输入 <code>ls</code> 查看当前目录</li>
<li>输入<code> port 8080</code> 查看端口被哪个进程占用,然后<code>taskkill</code></li>
</ol>
<p><strong>发挥想象,还能用这个做更多的事情</strong></p>
]]></content>
      <tags>
        <tag>cmd</tag>
      </tags>
  </entry>
  <entry>
    <title>启动tomcat时,log出现淇℃伅</title>
    <url>/2021/09/26/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/%E5%90%AF%E5%8A%A8tomcat%E6%97%B6-log%E5%87%BA%E7%8E%B0%E6%B7%87%E2%84%83/</url>
    <content><![CDATA[<p><code>淇℃伅</code>其实是 <code>信息</code>的乱码显示<br>修改tomcat安装目录下的<code>config/logging.properties</code>文件,找到<code>java.util.logging.Consolehandler.encoding</code>,将值改成<code>GBK</code>即可解决该问题。我下载的comcat8.5默认是<code>UTF-8</code></p>
<p>如果没有这个配置项就在最后直接加上</p>
<figure class="highlight properties"><figcaption><span>config/logging.properties</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">java.util.logging.Consolehandler.encoding</span> = <span class="string">GBK</span></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title>设置node最大使用内存</title>
    <url>/2021/09/26/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/%E8%AE%BE%E7%BD%AEnode%E6%9C%80%E5%A4%A7%E4%BD%BF%E7%94%A8%E5%86%85%E5%AD%98/</url>
    <content><![CDATA[<p>node的最大使用内存是2G 超出会导致程序退出</p>
<p>下面设置的是4096M<br><code>setx NODE_OPTIONS --max_old_space_size=4096</code></p>
]]></content>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title>小工具集合</title>
    <url>/2021/04/19/%E6%88%91%E7%9A%84%E9%A1%B9%E7%9B%AE/2021-4-19-%E5%B0%8F%E5%B7%A5%E5%85%B7%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<h1 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h1><p><a href="https://gitee.com/alasq/tools.git">https://gitee.com/alasq/tools.git</a> </p>
<p>请原谅我把gitee当网盘用☺️</p>
<h1 id="开发用的小工具"><a href="#开发用的小工具" class="headerlink" title="开发用的小工具"></a>开发用的小工具</h1><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>前端开发用的小工具</p>
<h4 id="工具列表-该仓库有安装包的工具"><a href="#工具列表-该仓库有安装包的工具" class="headerlink" title="工具列表(该仓库有安装包的工具)"></a>工具列表(该仓库有安装包的工具)</h4><ul>
<li>Hotkey Commander 检测快捷键冲突</li>
<li>小书匠 写作工具,可直接同步到多个平台</li>
<li>licecap 录屏</li>
<li>ScreenToGif 录Gif还能编辑 gif</li>
<li>fscupture 截屏,测距,取色,录屏(视频),滚动录屏</li>
<li>Snipaste 截屏,粘贴到桌面</li>
<li>everything 文件系统快速搜索</li>
<li>Q-dir 分屏资源管理器</li>
</ul>
<h4 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h4><ul>
<li>chrome &amp; firefox &amp; ie &amp; edge &amp; 360浏览器</li>
<li>Git &amp; Git tortoise 版本管理工具</li>
<li>Node 跑Node代码用</li>
<li>nvm node版本管理工具</li>
<li>Oracle JDK / Open JDK 跑java代码用的</li>
<li>Postman 接口测试工具</li>
<li>XAMPP（Apache+MySQL+PHP+PERL）跑PHP用,还白送一个comcat 一个mysql数据库</li>
<li>Beyond Compare 比较文件夹很好用</li>
<li>WinSCP sftp工具</li>
<li>xShell / mabaxterm ssh远程连接工具</li>
<li>docker windows上不建议装,能用的镜像太少</li>
</ul>
<h3 id="Chrome-插件"><a href="#Chrome-插件" class="headerlink" title="Chrome 插件"></a>Chrome 插件</h3><ul>
<li>RSS 订阅</li>
<li>划词翻译</li>
<li>Vue DevTools</li>
</ul>
<h4 id="IDE"><a href="#IDE" class="headerlink" title="IDE"></a>IDE</h4><ul>
<li>Vscode/WebStorm</li>
<li>HBuilder</li>
<li>微信开发者工具</li>
<li>nodePad++</li>
</ul>
<h4 id="直播三件套"><a href="#直播三件套" class="headerlink" title="直播三件套"></a>直播三件套</h4><ul>
<li>OBS Studio 录屏</li>
<li>Arctime Pro 字幕工具</li>
<li>Adobe Pr 视频编辑(会声会影/拍大师/剪映/爱剪辑)</li>
</ul>
<h3 id="办公软件"><a href="#办公软件" class="headerlink" title="办公软件"></a>办公软件</h3><ul>
<li>word &amp; ppt &amp; excel </li>
<li>pdf</li>
<li>email/foxmail</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>主流的深度学习开源工具</title>
    <url>/2021/04/21/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/2021-4-21-%20%E4%B8%BB%E6%B5%81%E7%9A%84%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%BC%80%E6%BA%90%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>工具名称</th>
<th>维护人员</th>
<th>支持语言</th>
</tr>
</thead>
<tbody><tr>
<td>Caffe</td>
<td>加州大学伯利克分校视觉与学习中心</td>
<td>C++,py,matlab</td>
</tr>
<tr>
<td>Deeplearning4j</td>
<td>Skymind</td>
<td>java,scala,clojure</td>
</tr>
<tr>
<td>Microsoft Cognitive Toolkit( CNTK)</td>
<td>微软研究院</td>
<td>py,c++</td>
</tr>
<tr>
<td>MXNext</td>
<td>分布式机器学习社区</td>
<td>py,c++,go,r,…</td>
</tr>
<tr>
<td>PaddlePaddle</td>
<td>百度</td>
<td>py,c++</td>
</tr>
<tr>
<td>TensorFlow</td>
<td>google</td>
<td>py,c++</td>
</tr>
<tr>
<td>Theano</td>
<td>蒙特利尔大学</td>
<td>py</td>
</tr>
<tr>
<td>Torch</td>
<td></td>
<td>lua,c,  luaJIT</td>
</tr>
<tr>
<td>PyTorch</td>
<td></td>
<td>py</td>
</tr>
</tbody></table>
]]></content>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>《编写可测试javascript》 第二章 复杂度（一）</title>
    <url>/2019/04/03/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/2019-4-3-%E3%80%8A%E7%BC%96%E5%86%99%E5%8F%AF%E6%B5%8B%E8%AF%95javascript%E3%80%8B%20%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ol>
<li>代码大小</li>
<li>JSLint</li>
<li>圈复杂度</li>
<li>重用</li>
<li>扇出</li>
<li>扇入</li>
<li>耦合（耦合度由大到小排列）<br>内容耦合<br>公共耦合<br>控制耦合<br>印记耦合<br>数据耦合<br>无耦合<br>实例化</li>
<li>耦合性度量</li>
<li>现实中耦合</li>
<li>依赖注入</li>
<li>注释<br>YUIDoc JSDoc Docco/Rocco</li>
<li>人工测试</li>
<li>小结</li>
</ol>
<h3 id="1-代码大小"><a href="#1-代码大小" class="headerlink" title="1.代码大小"></a>1.代码大小</h3><p><strong>定义</strong>：函数的行数（包括注释行数）<br>减少该复杂度的方式 <strong>拆函数</strong></p>
<ul>
<li>命令（command）和 查询（query）分离<br>命令（command）：没有return 的函数<br>查询（query）：带return 的函数<h3 id="2-JSLint"><a href="#2-JSLint" class="headerlink" title="2.JSLint"></a>2.JSLint</h3></li>
<li>*规范书写语法**，简洁代码，减少复杂度<h3 id="3-圈复杂度"><a href="#3-圈复杂度" class="headerlink" title="3.圈复杂度"></a>3.圈复杂度</h3></li>
<li>*定义<strong>：获得100%代码覆盖率需要编写的</strong>单元测试个数<strong>（if/else/switch/then 的使用）<br>最佳实践：</strong>方法的圈复杂度应该小于10个**，&gt;25个一定有bug；&gt;100个，bug越改越多<br>检测工具：jscheckstyle<blockquote>
<p><code>npm i -g jscheckstyle</code> </p>
</blockquote>
</li>
</ul>
<p><strong>理论与实践</strong>：<br>我做的项目中有一个判断基站颜色显示的逻辑，绘制canvas站点的fillStyle<br>入参包括</p>
<ul>
<li>是否规划站 黄色</li>
<li>是否现网站 蓝色</li>
<li>是否新建站 绿色</li>
<li>天线型号 2t2t 4t4r 8t8r 16t16r  基于站点类型增加颜色饱和度</li>
<li>是否离线站点  灰色</li>
<li>是否搜索结果  红色<br>这些放在一个方法里面的圈复杂度应该是<br>圈复杂度=天线4<em>站点类型3</em>是否离线2*是否搜索结果2=48<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getColor</span>(<span class="params">siteType,trType,isSearchResult,isOffAir</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> color=<span class="string">&#x27;blue&#x27;</span></span><br><span class="line">  <span class="keyword">if</span>(isSearchResult)&#123;</span><br><span class="line">      <span class="keyword">return</span> color=<span class="string">&#x27;red&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(isOffAir)&#123;</span><br><span class="line">   <span class="keyword">return</span> color=<span class="string">&#x27;gray&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//这里项目中用的if else if else 的嵌套结构，太恶心，这里用switch优化了下</span></span><br><span class="line">  <span class="keyword">switch</span>(siteType)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;current&#x27;</span>:  </span><br><span class="line">           <span class="keyword">if</span>(trType==<span class="string">&#x27;2t2r&#x27;</span>)color=<span class="string">&#x27;淡蓝&#x27;</span></span><br><span class="line">           <span class="keyword">if</span>(trType==<span class="string">&#x27;4t4r&#x27;</span>)color=<span class="string">&#x27;浅蓝&#x27;</span></span><br><span class="line">           <span class="keyword">if</span>(trType==<span class="string">&#x27;8t8r&#x27;</span>)color=<span class="string">&#x27;蓝&#x27;</span></span><br><span class="line">           <span class="keyword">if</span>(trType==<span class="string">&#x27;16t16r&#x27;</span>)color=<span class="string">&#x27;深蓝&#x27;</span></span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;new&#x27;</span>: </span><br><span class="line">           <span class="keyword">if</span>(trType==<span class="string">&#x27;2t2r&#x27;</span>)color=<span class="string">&#x27;淡绿&#x27;</span></span><br><span class="line">           <span class="keyword">if</span>(trType==<span class="string">&#x27;4t24&#x27;</span>)color=<span class="string">&#x27;浅绿&#x27;</span></span><br><span class="line">           <span class="keyword">if</span>(trType==<span class="string">&#x27;8t8r&#x27;</span>)color=<span class="string">&#x27;绿&#x27;</span></span><br><span class="line">           <span class="keyword">if</span>(trType==<span class="string">&#x27;16t16r&#x27;</span>)color=<span class="string">&#x27;深绿&#x27;</span></span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;plan&#x27;</span>: </span><br><span class="line">           <span class="keyword">if</span>(trType==<span class="string">&#x27;2t2r&#x27;</span>)color=<span class="string">&#x27;淡黄&#x27;</span></span><br><span class="line">           <span class="keyword">if</span>(trType==<span class="string">&#x27;4t24&#x27;</span>)color=<span class="string">&#x27;浅黄&#x27;</span></span><br><span class="line">           <span class="keyword">if</span>(trType==<span class="string">&#x27;8t8r&#x27;</span>)color=<span class="string">&#x27; 黄&#x27;</span></span><br><span class="line">           <span class="keyword">if</span>(trType==<span class="string">&#x27;16t16r&#x27;</span>)color=<span class="string">&#x27;深黄&#x27;</span></span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">default</span>:</span><br><span class="line">          </span><br><span class="line">  &#125;</span><br><span class="line"> <span class="keyword">return</span> color</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
尝试降低上面这个方法的圈复杂度<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">getColor</span>(<span class="params">siteType,trType,isSearchResult,isOffAir</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> colorMap=&#123;</span><br><span class="line">    current:&#123;</span><br><span class="line">   <span class="string">&#x27;2t2r&#x27;</span>:<span class="string">&#x27;淡蓝&#x27;</span>,</span><br><span class="line">   <span class="string">&#x27;4t4r&#x27;</span>:<span class="string">&#x27;浅蓝&#x27;</span>,</span><br><span class="line">   <span class="string">&#x27;8t8r&#x27;</span>:<span class="string">&#x27;蓝&#x27;</span>,</span><br><span class="line">   <span class="string">&#x27;16t16r&#x27;</span>:<span class="string">&#x27;深蓝&#x27;</span></span><br><span class="line">&#125;,</span><br><span class="line">    <span class="string">&#x27;new&#x27;</span>:&#123;</span><br><span class="line">   <span class="string">&#x27;2t2r&#x27;</span>:<span class="string">&#x27;淡蓝&#x27;</span>,</span><br><span class="line">   <span class="string">&#x27;4t4r&#x27;</span>:<span class="string">&#x27;浅蓝&#x27;</span>,</span><br><span class="line">   <span class="string">&#x27;8t8r&#x27;</span>:<span class="string">&#x27;蓝&#x27;</span>,</span><br><span class="line">   <span class="string">&#x27;16t16r&#x27;</span>:<span class="string">&#x27;深蓝&#x27;</span></span><br><span class="line">&#125;,</span><br><span class="line">    plan:&#123;</span><br><span class="line">   <span class="string">&#x27;2t2r&#x27;</span>:<span class="string">&#x27;淡蓝&#x27;</span>,</span><br><span class="line">   <span class="string">&#x27;4t4r&#x27;</span>:<span class="string">&#x27;浅蓝&#x27;</span>,</span><br><span class="line">   <span class="string">&#x27;8t8r&#x27;</span>:<span class="string">&#x27;蓝&#x27;</span>,</span><br><span class="line">   <span class="string">&#x27;16t16r&#x27;</span>:<span class="string">&#x27;深蓝&#x27;</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="keyword">var</span> color=<span class="string">&#x27;blue&#x27;</span></span><br><span class="line">  <span class="keyword">if</span>(isSearchResult)&#123;</span><br><span class="line">      <span class="keyword">return</span> color=<span class="string">&#x27;red&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(isOffAir)&#123;</span><br><span class="line">   <span class="keyword">return</span> color=<span class="string">&#x27;gray&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">    color =colorMap[siteType][trType]</span><br><span class="line">  &#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;colorMap 中没有定义这个颜色&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> color</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
后续如果增加新的站点类型或者天线类型，只要维护mapColor这个hash表就行了，不会再增加代码的圈复杂度，代码的可读与可维护性大大增强<h3 id="4-重用"><a href="#4-重用" class="headerlink" title="4.重用"></a>4.重用</h3></li>
<li><em>同样的代码不要写两次</em>* 没什么好说的，就像出轨有了第一次就一定有第二次……<br>另外就是能使用框架，就不要自己造轮子<h3 id="5-扇出Fan-Out（这个词好难理解），对应的还有扇入Fan-In"><a href="#5-扇出Fan-Out（这个词好难理解），对应的还有扇入Fan-In" class="headerlink" title="5.扇出Fan-Out（这个词好难理解），对应的还有扇入Fan-In"></a>5.扇出Fan-Out（这个词好难理解），对应的还有扇入Fan-In</h3></li>
<li>*定义**：函数直接或间接使用的模块或者对象数量<br>个人理解：<code>扇出就衡量一个函数做多少事。类比于人做事情，就是这个人指挥别人做的+他自己做的</code></li>
<li>*复杂度计算公式**：<code> (fan_in * fan_out)²</code></li>
<li>*扇出计算公式**：扇出=内部流程数量（指挥别人做的）+所更新数据结构数量（自己做的）</li>
<li>*最佳实践<strong>：函数的</strong>扇出应该小于等于4**，绝对不要大于7，超过的话就需要重构<br>解决方式：拆分模块，依赖注入<br>例子：requirejs定义一个模块，下面的就需要拆分了<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//拆分前</span></span><br><span class="line">define([a,b,c,d,e,f,g,h],<span class="function"><span class="keyword">function</span>(<span class="params">a,b,c,d,e,f,g,h</span>)</span>&#123;<span class="comment">//定义一个模块，依赖了7个小模块</span></span><br><span class="line"><span class="keyword">var</span> <span class="built_in">module</span>=&#123;</span><br><span class="line">    a,b,c,d,e,f,g,h</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">module</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//拆分后</span></span><br><span class="line">define([],<span class="function"><span class="keyword">function</span>(<span class="params">a,b,c,d</span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">SubModule</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.a=<span class="keyword">new</span> a()</span><br><span class="line">        <span class="built_in">this</span>.b=<span class="keyword">new</span> b()</span><br><span class="line">        <span class="built_in">this</span>.c=<span class="keyword">new</span> c()</span><br><span class="line">        <span class="built_in">this</span>.d=<span class="keyword">new</span> d()</span><br><span class="line">    &#125;</span><br><span class="line">    subModule.prototype.getA=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> <span class="built_in">this</span>.a&#125;</span><br><span class="line">    subModule.prototype.getB=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> <span class="built_in">this</span>.b&#125;</span><br><span class="line">    subModule.prototype.getC=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> <span class="built_in">this</span>.c&#125;</span><br><span class="line">    subModule.prototype.getD=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> <span class="built_in">this</span>.d&#125;</span><br><span class="line">    <span class="keyword">return</span> subModule</span><br><span class="line">&#125;)</span><br><span class="line">define([subModule,e,f,g,h],<span class="function"><span class="keyword">function</span>(<span class="params">subModule,e,f,g,h</span>)</span>&#123;<span class="comment">//仅仅减小扇出，但无实际意义</span></span><br><span class="line"><span class="keyword">var</span> <span class="built_in">module</span>=&#123;</span><br><span class="line">    a:subModule.getA(),</span><br><span class="line">    b:subModule.getB(),</span><br><span class="line">    c:subModule.getC(),</span><br><span class="line">    d:subModule.getD(),</span><br><span class="line">    e,f,g,h</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">module</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="6-扇入（入参？）"><a href="#6-扇入（入参？）" class="headerlink" title="6.扇入（入参？）"></a>6.扇入（入参？）</h3>定义：过程A的扇入是  过程A的内部流程数量 与 欲从过程A中获取信息的数据结构总和<br>高扇入复用程度越高，底层函数应该扇入高，扇出低。上层函数应该扇入低，扇出高。这样能保证函数的复杂度都比较低。<h3 id="7-耦合"><a href="#7-耦合" class="headerlink" title="7.耦合"></a>7.耦合</h3><a href="https://www.jianshu.com/p/33faf9d810f0">《编写可测试javascript》 第二章 复杂度（二）</a></li>
</ul>
]]></content>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>《编写可测试javascript》 第三章</title>
    <url>/2019/04/06/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/2019-4-6-%E3%80%8A%E7%BC%96%E5%86%99%E5%8F%AF%E6%B5%8B%E8%AF%95javascript%E3%80%8B%20%E7%AC%AC%E4%B8%89%E7%AB%A0/</url>
    <content><![CDATA[<p>通过事件解耦和隔离代码是javascript的一个原生特性,参考浏览器的DOM事件模型</p>
<h1 id="3-1-基于事件的好处"><a href="#3-1-基于事件的好处" class="headerlink" title="3.1 基于事件的好处"></a>3.1 基于事件的好处</h1><ul>
<li>应用程序都与消息传递有关</li>
<li>拿到其他对象的消息<br>全局对象（易污染）<br>函数参数传入（参数过多）<br>函数参数注入（要维护注入列表）<br>局部初始化（紧耦合）</li>
<li>函数是javascript的第一公民</li>
<li>浏览器 DOM是事件模型</li>
<li>nodejs 利用回调实现异步编程<h1 id="3-2事件集线器"><a href="#3-2事件集线器" class="headerlink" title="3.2事件集线器"></a>3.2事件集线器</h1></li>
<li>一个中央处理器（110接警中心）</li>
<li>向中央处理器注册事件的处理器（派出所，交警，刑警，消防，120急救中心，等）</li>
<li>事件触发器（打110报警的用户）<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">eventHub.fire(<span class="string">&#x27;着火了&#x27;</span>，&#123;<span class="attr">address</span>:<span class="string">&#x27;南山腾讯大厦&#x27;</span>，leave:<span class="string">&#x27;烧了10层&#x27;</span>&#125;)</span><br><span class="line">eventHub.listen(<span class="string">&#x27;着火了&#x27;</span>，killFire)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">killFire</span>(<span class="params">msg</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`出动消防车到<span class="subst">$&#123;msg.address&#125;</span>去灭火，火灾等级<span class="subst">$&#123;leave&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
集线器属于<strong>公共耦合</strong>，但在集线器对象里，没有共享的状态<h2 id="3-2-1使用事件集线器"><a href="#3-2-1使用事件集线器" class="headerlink" title="3.2.1使用事件集线器"></a>3.2.1使用事件集线器</h2><h2 id="3-2-2事件的响应"><a href="#3-2-2事件的响应" class="headerlink" title="3.2.2事件的响应"></a>3.2.2事件的响应</h2><h2 id="3-2-3基于事件的架构与MVC架构-思想一致"><a href="#3-2-3基于事件的架构与MVC架构-思想一致" class="headerlink" title="3.2.3基于事件的架构与MVC架构(思想一致)"></a>3.2.3基于事件的架构与MVC架构(思想一致)</h2>MVC倡导 关注点分离与模块化，基于事件的架构都满足<br>事件集线器==Controller<br>事件传递的数据==Model数据库的行<br>事件推送的数据==View查询模型获得数据<h2 id="3-2-4基于事件架构与面向对象编程（不冲突，可以一起用）"><a href="#3-2-4基于事件架构与面向对象编程（不冲突，可以一起用）" class="headerlink" title="3.2.4基于事件架构与面向对象编程（不冲突，可以一起用）"></a>3.2.4基于事件架构与面向对象编程（不冲突，可以一起用）</h2>面向对象=》继承耦合<br>面向对象=》没有链式交互对象<br>事件架构=》数据都是私有的，仅通过事件API暴露<br>事件架构=》没有生命周期问题，对象存在于整个应用程序生命周期，不需要析构<h2 id="3-2-5-基于事件的架构与软件及服务（促进关系）"><a href="#3-2-5-基于事件的架构与软件及服务（促进关系）" class="headerlink" title="3.2.5 基于事件的架构与软件及服务（促进关系）"></a>3.2.5 基于事件的架构与软件及服务（促进关系）</h2>软件及服务（SaaS），每个独立的服务都可以加入事件集线器</li>
</ul>
<h1 id="3-3-web应用程序"><a href="#3-3-web应用程序" class="headerlink" title="3.3 web应用程序"></a>3.3 web应用程序</h1><p>web应用程序大多与web服务器搅合在一起<br>让事件集线器成为web应用程序的中心，而不是web服务器<br>使用socke.io可以解决http同源的问题</p>
<h1 id="3-4测试基于事件的架构"><a href="#3-4测试基于事件的架构" class="headerlink" title="3.4测试基于事件的架构"></a>3.4测试基于事件的架构</h1><p>略……</p>
<h1 id="3-5基于事件的架构说明"><a href="#3-5基于事件的架构说明" class="headerlink" title="3.5基于事件的架构说明"></a>3.5基于事件的架构说明</h1><ol>
<li>可伸缩性<br>集线器宕机，则整个app宕机，所以，搞一组集线器负载匀衡</li>
<li>广播<br>广播给所有客户端会产生大量通信流量，所以慎用</li>
<li>运行时检查<br>函数和方法名 拼写错误，编译器能检查到，但是事件是字符串不能检查到，建议使用枚举值</li>
<li>安全性<br>事件集线器实现“可信任”客户端身份验证<br>socket.io支持数据加密</li>
<li>状态<br>web服务器通过会话cookie记录状态<br>事件集线器本身会将会话注入到事件中</li>
</ol>
<h1 id="3-6更智能的集线器，事件交换机"><a href="#3-6更智能的集线器，事件交换机" class="headerlink" title="3.6更智能的集线器，事件交换机"></a>3.6更智能的集线器，事件交换机</h1><p>事件分组：广播，单播<br>特性：节省网络带宽，自动防故障安全部署</p>
<h2 id="3-6-1部署"><a href="#3-6-1部署" class="headerlink" title="3.6.1部署"></a>3.6.1部署</h2><p>新版本部署=重启web服务（一般的web应用）<br>目标：模块完全独立于web服务的部署（跟微服务的架构很像啊）<br>条件：停用事件监听而不删除事件<br>方式：事件交换机</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">eventSwitch.on(<span class="string">&#x27;depositMoney&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">  cash+=data.depositAmount;</span><br><span class="line">  eventSwitch.emit(<span class="string">&#x27;depositMoney&#x27;</span>,cash)</span><br><span class="line">&#125;,&#123;<span class="attr">type</span>:<span class="string">&#x27;unicast&#x27;</span>&#125;)<span class="comment">//告知注册的是单播事件</span></span><br><span class="line"><span class="comment">//eventClient:done 这个事件不能由已连接的客户端触发</span></span><br><span class="line"><span class="comment">//单播</span></span><br><span class="line">eventHub.on(<span class="string">&#x27;eventClient:done&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">  process.exit(<span class="number">0</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//广播</span></span><br><span class="line">eventHub.on(<span class="string">&#x27;eventClient:done&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">  eventHub.removeAllListeers(event)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="3-6-2一种实现"><a href="#3-6-2一种实现" class="headerlink" title="3.6.2一种实现"></a>3.6.2一种实现</h2><p><a href="https://github.com/zzo/EventHub">https://github.com/zzo/EventHub</a><br><code>npm install EventHub</code>安装<br><code>npm start EventHub</code>启动 默认监听5883端口</p>
<h2 id="3-6-3-会话"><a href="#3-6-3-会话" class="headerlink" title="3.6.3 会话"></a>3.6.3 会话</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">eventHub=<span class="built_in">require</span>(<span class="string">&#x27;EventHub/clients/server/eventClient.js&#x27;</span>)</span><br><span class="line">.getClientHub(<span class="string">&#x27;http://localhost:5886?token=secret&#x27;</span>)</span><br><span class="line">eventHub.on(<span class="string">&#x27;user&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line"> <span class="keyword">var</span> sessionID=obj[<span class="string">&#x27;eventHub:session&#x27;</span>]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="3-6-4-可拓展性"><a href="#3-6-4-可拓展性" class="headerlink" title="3.6.4 可拓展性"></a>3.6.4 可拓展性</h2><p>socket.io 支持多种客户端，多种语言，不仅仅是javascript<br>一个例子<a href="https://github.com/zzo/BidSilent">https:github.com/zzo/BidSilent </a></p>
<h2 id="3-7-小结"><a href="#3-7-小结" class="headerlink" title="3.7 小结"></a>3.7 小结</h2><ul>
<li><p>基于事件的架构<br>高度模块化<br>松耦合<br>小依赖<br>高可重用性<br>便于创建可测试javascript</p>
</li>
<li><p>事件集线器构建在 socket.io 上</p>
</li>
<li><p>MVC实际上是用事件进行了增强</p>
</li>
<li><p>基于事件的架构开启了软件即服务,根据需要对小而独立的功能进行动态增删</p>
</li>
<li><p>使用事件交换机部署基于事件的模块非常容易,允许单独关闭旧模块,而不丢任何事件</p>
</li>
<li><p>测试已经隔离的模块更简单</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>466时间管理</title>
    <url>/2021/05/06/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/2021-5-6-466%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h2 id="时间的4个特性"><a href="#时间的4个特性" class="headerlink" title="时间的4个特性"></a>时间的4个特性</h2><ul>
<li>无法开源</li>
<li>无法节流</li>
<li>无法取代</li>
<li>无法再生</li>
</ul>
<h2 id="时间管理6原则"><a href="#时间管理6原则" class="headerlink" title="时间管理6原则"></a>时间管理6原则</h2><p><img src="https://upload-images.jianshu.io/upload_images/8156292-eca9e181b2a68dfa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="时间管理6原则"></p>
<h2 id="时间管理6步骤——做正确的事"><a href="#时间管理6步骤——做正确的事" class="headerlink" title="时间管理6步骤——做正确的事"></a>时间管理6步骤——做正确的事</h2><p><img src="https://upload-images.jianshu.io/upload_images/8156292-7efb944b9c0b0b7a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="时间管理6步骤"></p>
<h3 id="四象限原则"><a href="#四象限原则" class="headerlink" title="四象限原则"></a>四象限原则</h3><p><img src="https://upload-images.jianshu.io/upload_images/8156292-779dfccb034b172c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="四象限"></p>
<h3 id="每天时间安排-9宫格"><a href="#每天时间安排-9宫格" class="headerlink" title="每天时间安排(9宫格)"></a>每天时间安排(9宫格)</h3><p><img src="https://upload-images.jianshu.io/upload_images/8156292-7844c69c9478bc4c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="每天时间安排"></p>
]]></content>
      <tags>
        <tag>项目管理</tag>
      </tags>
  </entry>
  <entry>
    <title>产品生命周期</title>
    <url>/2021/09/25/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E4%BA%A7%E5%93%81%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    <content><![CDATA[<ol>
<li>GA 可全球发布</li>
<li>EOP 停止生产</li>
<li>EOM 停止销售</li>
<li>EOS 停止服务</li>
</ol>
]]></content>
      <tags>
        <tag>项目管理</tag>
      </tags>
  </entry>
  <entry>
    <title>华为研发项目管理（RDPM）中的术语</title>
    <url>/2021/09/09/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E5%8D%8E%E4%B8%BA%E7%A0%94%E5%8F%91%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%EF%BC%88RDPM%EF%BC%89%E4%B8%AD%E7%9A%84%E6%9C%AF%E8%AF%AD/</url>
    <content><![CDATA[<h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><table>
<thead>
<tr>
<th>术语</th>
<th>全称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>RDPM</td>
<td>research and development project management methods</td>
<td>华为PSST体系的研发项目管理方法</td>
</tr>
<tr>
<td>CP</td>
<td>check point</td>
<td>评审点</td>
</tr>
<tr>
<td>PM</td>
<td>Project Manager</td>
<td>项目经理</td>
</tr>
<tr>
<td>PL</td>
<td>Project Leader</td>
<td>项目组长</td>
</tr>
<tr>
<td>SE</td>
<td></td>
<td>系统工程师（出方案的)</td>
</tr>
<tr>
<td>PG</td>
<td></td>
<td>程序员</td>
</tr>
<tr>
<td>QA</td>
<td>Quality Assurance</td>
<td>质量保证</td>
</tr>
<tr>
<td>UI</td>
<td></td>
<td>平面设计师  （画图的）</td>
</tr>
<tr>
<td>UX</td>
<td></td>
<td>交互设计师</td>
</tr>
<tr>
<td>UCD</td>
<td></td>
<td>用户体验设计中心</td>
</tr>
<tr>
<td>PMBOK</td>
<td>Project Management Body of knowledge</td>
<td></td>
</tr>
<tr>
<td>PDU</td>
<td>Product development Unit</td>
<td>产品部</td>
</tr>
<tr>
<td>PMO</td>
<td>project Management office</td>
<td>项目管理办公室，设置在PDU及以上层面</td>
</tr>
<tr>
<td>PO</td>
<td>project office</td>
<td>项目办公室，职能同PMO</td>
</tr>
<tr>
<td>RDR</td>
<td>R&amp;D Review</td>
<td>RDR评审点,RDR0-RDR5共6个检查点</td>
</tr>
<tr>
<td>EER</td>
<td>Early Execution Review</td>
<td>提前执行评审点，在RDR2前执行；</td>
</tr>
<tr>
<td>WBS</td>
<td>work breakdown structure</td>
<td>工作分解结构</td>
</tr>
<tr>
<td>PMI</td>
<td>Project management institue</td>
<td>全球领先的项目管理协会</td>
</tr>
<tr>
<td>PMBOK</td>
<td>Project Management Body of knowledge</td>
<td></td>
</tr>
<tr>
<td>Project Portfolio Owner</td>
<td></td>
<td>项目组合负责人，在多项目情况下的管理者(调整优先级等)</td>
</tr>
<tr>
<td>Project sponsor</td>
<td></td>
<td>赞助人，以资金或其它方式为项目提供财务资源的个人或团队；</td>
</tr>
<tr>
<td>OSG</td>
<td>project Operation steering group</td>
<td>项目运作指导团队</td>
</tr>
<tr>
<td>ROI</td>
<td></td>
<td>投资回报率</td>
</tr>
<tr>
<td>CDP</td>
<td></td>
<td>charter的开发过程；</td>
</tr>
<tr>
<td>IPMT/BMT/SPDT</td>
<td></td>
<td>决策者</td>
</tr>
<tr>
<td>E2E</td>
<td>end to end</td>
<td>端到端</td>
</tr>
<tr>
<td>PCR</td>
<td>project change review</td>
<td>项目更改评审</td>
</tr>
<tr>
<td>CCB</td>
<td>change control board</td>
<td>变更控制委员会</td>
</tr>
<tr>
<td>PSST</td>
<td></td>
<td>华为产品与解决方案体系；</td>
</tr>
<tr>
<td>(O/SBP)</td>
<td></td>
<td>商业计划</td>
</tr>
<tr>
<td>SME</td>
<td></td>
<td>领域专家</td>
</tr>
<tr>
<td>TR</td>
<td>technical review</td>
<td>技术评审点</td>
</tr>
<tr>
<td>DCP</td>
<td></td>
<td>决策评审点</td>
</tr>
<tr>
<td>ADCP</td>
<td></td>
<td>可获得性DCP</td>
</tr>
<tr>
<td>CDCP</td>
<td></td>
<td>概念DCP</td>
</tr>
<tr>
<td>PDCP</td>
<td></td>
<td>计划DCP</td>
</tr>
<tr>
<td>Charter</td>
<td></td>
<td>项目启动任务书</td>
</tr>
<tr>
<td>GA</td>
<td>General availability</td>
<td>项目正式发布</td>
</tr>
<tr>
<td>EOM</td>
<td>End of marketing</td>
<td>产品停止销售</td>
</tr>
<tr>
<td>EOP</td>
<td>End of Producting</td>
<td>产品停止生产</td>
</tr>
<tr>
<td>EOFS</td>
<td>End of full support</td>
<td>停止为发布软件系统开发新补丁</td>
</tr>
<tr>
<td>EOS</td>
<td>End of service&support;</td>
<td>产品停止服务</td>
</tr>
<tr>
<td>V/R/C</td>
<td>Version/Release/Modification</td>
<td>类似于软件包的大版本，小版本，补丁版本</td>
</tr>
<tr>
<td>SPDT</td>
<td>Solution Program Development Team</td>
<td>（产品）解决方案开发团队</td>
</tr>
</tbody></table>
<h2 id="项目运作指导团队-（OSG）-组成部分"><a href="#项目运作指导团队-（OSG）-组成部分" class="headerlink" title="项目运作指导团队 （OSG） 组成部分"></a>项目运作指导团队 （OSG） 组成部分</h2><ul>
<li>PUD产品部部长</li>
<li>PO采购部部长</li>
<li>PDT/SPDT 开发经理 </li>
<li>产品部职能部门主管（设计，开发，集成与验证测试，质量，资料，维护）</li>
</ul>
<h2 id="项目生命周期"><a href="#项目生命周期" class="headerlink" title="项目生命周期"></a>项目生命周期</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">立项准备--&gt; 概念 --&gt;计划--&gt;开发--&gt;验证--&gt;发布--&gt;收尾-.-&gt;GA-.-&gt;EOM-.-&gt;EOP-.-&gt;EOFS-.-&gt;EOS</span><br></pre></td></tr></table></figure>

<h2 id="项目组成员"><a href="#项目组成员" class="headerlink" title="项目组成员"></a>项目组成员</h2><ul>
<li>QA 质量保证 （项目质量）</li>
<li>POP 项目助理（工时，人力，进度，会议，需求跟踪，问题跟踪）</li>
<li>CME/CIE 研发项目配置管理工作 （流水线，仓库权限，BPI信息维护，版本管理，版本变更）</li>
<li>职能部门经理</li>
<li>执行小组<ul>
<li>设计组</li>
<li>开发组</li>
<li>测试组（test beta）</li>
<li>验收组 (uat prod)</li>
<li>资料组</li>
</ul>
</li>
</ul>
<h2 id="知识域"><a href="#知识域" class="headerlink" title="知识域"></a>知识域</h2><ul>
<li>价值管理</li>
<li>范围管理</li>
<li>质量管理 成本管理 时间管理</li>
<li>人力资源管理 采购管理 财务管理 风险管理</li>
<li>整体管理（沟通管理）</li>
</ul>
]]></content>
      <tags>
        <tag>项目管理</tag>
      </tags>
  </entry>
  <entry>
    <title>模块设计工程师(MDE)</title>
    <url>/2021/11/04/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E6%A8%A1%E5%9D%97%E8%AE%BE%E8%AE%A1%E5%B7%A5%E7%A8%8B%E5%B8%88/</url>
    <content><![CDATA[<p>最近在做项目组MDE关键角色认证评审的工作,记录下</p>
<h2 id="模块设计工程师"><a href="#模块设计工程师" class="headerlink" title="模块设计工程师"></a>模块设计工程师</h2><p>MDE 是 Module Design Engineer 的缩写。</p>
<h2 id="MDE-任职要求"><a href="#MDE-任职要求" class="headerlink" title="MDE 任职要求"></a>MDE 任职要求</h2><ol>
<li>（需求处理）完成需求对齐,分解,输出概要设计(这个有些是SE出),详细设计</li>
<li>（模块设计）考虑模块复用,梳理内部外部依赖,确定目录结构,数据流向,对代码安全,代码质量负责</li>
<li>（持续优化）技术攻关,代码重构,废弃功能管理,历史需求整理,文档优化</li>
<li>（知识分享）能总结提供开发文档，提供技术培训</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>MDE 除了编码能力外,还需要良好的理解能力,沟通能力,以及协助他人的一个意愿。不再局限于完成自己的开发任务，需要对项目中的某个模块负责。</p>
]]></content>
      <tags>
        <tag>项目管理</tag>
      </tags>
  </entry>
  <entry>
    <title>版本火车</title>
    <url>/2021/09/16/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E7%89%88%E6%9C%AC%E7%81%AB%E8%BD%A6/</url>
    <content><![CDATA[<h1 id="版本火车"><a href="#版本火车" class="headerlink" title="版本火车"></a>版本火车</h1><p>一个比较成熟的软件系统，发版本的时间基本都是固定的，就像列车的时刻表。需求就是需要乘车的人。在进行版本计划的时候。就把相关需求列在版本火车的区间内。如果需求能够按时完成，赶上车就上线。如果测试不够充分，或者需求有变更，就敢下一趟上线的火车。</p>
<p>版本火车适合需求之间没有依赖。成熟度比较高的软件。</p>
<h1 id="敏捷开发"><a href="#敏捷开发" class="headerlink" title="敏捷开发"></a>敏捷开发</h1><p>与版本火车相对的就是敏捷开发。<br>敏捷开发对开发人员的素质要求比较高。因为测试时间短，主要依靠开发人员的水平。适合需求频繁变更，需求间高度依赖的启动阶段的项目。</p>
]]></content>
      <tags>
        <tag>项目管理</tag>
      </tags>
  </entry>
  <entry>
    <title>范围管理</title>
    <url>/2021/09/16/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E8%8C%83%E5%9B%B4%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<p>范围管理分两部分，第一是需求管理，项目组单位时间的产出是固定的。哪些需求可以砍，哪些需求可以延期，都是范围管理的内容。<br>范围管理的另外一部分，是标识项目交付与验收标准。</p>
<blockquote>
<p>主要确定 业务需求，交付时间，验收标准，交付件 就差不多了</p>
</blockquote>
<p>做好范围管理的核心是做好需求变更的控制，一定要评估变更对进度，成本，质量的影响，才能决定需求变更。</p>
<h2 id="需求获取"><a href="#需求获取" class="headerlink" title="需求获取"></a>需求获取</h2><p>外部需求：来自用户<br>内部需求：来自开发与测试（这个容易被忽视）</p>
<h2 id="需求分析与优先级"><a href="#需求分析与优先级" class="headerlink" title="需求分析与优先级"></a>需求分析与优先级</h2><ul>
<li>what/why 目的是什么，要解决什么，背景是什么</li>
<li>who 主要看这个需求是普遍需求还是个别需求</li>
<li>when 需求要什么时候满足</li>
<li>优先级，必选，可选，是否可替代</li>
<li>how 客户期待推荐的解决方案</li>
</ul>
<blockquote>
<p>总的来说就是 投资回报高 &gt; 提升用户满意的 &gt; 提升竞争力的 &gt; 能做的</p>
</blockquote>
]]></content>
      <tags>
        <tag>项目管理</tag>
      </tags>
  </entry>
  <entry>
    <title>项目管理/影响力</title>
    <url>/2021/05/07/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E5%BD%B1%E5%93%8D%E5%8A%9B/</url>
    <content><![CDATA[<h2 id="做事情成功的要素"><a href="#做事情成功的要素" class="headerlink" title="做事情成功的要素"></a>做事情成功的要素</h2><ol>
<li>自己想不想做</li>
<li>环境允不允许</li>
<li>能不能做到</li>
</ol>
<h2 id="如何说服他人"><a href="#如何说服他人" class="headerlink" title="如何说服他人"></a>如何说服他人</h2><p>晓之以理。动之以情。诱之以利。绳之以法。胁之以威。</p>
<ul>
<li>晓之以理的难处是，个人认知的不同,很难达到一致</li>
<li>动之以情的问题是，感情培养的成本很高。</li>
<li>诱之以利的问题是，公司给的政策是有限的。</li>
<li>绳之以法，工作中基本上用不到</li>
<li>胁之以威，“你给我滚！”  “好的！老子不干了！！”</li>
</ul>
<p>管理真正能用的就是晓之以理动之以情两种，因为成本高，所以要做好一定很累。</p>
<h2 id="影响他人的方法"><a href="#影响他人的方法" class="headerlink" title="影响他人的方法"></a>影响他人的方法</h2><ol>
<li>能给人带来好处，激励</li>
<li>能给人带来痛苦，惩罚</li>
</ol>
<h2 id="沟通方式方法"><a href="#沟通方式方法" class="headerlink" title="沟通方式方法"></a>沟通方式方法</h2><ol>
<li>客观阐述事实</li>
<li>陈述自己的观点</li>
<li>表示愿意协助改进</li>
<li>商讨解决办法</li>
</ol>
<h2 id="人与人的关系"><a href="#人与人的关系" class="headerlink" title="人与人的关系"></a>人与人的关系</h2><ol>
<li>人际关系是流体，有波动性</li>
<li>需要你的时候，关系就会变好</li>
<li>不需要的时候，关系会被冷落</li>
</ol>
<h2 id="性格分析方法-DISC"><a href="#性格分析方法-DISC" class="headerlink" title="性格分析方法 DISC"></a>性格分析方法 DISC</h2><p>根据人做事情的快慢，人际交往的意愿。大致可分为四类。</p>
<ul>
<li>D型人格：孙悟空 支配型 自己+环境</li>
<li>I型人格：猪八戒 影响型 自己+他人</li>
<li>S型人格：沙悟净 稳健型 他人</li>
<li>C型人格：唐三丈 谨慎型 环境</li>
</ul>
<h2 id="沟通技巧——时间换空间"><a href="#沟通技巧——时间换空间" class="headerlink" title="沟通技巧——时间换空间"></a>沟通技巧——时间换空间</h2><p>有时候，不好处理的事情，可以先放一放，冷一冷。情绪爆炸的时候，不是沟通的好时机。</p>
<h2 id="管理者要做到"><a href="#管理者要做到" class="headerlink" title="管理者要做到"></a>管理者要做到</h2><p>见人说人话，见鬼说鬼话。斗战圣佛有72般变化，以应对不同的场景。也能保持一个战心。自我，本我，超我。</p>
]]></content>
      <tags>
        <tag>项目管理</tag>
      </tags>
  </entry>
  <entry>
    <title>风险管理</title>
    <url>/2021/09/16/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E9%A3%8E%E9%99%A9%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h1 id="项目管理风险识别-CheckList"><a href="#项目管理风险识别-CheckList" class="headerlink" title="项目管理风险识别 CheckList"></a>项目管理风险识别 CheckList</h1><table>
<thead>
<tr>
<th>风险分类</th>
<th>风险检查项</th>
</tr>
</thead>
<tbody><tr>
<td>项目环境</td>
<td>是否及时建立适合项目运作的环境（办公设备，数据库申请）</td>
</tr>
<tr>
<td>人员技能</td>
<td>PDT成员缺少必要的项目管理技能，导致项目管理无法有效进行</td>
</tr>
<tr>
<td>人员技能</td>
<td>各级项目经理是否有必备的或丰富的项目管理技能和经验</td>
</tr>
<tr>
<td>人员技能</td>
<td>是否有安排项目经理的管理培训来提升团队管理能力，提高管理效率</td>
</tr>
<tr>
<td>异地管理</td>
<td>是否存在异地开发情况</td>
</tr>
<tr>
<td>异地管理</td>
<td>如有，是否建立了可用的异地管理体系来支撑异地的日常管理工作</td>
</tr>
<tr>
<td>流程执行</td>
<td>是否在项目开始前，就考虑了项目应该遵守的流程</td>
</tr>
<tr>
<td>流程执行</td>
<td>是否考虑了项目的特殊性，提出需要裁剪的流程建议，包括需要遵从的标准</td>
</tr>
<tr>
<td>流程执行</td>
<td>是否提前根据各评审点的要求来准备相关文档</td>
</tr>
<tr>
<td>流程执行</td>
<td>是否将各评审点的要求来分解，并提前考虑在过程中进行满足</td>
</tr>
</tbody></table>
<blockquote>
<p>个人理解：风险主要集中在项目前的准备，以及流程的制定。制定流程应该充分讨论，得到大家的认可才能更好的实施。各个评审点基本上都是用来把控风险的，所以要提前准备。</p>
</blockquote>
<h1 id="风险管理表"><a href="#风险管理表" class="headerlink" title="风险管理表"></a>风险管理表</h1><table>
<thead>
<tr>
<th>类别</th>
<th>风险描述</th>
<th>预防措施</th>
<th>应急措施</th>
<th>当前状态</th>
<th>风险系数</th>
<th>责任人</th>
<th>开始时间</th>
<th>结束时间</th>
<th>当前进展</th>
<th>发生概率</th>
<th>影响度</th>
</tr>
</thead>
<tbody><tr>
<td>进度/人力/质量/技术</td>
<td>设计人员还在招聘中</td>
<td>优先根据低保真完成功能模块，等设计稿出来后再修改样式</td>
<td>提前从xx项目协调一名设计人员到，一周内招聘无进展</td>
<td>open</td>
<td>0.6</td>
<td>张三</td>
<td>2021年9月16日</td>
<td>2021年10月16日</td>
<td>xx项目设计人员已协调到位</td>
<td>中</td>
<td>高</td>
</tr>
</tbody></table>
<blockquote>
<p>风险需要从客户的角度去看。风险可以规避，转移，减轻。制定风险计划的时候，应该拉上责任人一起。</p>
</blockquote>
]]></content>
      <tags>
        <tag>项目管理</tag>
      </tags>
  </entry>
  <entry>
    <title>tensorflow环境搭建</title>
    <url>/2021/04/24/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/tensorflow/2021-4-24-tensorflow%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h2 id="TensorFlow-的两个依赖"><a href="#TensorFlow-的两个依赖" class="headerlink" title="TensorFlow 的两个依赖"></a>TensorFlow 的两个依赖</h2><h3 id="Protocol-Buffer"><a href="#Protocol-Buffer" class="headerlink" title="Protocol Buffer"></a>Protocol Buffer</h3><p>结构化处理工具,比json,xml更小,解析更快</p>
<h3 id="Bazel-自动化构建工具-类似于maven"><a href="#Bazel-自动化构建工具-类似于maven" class="headerlink" title="Bazel 自动化构建工具,类似于maven"></a>Bazel 自动化构建工具,类似于maven</h3><ul>
<li>BUILD  文件用于表示构建目标</li>
<li>WORKSPACE 文件用于标记外部依赖</li>
</ul>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>三种方式安装: docker  pip 源码<br>我们使用pip来安装</p>
<h3 id="安装-Anaconda"><a href="#安装-Anaconda" class="headerlink" title="安装 Anaconda"></a>安装 Anaconda</h3><p>python的发行版,除了python,还包含了很多常用的关于科学计算的库<br>我参考这篇文章安装成功的 <a href="https://www.cnblogs.com/ljysy/p/10660885.html">https://www.cnblogs.com/ljysy/p/10660885.html</a></p>
<p>我这里下载的是 Anaconda 版本是 Anaconda3-5.3.1-Windows-x86_64.exe 对应的 python3.7.0</p>
<ol>
<li><code>conda create -n tensorflow python=3.7.0</code> 创建了一个独立的tensorflow的工作空间,在这个空间内使用的python版本为3.7.0</li>
<li><code>conda activate tensorflow</code> 激活这个名为tensorflow空间</li>
<li><code>pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple</code>  在空间内配置pip的镜像源</li>
<li><code>pip install tensorflow</code></li>
</ol>
<h3 id="Anaconda-vscode-配置"><a href="#Anaconda-vscode-配置" class="headerlink" title="Anaconda + vscode 配置"></a>Anaconda + vscode 配置</h3><p><a href="https://www.jianshu.com/p/ef1ae10ba950">https://www.jianshu.com/p/ef1ae10ba950</a></p>
<h3 id="如果提示pip的版本过低-就使用下面的命令升级pip"><a href="#如果提示pip的版本过低-就使用下面的命令升级pip" class="headerlink" title="如果提示pip的版本过低,就使用下面的命令升级pip"></a>如果提示pip的版本过低,就使用下面的命令升级pip</h3><p><code>pip install -i https://pypi.tuna.tsinghua.edu.cn/simple pip -U</code></p>
<h3 id="code-runner-输出乱码"><a href="#code-runner-输出乱码" class="headerlink" title="code-runner 输出乱码"></a>code-runner 输出乱码</h3><p>参考这个文章解决  <a href="https://www.cnblogs.com/zhaoshizi/p/9050768.html">https://www.cnblogs.com/zhaoshizi/p/9050768.html</a>  </p>
<p>在项目下 <code>.vscode/settings.json</code> 配置python的路径以及 code-runner的执行路径,设置成全局的也行吧</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;python.pythonPath&quot;</span>: <span class="string">&quot;F:\\ProgramData\\Anaconda3\\envs\\tensorflow&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;code-runner.executorMap&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;python&quot;</span>: <span class="string">&quot;set PYTHONIOENCODING=utf8 &amp;&amp; F:\\ProgramData\\Anaconda3\\envs\\tensorflow\\python.exe&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>试下tensorflow官网的例子,能跑起来就是成功了。有时候下载测试数据集的时候会失败，多试几次就好了</p>
]]></content>
      <tags>
        <tag>TensorFlow</tag>
      </tags>
  </entry>
  <entry>
    <title>快速搭建个人博客</title>
    <url>/2017/02/06/%E5%8D%9A%E5%AE%A2/2017-02-06-%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<blockquote>
<p>正所谓前人栽树，后人乘凉。</p>
<p>感谢<a href="https://github.com/huxpro">Huxpro</a>提供的博客模板</p>
<p><a href="http://qiubaiying.top/">我的的博客</a></p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>从 Jekyll 到 GitHub Pages 中间踩了许多坑，终于把我的个人博客<a href="http://qiubaiying.top/">BY Blog</a>搭建出来了。。。</p>
<p>本教程针对的是不懂技术又想搭建个人博客的小白，操作简单暴力且快速。当然懂技术那就更好了。</p>
<p>看看看博客的主页样式：</p>
<p><a href="http://qiubaiying.github.io/"><img src="http://upload-images.jianshu.io/upload_images/2178672-51a2fe6fbe24d1cd.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a></p>
<p>在手机上的布局：</p>
<p><a href="http://qiubaiying.github.io/"><img src="http://upload-images.jianshu.io/upload_images/2178672-d58bb45f9faedb70.jpg"></a></p>
<p>废话不多说了，开始进入正文。</p>
<h1 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h1><h3 id="从注册一个Github账号开始"><a href="#从注册一个Github账号开始" class="headerlink" title="从注册一个Github账号开始"></a>从注册一个Github账号开始</h3><p>我采用的搭建博客的方式是使用 <a href="https://pages.github.com/">GitHub Pages</a> + <a href="http://jekyll.com.cn/">jekyll</a> 的方式。</p>
<p>要使用 GitHub Pages，首先你要注册一个<a href="https://github.com/">GitHub</a>账号，GitHub 是全球最大的同性交友网站(吐槽下程序员~)，你值得拥有。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2178672-e65e5cda50f38cef.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<h3 id="拉取我的博客模板"><a href="#拉取我的博客模板" class="headerlink" title="拉取我的博客模板"></a>拉取我的博客模板</h3><p>注册完成后搜索 <code>qiubaiying.github.io</code> 进入<a href="https://github.com/qiubaiying/qiubaiying.github.io">我的仓库</a></p>
<p><img src="http://upload-images.jianshu.io/upload_images/2178672-1b234fb8549e58aa.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>点击右上角的 <strong>Fork</strong> 将我的仓库拉倒你的账号下</p>
<p>稍等一下，点击刷新，你会看到<strong>Fork</strong>了成功的页面</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2178672-b2347768a1f2d993.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<h3 id="修改仓库名"><a href="#修改仓库名" class="headerlink" title="修改仓库名"></a>修改仓库名</h3><p>点击<strong>settings</strong>进入设置</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2178672-f47b7e4802de6a34.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p id = "Rename"></p>
修改仓库名为 `你的Github账号名.github.io`，然后 Rename

<p><img src="http://upload-images.jianshu.io/upload_images/2178672-ca3d843e526cdd5b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>这时你在在浏览器中输入 <code>你的Github账号名.github.io</code> 例如:<code>baiyingqiu.github.io</code></p>
<p>你将会看到如下界面</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2178672-96b5db55df9db422.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>说明已经成功一半了😀。。。当然，还需要修改博客的配置才能变成你的博客。</p>
<p>若是出现</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2178672-cfd55a22902a9d2c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>则需要 <a href="#Rename">检查一下你的仓库名是否正确</a></p>
<h3 id="整个网站结构"><a href="#整个网站结构" class="headerlink" title="整个网站结构"></a>整个网站结构</h3><p>修改Blog前我们来看看Jekyll 网站的基础结构，当然我们的网站比这个复杂。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">├── _config.yml</span><br><span class="line">├── _drafts</span><br><span class="line">|   ├── begin-with-the-crazy-ideas.textile</span><br><span class="line">|   └── on-simplicity-in-technology.markdown</span><br><span class="line">├── _includes</span><br><span class="line">|   ├── footer.html</span><br><span class="line">|   └── header.html</span><br><span class="line">├── _layouts</span><br><span class="line">|   ├── default.html</span><br><span class="line">|   └── post.html</span><br><span class="line">├── _posts</span><br><span class="line">|   ├── 2007-10-29-why-every-programmer-should-play-nethack.textile</span><br><span class="line">|   └── 2009-04-26-barcamp-boston-4-roundup.textile</span><br><span class="line">├── _data</span><br><span class="line">|   └── members.yml</span><br><span class="line">├── _site</span><br><span class="line">├── img</span><br><span class="line">└── index.html</span><br></pre></td></tr></table></figure>

<p>很复杂看不懂是不是，不要紧，你只要记住其中几个OK了</p>
<ul>
<li><code>_config.yml</code> 全局配置文件</li>
<li><code>_posts</code>    放置博客文章的文件夹</li>
<li><code>img</code>    存放图片的文件夹</li>
</ul>
<p>其他的想继续深究可以<a href="http://jekyll.com.cn/docs/structure/">看这里</a></p>
<h3 id="修改博客配置"><a href="#修改博客配置" class="headerlink" title="修改博客配置"></a>修改博客配置</h3><p>来到你的仓库，找到<code>_config.yml</code>文件,这是网站的全局配置文件。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2178672-c23d4a5d67c88084.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>点击修改</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2178672-b37268df7a7852ca.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>然后编辑<code>_config.yml</code>的内容</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2178672-0c8750f5a18dbe03.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>接下来我们来详细说说以下配置文件的内容：</p>
<h4 id="基础设置"><a href="#基础设置" class="headerlink" title="基础设置"></a>基础设置</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Site settings</span><br><span class="line">title: You Blog    				  	#你博客的标题</span><br><span class="line">SEOTitle: 你的博客 | You Blog    	 #显示在浏览器上搜索的时候显示的标题</span><br><span class="line">header-img: img&#x2F;post-bg-rwd.jpg  	#显示在首页的背景图片</span><br><span class="line">email: You@gmail.com	</span><br><span class="line">description: &quot;You Blog&quot;  			 #网站介绍</span><br><span class="line">keyword: &quot;BY, BY Blog, 柏荧的博客, qiubaiying, 邱柏荧, iOS, Apple, iPhone&quot; #关键词</span><br><span class="line">url: &quot;https:&#x2F;&#x2F;qiubaiying.github.io&quot;          # 这个就是填写你的博客地址</span><br><span class="line">baseurl: &quot;&quot;      # 这个我们不用填写</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="侧边栏"><a href="#侧边栏" class="headerlink" title="侧边栏"></a>侧边栏</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Sidebar settings</span><br><span class="line">sidebar: true                           # 是否开启侧边栏.</span><br><span class="line">sidebar-about-description: &quot;说点装逼的话。。。&quot;</span><br><span class="line">sidebar-avatar:&#x2F;img&#x2F;avatar-by.JPG      # 你的个人头像 这里你可以改成我在img文件夹中的两张备用照片 img&#x2F;avatar-m 或 avatar-g</span><br></pre></td></tr></table></figure>
<h4 id="社交账号"><a href="#社交账号" class="headerlink" title="社交账号"></a>社交账号</h4><p>展示你的其他社交平台</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2178672-ec775a22f76e2f40.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>在下面你的社交账号的用户名就可以了，若没有可不用填</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># SNS settings</span><br><span class="line">RSS: false</span><br><span class="line">weibo_username:     username</span><br><span class="line">zhihu_username:     username</span><br><span class="line">github_username:    username</span><br><span class="line">facebook_username:  username</span><br><span class="line">jianshu_username:	jianshu_id</span><br></pre></td></tr></table></figure>

<p>新加入了<strong>简书</strong>，<code>jianshu_id</code> 在你打开你的简书主页后的地址如：<code>http://www.jianshu.com/u/e71990ada2fd</code>中，后面这一串数字：<code>e71990ada2fd </code></p>
<h4 id="评论系统"><a href="#评论系统" class="headerlink" title="评论系统"></a>评论系统</h4><p>博客中使用的是 <a href="https://disqus.com/">Disqus</a> 评论系统，在 <a href="https://disqus.com/">官网</a> 注册帐号后，按下面的步骤简单的配置即可：</p>
<p>进入 <a href="https://disqus.com/home/settings/profile/">设置页面</a> 配置个人信息</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2178672-904ecb30c536c73b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="配置 Disqus 个人信息"></p>
<p>找到 <strong>Username</strong></p>
<p><img src="http://upload-images.jianshu.io/upload_images/2178672-19d1b9e7d2624bfb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Disqus Account"></p>
<p>这个 <strong>Username</strong>  就是我们 <code>_config.yml</code> 中 <code>disqus_username</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Disqus settings（https:&#x2F;&#x2F;disqus.com&#x2F;）</span><br><span class="line">disqus_username: qiubaiying</span><br></pre></td></tr></table></figure>

<blockquote>
<p>很对人反映 Disqus 评论插件加载不出来，因为 Disqus 在国内加载缓慢，所以我新集成了 Gitalk 评论插件（感谢<a href="https://github.com/FeDemo">@FeDemo</a>的推荐），喜欢折腾的朋友可以看这篇：<a href="http://qiubaiying.top/2017/12/19/%E4%B8%BA%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0-Gitalk-%E8%AF%84%E8%AE%BA%E6%8F%92%E4%BB%B6/">《为博客添加 Gitalk 评论插件》</a>。 我已经在<code>_config.yml</code> 配置就好了，只需要填写参数可以了。</p>
</blockquote>
<h4 id="网站统计"><a href="#网站统计" class="headerlink" title="网站统计"></a>网站统计</h4><p>集成了 <a href="http://tongji.baidu.com/web/welcome/login">Baidu Analytics</a> 和 <a href="http://www.google.cn/analytics/">Google Analytics</a>，到各个网站注册拿到track_id替换下面的就可以了</p>
<p>这是我的 Google Analytics</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2178672-c36b895c53196fdb.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p><strong>不要使用我的track_id</strong>😂。。。</p>
<p>若不想启用统计，直接删除或注释掉就可以了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Analytics settings</span><br><span class="line"># Baidu Analytics</span><br><span class="line">ba_track_id: 396d620431acacbf4689e5c281720f00</span><br><span class="line"></span><br><span class="line"># Google Analytics</span><br><span class="line">ga_track_id: &#39;UA-90855596-1&#39;            # Format: UA-xxxxxx-xx</span><br><span class="line">ga_domain: auto</span><br></pre></td></tr></table></figure>

<h4 id="好友"><a href="#好友" class="headerlink" title="好友"></a>好友</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">friends: [</span><br><span class="line">    &#123;</span><br><span class="line">        title: &quot;简书·BY&quot;,</span><br><span class="line">        href: &quot;http:&#x2F;&#x2F;www.jianshu.com&#x2F;u&#x2F;e71990ada2fd&quot;</span><br><span class="line">    &#125;,&#123;</span><br><span class="line">        title: &quot;Apple&quot;,</span><br><span class="line">        href: &quot;https:&#x2F;&#x2F;apple.com&quot;</span><br><span class="line">    &#125;,&#123;</span><br><span class="line">        title: &quot;Apple Developer&quot;,</span><br><span class="line">        href: &quot;https:&#x2F;&#x2F;developer.apple.com&#x2F;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h4 id="保存"><a href="#保存" class="headerlink" title="保存"></a>保存</h4><p>讲网页拉倒底部，点击 <code>Commit changes</code> 提交保存</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2178672-0781006b5d15d149.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>再次进入你的主页，</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2178672-a49ee2975d524c93.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>恭喜你，你的个人博客搭建完成了😀。</p>
<h1 id="写文章"><a href="#写文章" class="headerlink" title="写文章"></a>写文章</h1><p>利用 Github网站 ，我们可以不用学习<a href="https://git-scm.com/">git</a>，就可以轻松管理自己的博客</p>
<p>对于轻车熟路的程序猿来说，使用git管理会更加方便。。。</p>
<h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><p>文章统一放在网站根目录下的 <code>_posts</code> 的文件夹中。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2178672-fb74cdc11a950bd4.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>创建一个文件</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2178672-9a47b2074362e570.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>在下面写文章，和标题，还能实时预览，最后提交保存就能看到自己的新文章了。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2178672-88acd9e29fa3ae8a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><p>每一篇文章文件命名采用的是<code>2017-02-04-Hello-2017.md</code>时间+标题的形式，空格用<code>-</code>替换连接。</p>
<p>文件的格式是 <code>.md</code> 的 <a href="http://sspai.com/25137/"><strong>MarkDown</strong></a> 文件。</p>
<p>我们的博客文章格式采用是 <strong>MarkDown</strong>+ <strong>YAML</strong> 的方式。</p>
<p><a href="http://www.ruanyifeng.com/blog/2016/07/yaml.html?f=tt"><strong>YAML</strong></a> 就是我们配置 <code>_config</code>文件用的语言。</p>
<p><a href="http://sspai.com/25137/"><strong>MarkDown</strong></a> 是一种轻量级的「标记语言」，很简单。<a href="http://sspai.com/25137">花半个小时看一下</a>就能熟练使用了</p>
<p>大概就是这么一个结构。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">layout:     post   				    # 使用的布局（不需要改）</span><br><span class="line">title:      My First Post 				# 标题 </span><br><span class="line">subtitle:   Hello World, Hello Blog #副标题</span><br><span class="line">date:       2017-02-06 				# 时间</span><br><span class="line">author:     BY 						# 作者</span><br><span class="line">header-img: img&#x2F;post-bg-2015.jpg 	#这篇文章标题背景图片</span><br><span class="line">catalog: true 						# 是否归档</span><br><span class="line">tags:								#标签</span><br><span class="line">    - 生活</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">## Hey</span><br><span class="line">&gt;这是我的第一篇博客。</span><br><span class="line"></span><br><span class="line">进入你的博客主页，新的文章将会出现在你的主页上.</span><br></pre></td></tr></table></figure>

<p>按格式创建文章后，提交保存。进入你的博客主页，新的文章将会出现在你的主页上.</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2178672-f4d5bb65ae3abd00.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>到这里，恭喜你！</p>
<p>你已经成功搭建了自己的个人博客以及学会在博客上撰写文字的技能了（是不是有点小兴奋🙈）。</p>
<h4 id="首页标签"><a href="#首页标签" class="headerlink" title="首页标签"></a>首页标签</h4><p>在首页可以看到这些特色标签，当你的文章出现相同标签（默认相同的<strong>标签数量大于1</strong>），才会自动生成。</p>
<p>所以当你只放一篇文章的时候是不会出现标签的。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2178672-9281b7176c456f92.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>建站的初期，博客比较少，若你想直接在首页生成比较多的标签。你可以在 <code>_congfig.yml</code>中找到这段：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Featured Tags</span><br><span class="line">featured-tags: true                     # 是否使用首页标签</span><br><span class="line">featured-condition-size: 1              # 相同标签数量大于这个数，才会出现在首页</span><br></pre></td></tr></table></figure>

<p>将其修改为<code>featured-condition-size: 0</code>, 这样只有一个标签时也会出现在首页了。</p>
<p>相反，当你博客比较多，标签也很多时，这时你就需要改回 <code>1</code> 甚至是 <code>2</code> 了。</p>
<h1 id="自定义域名"><a href="#自定义域名" class="headerlink" title="自定义域名"></a>自定义域名</h1><p>搭建好博客之后 你可能不想直接使用 <a href="http://baiyingqiu.github.io/">baiyingqiu.github.io</a> 这么长的博客域名吧, 想换成想 <a href="http://qiubaiying.top/">qiubaiying.top</a> 这样简短的域名。那我们开始吧！</p>
<h4 id="购买域名"><a href="#购买域名" class="headerlink" title="购买域名"></a>购买域名</h4><p>首先，你必须购买一个自己的域名。</p>
<p>我是在<a href="https://wanwang.aliyun.com/domain/?spm=5176.8006371.1007.dnetcndomain.q1ys4x">阿里云</a>购买的域名</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2178672-ef3844cab15e35ff.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>用<strong>阿里云</strong> app也可以注册域名，域名的价格根据后缀的不同和域名的长度而分，比如我这个 <code>qiubaiying.top</code> 的域名第一年才只要4元~</p>
<p>域名尽量选择短一点比较好记住，注意，不能选择中文域名，比如 <code>张三.top</code> ,GitHub Pages <strong>无法处理中文域名</strong>，会导致你的域名在你的主页上使用。</p>
<p>注册的步骤就不在介绍了</p>
<h4 id="解析域名"><a href="#解析域名" class="headerlink" title="解析域名"></a>解析域名</h4><p>注册好域名后，需要将域名解析到你的博客上</p>
<p>管理控制台 → 域名与网站（万网） → 域名</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2178672-9a75bba50d1b14d7.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>选择你注册好的域名，点击解析</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2178672-0968a8dd2045f4fd.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>添加解析</p>
<p>分别添加两个<code>A</code> 记录类型,</p>
<p>一个主机记录为 <code>www</code>,代表可以解析 <code>www.qiubaiying.top</code>的域名</p>
<p>另一个为 <code>@</code>, 代表 <code>qiubaiying.top</code></p>
<p>记录值就是我们博客的IP地址，是 GitHub Pagas 在美国的服务器的地址 <code>151.101.100.133</code></p>
<p><img src="http://upload-images.jianshu.io/upload_images/2178672-0769a93bc487e9d8.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>可以通过 <a href="http://ip.chinaz.com/">这个网站</a>  或者直接在终端输入<code>ping 你的地址</code>，查看博客的IP</p>
<pre><code>ping qiubaiying.github.io
</code></pre>
<p>细心地你会发现所有人的博客都解析到 <code>151.101.100.133</code> 这个IP。</p>
<p>然后 GitHub Pages 再通过 CNAME记录 跳转到你的主页上。</p>
<h4 id="修改CNAME"><a href="#修改CNAME" class="headerlink" title="修改CNAME"></a>修改CNAME</h4><p>最后一步，只需要修改 我们github仓库下的 <strong>CNAME</strong> 文件。</p>
<p>选择 <strong>CNAME</strong> 文件</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2178672-a422f3dab436dfb7.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>使用的注册的域名进行替换,然后提交保存</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2178672-6e613004fb410b44.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>这时，输入你自己的域名，就可以解析到你的主页了。</p>
<p>大功告成！</p>
<h1 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h1><p>若你对博客模板进行修改，你就要看看 Jekyll 的<a href="http://jekyll.com.cn/">开发文档</a>,是中文文档哦，对英语一般的朋友简直是福利啊（比如说我😀）。</p>
<p>还要学习 <strong>Git</strong> 和 <strong>GitHub</strong> 的工作机制了及使用。</p>
<p>你可以先看看这个<a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/">git教程</a>，对git有个初步的了解后，那么相信你就能将自己图片传到GitHub仓库上，或者可以说掌握了 <strong>使用git管理自己的GitHub仓库</strong> 的技能呢。</p>
<p>对于轻车熟路的程序猿来说，这篇教程就算就结束了，因为下面的内容对于你们来说 so eazy~</p>
<p>但相信很多小白都一脸懵逼，那我们继续👇。</p>
<h1 id="利用GithHub-Desktop管理GitHub仓库"><a href="#利用GithHub-Desktop管理GitHub仓库" class="headerlink" title="利用GithHub Desktop管理GitHub仓库"></a>利用GithHub Desktop管理GitHub仓库</h1><p><a href="https://desktop.github.com/">GithHub Desktop</a> 是 <strong>GithHub</strong> 推出的一款管理GitHub仓库的桌面软件，换句话说就是将你在<strong>Github</strong>上的文件同步到本地电脑上，并将修改后的文件同步到<strong>Github</strong>远程仓库。</p>
<h4 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h4><p>点击图片进入下载页面，选择对应的平台进行下载</p>
<p><a href="https://desktop.github.com/"><img src="http://upload-images.jianshu.io/upload_images/2178672-6022ba3938b3088e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></a></p>
<p>下面以<strong>Mac</strong>平台为例：</p>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>将下载好的文件解压，将这只小猫拖到应用程序文件夹中</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2178672-8f8c27f4e5c72276.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>就可以在<strong>Launchpad</strong>找到这只小猫咪~</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2178672-0f2da4717361459c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<h4 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h4><p>点开应用,会弹出<strong>登录</strong>框，</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2178672-adb7d6824e471ef5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>输入你的<strong>GitHub</strong>账号和密码进行登录</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2178672-2d7c407ebddbb44f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>登录后关闭窗口</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2178672-93cdccc42024914b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>然后返回引导窗，一直按 <strong>Continue</strong> 继续</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2178672-450ccef6b1ab7b0a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p><strong>Continue</strong></p>
<p><img src="http://upload-images.jianshu.io/upload_images/2178672-06b6e6792472ecae.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>还是<strong>Continue</strong>~<br><img src="http://upload-images.jianshu.io/upload_images/2178672-681a6c455f6b512f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>进入主界面，先 <strong>右键Remve</strong> 删除这个用户指导，贼烦~</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2178672-604f6f23b8fab6f3.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<h4 id="克隆仓库"><a href="#克隆仓库" class="headerlink" title="克隆仓库"></a>克隆仓库</h4><p>选择你的仓库克隆到本地</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2178672-45ddcd27e2f858a1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/2178672-625be1220fea36b6.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<h4 id="管理仓库"><a href="#管理仓库" class="headerlink" title="管理仓库"></a>管理仓库</h4><p>现在文件夹中打开</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2178672-92c1616af56b501a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>打开后你会的发现文件结构和你在Github上的一模一样~</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2178672-bf3580ae1cd9a29e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>你最先关心的可能是你的头像~在<strong>img</strong>文件夹中把替换我的头像就好了。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2178672-c9421d64538c3ba6.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>不仅是图片，所有在Github上的的操作都可以进行。</p>
<h4 id="保存修改"><a href="#保存修改" class="headerlink" title="保存修改"></a>保存修改</h4><p>当你对仓库文件夹的文件下进行修改、添加或删除时，都可以在 <strong>GitHub Desktop</strong> 中看到</p>
<p>例如我在 <code>img</code> 中添加了一张图片 <code>avatar-demo.png</code> 添加了一张图片</p>
<p>就可以在看到<strong>GitHub Desktop</strong>显示了我的修改</p>
<p>保存修改只要按 <strong>Commit to master</strong>，然后可以写上你的修改说明</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2178672-4bfbfec37cbb8eb6.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<h4 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h4><p>将修改同步到 <strong>GitHub</strong> 远程仓库上只需要一步：点击右上角的<strong>同步按钮</strong></p>
<p><img src="http://upload-images.jianshu.io/upload_images/2178672-3c2ee8234a7f1832.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<h4 id="完成"><a href="#完成" class="headerlink" title="完成"></a>完成</h4><p>打开你的GitHub上的仓库，你就可以看到已经和本地同步了</p>
<p>可以看到你提交的详情： <code>add img</code> </p>
<p><img src="http://upload-images.jianshu.io/upload_images/2178672-293bdd4cbee0e9e3.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>这样，你已经能轻松管理自己的博客了。</p>
<p>想上传头像，背景，或者是删掉你不要的图片（我的头像😏）已经是 so eazy了吧~</p>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>你在 <strong>GitHub</strong> 网站上进行 <strong>Commit</strong> 操作后，需要在<strong>GitHub Desktop</strong>上按一下 <strong>同步按键</strong> 才能同步网站上的修改到你的本地。</p>
<h1 id="修改个人介绍"><a href="#修改个人介绍" class="headerlink" title="修改个人介绍"></a>修改个人介绍</h1><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fme0poz7gqj30vq0l8whh.jpg"></p>
<p>修改个人介绍需要修改根目录下的 <code>about.html</code> 文件</p>
<p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fme0rna33tj30bw0bntah.jpg"></p>
<p>看不懂 HTML 标签？没关系，对照着修改就好了~ 还有注意这个有中英介绍</p>
<p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fme0sbvmmcj30zp0os7ap.jpg"></p>
<h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><p>最近有很多人给我提问题，我这边总结一下</p>
<h4 id="配置文件修改后没有效果"><a href="#配置文件修改后没有效果" class="headerlink" title="配置文件修改后没有效果"></a>配置文件修改后没有效果</h4><p>刷新几遍浏览器就好了~</p>
<p>不行的话，先清除浏览器缓存再试试。</p>
<h4 id="404错误"><a href="#404错误" class="headerlink" title="404错误"></a>404错误</h4><ol>
<li>检查你的仓库名是否有按照要求填写</li>
<li>确定 <strong>Fork</strong> 的是不是我的仓库~</li>
</ol>
<h4 id="修改CNAME文件，域名还是不变"><a href="#修改CNAME文件，域名还是不变" class="headerlink" title="修改CNAME文件，域名还是不变"></a>修改CNAME文件，域名还是不变</h4><p>清除浏览器缓存就OK~</p>
<h4 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h4><p>直接在评论中提出来或私信我，我会一一替大家解决的😀</p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>最近有人往我的远程仓库不停的 <strong>push</strong>，一天连收几十封邮件！例如像这样的</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2178672-1347f2cc9a4a8dc8.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>原因大多是直接Clone了我的仓库到本地，<strong>没有删除我的远程仓库地址</strong>，添加完自己的仓库地址后，一口气推送到所有远程仓库（包括我的😂）~</p>
<p>打扰了我的工作和生活~</p>
<p>所以，<strong>请不要往我的仓库上推送分支</strong>！</p>
<p>我发现一个问题是，很多人每次修改博客的内容都commit一次到远程仓库，然后再查看修改结果，这样效率非常低！</p>
<h4 id="来，上车！"><a href="#来，上车！" class="headerlink" title="来，上车！"></a>来，上车！</h4><h2 id="在本地调试博客"><a href="#在本地调试博客" class="headerlink" title="在本地调试博客"></a>在本地调试博客</h2><blockquote>
<p>注：下面的操作是在 <strong>Mac</strong> 终端进行的。<br><strong>Windows</strong> 环境下的配置请参考 <a href="http://www.jianshu.com/u/a13e7484dc21">@梦幻之云</a> 提供的 <a href="https://agcaiyun.cn/2017/09/10/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/">这篇文章</a>。</p>
</blockquote>
<p>有心的同学在 <a href="http://jekyllcn.com/">jekyll官网</a> 就会发现 <code>jekyll</code> 的 提供的实例代码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">~ $ gem install jekyll bundler</span><br><span class="line">~ $ jekyll new my-awesome-site</span><br><span class="line">~ $ cd my-awesome-site</span><br><span class="line">~&#x2F;my-awesome-site $ bundle install</span><br><span class="line">~&#x2F;my-awesome-site $ bundle exec jekyll serve</span><br><span class="line"># &#x3D;&gt; 打开浏览器 http:&#x2F;&#x2F;localhost:4000</span><br></pre></td></tr></table></figure>


<p>这段命令创建了一个默认的 <code>jekll</code> 网站，然后在本机的 4000 窗口展示。聪明的你应该发现怎么做了吧~</p>
<p>安装 <code>jekyll</code>和 <code>jekyll bundler</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gem install jekyll</span><br><span class="line">$ gem install jekyll bundler</span><br></pre></td></tr></table></figure>

<p>进入你的 <strong>Blog 所在目录</strong>，然后创建本地服务器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ jekyll s</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后会显示 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> Auto-regeneration: enabled for &#39;&#x2F;Users&#x2F;baiying&#x2F;Blog&#39;</span><br><span class="line">Configuration file: &#x2F;Users&#x2F;baiying&#x2F;Blog&#x2F;_config.yml</span><br><span class="line">    Server address: http:&#x2F;&#x2F;127.0.0.1:4000&#x2F;</span><br><span class="line">  Server running... press ctrl-c to stop.</span><br></pre></td></tr></table></figure>

<p>你就可以在 <a href="http://127.0.0.1:4000/">http://127.0.0.1:4000/</a> 看到你的博客，你对本地博客的修改都会在这个地址进行显示，这大大提高了对博客的配置效率。</p>
<p>使用<code>ctrl+c</code>就可以停止 <strong>serve</strong></p>
<h1 id="Star"><a href="#Star" class="headerlink" title="Star"></a>Star</h1><p>若本教程顺利帮你搭建了自己的个人博客，请不要 <strong>害羞</strong>，给我的 <a href="https://github.com/qiubaiying/qiubaiying.github.io">github仓库</a> 点个 <strong>star</strong> 吧！</p>
<p>因为最近发现 Fork 将近破百，加上直接 Clone 仓库的，保守估计已经帮助上百人成功的搭建了自己的博客，<del>可是 Star 却仅仅只有 <strong>12</strong>！可能还是做的不够好吧！</del>现在已经破百了，感谢大家的Star！</p>
<h3 id="别无他求，点个-Star-吧！"><a href="#别无他求，点个-Star-吧！" class="headerlink" title="别无他求，点个 Star 吧！"></a><strong>别无他求，点个 <a href="https://github.com/qiubaiying/qiubaiying.github.io">Star</a> 吧</strong>！</h3><p><img src="http://upload-images.jianshu.io/upload_images/2178672-768a38ee9fb0df28.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p><strong>心满意足！</strong></p>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><h4 id="修改网站的-icon"><a href="#修改网站的-icon" class="headerlink" title="修改网站的 icon"></a>修改网站的 <strong>icon</strong></h4><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1flgh6k23ppj30ad00uq2t.jpg"></p>
<p>要修改如图所示的网站 <strong>icon</strong>：</p>
<p>在博客 <code>img</code> 目录下找到并替换 <code>favicon.ico</code> 这个图标即可，图标尺寸为<code>32x32</code>。</p>
<p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1flghahch1oj30gu09y419.jpg"></p>
<h4 id="修改主页的座右铭"><a href="#修改主页的座右铭" class="headerlink" title="修改主页的座右铭"></a>修改主页的座右铭</h4><p>最近有不少小伙伴私信我：<strong>如何修改主页的座右铭？</strong></p>
<p>就是这个：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2178672-31dc0068f256aca3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>很简单，找到博客目录下的 <strong>index.html</strong> 文件，修改这句话就可以了。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2178672-9e4785654523bf07.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<h4 id="如何在博客文章中上插入图片"><a href="#如何在博客文章中上插入图片" class="headerlink" title="如何在博客文章中上插入图片"></a>如何在博客文章中上插入图片</h4><p>博客的文章用的是 MarkDown 格式，如果没用过 MarkDown 真的 强烈推荐 <a href="http://sspai.com/25137">花半个小时学习一下</a>。</p>
<p>MarkDown 中添加图片的形式是 :<code>![](图片的URL)</code></p>
<p>例如：</p>
<p><code>![MarkDown示例图片](http://upload-images.jianshu.io/upload_images/2178672-eb2effd6b942a500.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</code>就会显示下面这张图片</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2178672-98965f66db8f5856.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="MarkDown示例图片"></p>
<p><code>https://ws3.sinaimg.cn/large/006tNc79gy1fj9xhjzobbj30yg0my75z.jpg</code>就是这张图片的URL，我们可以在浏览器输入这个URL找到或下载这张图片。</p>
<p>所以，要在 MacDown 中插入图片，这张图片就需要上传到图床（网上），然后在引<br>用这张图片的URL。</p>
<h5 id="将图片上传到图床"><a href="#将图片上传到图床" class="headerlink" title="将图片上传到图床"></a>将图片上传到图床</h5><p>Mac 上的图床神器：iPic  </p>
<p>直接在App Store上下载，谁用谁知道！</p>
<p>使用方法很简单，直接拖动图片到 P 图标上，或者选中图片按快捷键 <code>⌘+U</code>，就能请示上传。</p>
<p>上传成功就能直接粘贴图片的URL。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2178672-7399aeaced6f1e29.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="iPic"></p>
<p>用 iPic 上传图片后，获取URL插入文章中就可以了。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2178672-4be76fb02708de5e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="iPic上传图片"></p>
<h4 id="推荐几个好用软件"><a href="#推荐几个好用软件" class="headerlink" title="推荐几个好用软件"></a>推荐几个好用软件</h4><h5 id="MarkDown编辑器"><a href="#MarkDown编辑器" class="headerlink" title="MarkDown编辑器"></a>MarkDown编辑器</h5><p><a href="https://macdown.uranusjr.com/">MacDown</a>：可能是Mac上最好的MacDown编辑器了  </p>
<p><img src="http://upload-images.jianshu.io/upload_images/2178672-2226239a63278302.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<h5 id="图片压缩工具"><a href="#图片压缩工具" class="headerlink" title="图片压缩工具"></a>图片压缩工具</h5><p><a href="https://imageoptim.com/">ImageOptim</a></p>
<p>对于我们的博客来说，图片越大，加载速度越慢。</p>
<p>不信你用手机打开你的博客试试~</p>
<p>所以有必要对我们上传到博客网站中的图片：指的是你的头像，首页背景图片，文章背景图片等。对于博客文章中插入的图片，其实也可以压缩了再上传。</p>
<p>对博客中的所有图片进行压缩：</p>
<p>看看压缩结果，最高的一张压缩了78.7%，这简直是太可怕了！</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2178672-0f8e643fa1da8674.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ImageOptim压缩图片"></p>
<p>好了，现在个人博客的加载速度估计要起飞了~</p>
<h1 id="最后要说个事情"><a href="#最后要说个事情" class="headerlink" title="最后要说个事情"></a>最后要说个事情</h1><p>我在博客中的文章，你们可以保留，让更多需要帮助人的看到，当然也可以删除。</p>
<p>但是，我发现居然有人把文章的作者改成了自己，然后当成自己的文章放在自己的博客上，这就令人感到气愤了。</p>
<p>比如说向我请教问题的这位：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2178672-ed45ebafec7f5d34.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>我在博客中的每篇文章都是我一字一句敲出来的，转载的文章我也注明了出处，表示对原作者的尊重。同时也希望大家都能尊重我的付出。</p>
<p>谢谢~</p>
]]></content>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
</search>
